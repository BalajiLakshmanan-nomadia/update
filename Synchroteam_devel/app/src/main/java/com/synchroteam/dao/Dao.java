package com.synchroteam.dao;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.media.ExifInterface;
import android.os.Environment;
import android.text.TextUtils;
import android.util.Log;

import com.sap.ultralitejni17.ConfigPersistent;
import com.sap.ultralitejni17.Connection;
import com.sap.ultralitejni17.DatabaseManager;
import com.sap.ultralitejni17.PreparedStatement;
import com.sap.ultralitejni17.ResultSet;
import com.sap.ultralitejni17.StreamHTTPParms;
import com.sap.ultralitejni17.StreamHTTPSParms;
import com.sap.ultralitejni17.SyncParms;
import com.sap.ultralitejni17.ULjException;
import com.sap.ultralitejni17.SyncObserver;
import com.sap.ultralitejni17.SyncResult;

import com.synchroteam.beans.AttachmentsBeans;
import com.synchroteam.beans.AuthExpiryModel;
import com.synchroteam.beans.CConectionsBeans;
import com.synchroteam.beans.CalendarAllJobBeans;
import com.synchroteam.beans.CatalougePieces;
import com.synchroteam.beans.Categorie;
import com.synchroteam.beans.Client;
import com.synchroteam.beans.Client_Site_Bean;
import com.synchroteam.beans.Client_Site_EquipmnentBean;
import com.synchroteam.beans.CommonJobBean;
import com.synchroteam.beans.CommonListBean;
import com.synchroteam.beans.Conge;
import com.synchroteam.beans.CurrentJobArrayListBean;
import com.synchroteam.beans.CurrentJobDataBean;
import com.synchroteam.beans.CurrentJobDataBeanNew;
import com.synchroteam.beans.CustomFieldsByVal;
import com.synchroteam.beans.Description;
import com.synchroteam.beans.Equipement;
import com.synchroteam.beans.Families;
import com.synchroteam.beans.FamiliesBean;
import com.synchroteam.beans.Famille;
import com.synchroteam.beans.GestionAcces;
import com.synchroteam.beans.GlobalTaxInvoiceList;
import com.synchroteam.beans.InventoryDialogSerialNumber;
import com.synchroteam.beans.InventoryItemBeans;
import com.synchroteam.beans.InventorySerialNumbersBeans;
import com.synchroteam.beans.InventoryStocksBeans;
import com.synchroteam.beans.Invoice_Quotation_Beans;
import com.synchroteam.beans.Invoice_Quotation_Items_Beans;
import com.synchroteam.beans.InvoicingCatalogCategoryBeans;
import com.synchroteam.beans.InvoicingCatalogSubCategoryBeans;
import com.synchroteam.beans.Item;
import com.synchroteam.beans.JobDetailsModel;
import com.synchroteam.beans.JobIncidentLogModel;
import com.synchroteam.beans.JobIncidentModel;
import com.synchroteam.beans.JobsCount;
import com.synchroteam.beans.Message_oper;
import com.synchroteam.beans.ModeleRapport;
import com.synchroteam.beans.PartCategoryNameBeans;
import com.synchroteam.beans.PendingRequestBeans;
import com.synchroteam.beans.Photo_Pda;
import com.synchroteam.beans.Quotation_Items_Beans;
import com.synchroteam.beans.ReportsCategoryItem;
import com.synchroteam.beans.ReportsJobBean;
import com.synchroteam.beans.ReportsStartAndEndTime;
import com.synchroteam.beans.SharedBlocks;
import com.synchroteam.beans.Site;
import com.synchroteam.beans.SortiePiece;
import com.synchroteam.beans.TaxRates;
import com.synchroteam.beans.TravelActivity;
import com.synchroteam.beans.TypeIntervention;
import com.synchroteam.beans.UnavailabilityBeans;
import com.synchroteam.beans.User;
import com.synchroteam.dialogs.SynchronizationErrorDialog;
import com.synchroteam.retrofit.ApiInterface;
import com.synchroteam.retrofit.Apiclient;
import com.synchroteam.retrofit.models.mobileAuth.AuthData;
import com.synchroteam.retrofit.models.syncservice.SyncService;
import com.synchroteam.synchroteam3.R;
import com.synchroteam.utils.DateFormatUtils;
import com.synchroteam.utils.KEYS;
import com.synchroteam.utils.Logger;
import com.synchroteam.utils.ReportsItems;
import com.synchroteam.utils.SharedPref;
import com.synchroteam.utils.SynchroteamUitls;
import com.synchroteam.utils.DialogUtils;

import org.joda.time.Interval;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.text.DateFormat;
import java.text.Format;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Currency;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Vector;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

import static com.sap.ultralitejni17.SyncObserver.States.RECEIVING_TABLE;
import static com.synchroteam.utils.DateFormatUtils.addTwoDateTimeStamps;
import static com.synchroteam.utils.DateFormatUtils.subtractTwoDateTimeStamps;

/***
 * Class to syncronise and handle database operation.
 * Previous developer Class
 */

/**
 * ** Commenting Out The things Not Required Currently in this file this mainly
 * include Dalkia Related Changes.
 *
 * @author ideavate.solution
 */
@SuppressLint("SimpleDateFormat")
public class Dao {

    private static final String PREVIOUS_VERSION = "/#/54";
    private static final String TAG = "Dao";
    /**
     * The script.
     */


    // for devel version 53
    // public static String script = "st_ver53".trim();

    //for devel version 54
//    public static String script = "st_ver54".trim();
//    public static String dbName = "STDB.ulj";

    //for devel version 55
    public static String script = "st_ver55".trim();
    public static String dbName = "STDB.ulj";

    private static Tables t = new Tables();

    /**
     * ***** The Below Code Commented May Be neede For Future Purpose.
     */
    // ------------------local-------------------------
    // private static String host="10.0.2.2";
    // private static String host="192.168.1.16";
    // private static int port=443; //https
    // private static int port=8081; //http

    // ******************************************** Sync variables for prod ************************
    private static String host;
    private static int port;
    private static String debug_host;
    private static int debug_port;
    /**
     * The config.
     */
    public ConfigPersistent config;
    /**
     * The connDao.
     */
    public Connection connDao;
    /**
     * Execute ddl.
     */
    PreparedStatement ps;
    /**
     * The current date format.
     */
    private String currentDateFormat = "yyyy-MM-dd HH:mm:ss";
    /**
     * The job duration format.
     */
    private SimpleDateFormat jobDurationFormat = new SimpleDateFormat("HH:mm", Locale.US);
    /**
     * The context.
     */
    private Context context;
    /**
     * The dedline header format.
     */
    private String dedlineHeaderFormat = "yyyy-MM-dd";
    /**
     * The required suspended job count check format.
     */
    private String requiredSuspendedJobCountCheckFormat = "yyyy-MM-dd";
    // ******************************************** End of code - Sync variables for prod ************************

    // ******************************************** Sync variables for Devel ***********************
    //    Development URL (http) - for Shared block feature
    //    private static String host = "demo.suiviintervention.synchroteam.com";

    //    The port.
    //    private static int port = 2560;

    //    Debug host
    //    private static String debug_host = "mobilink.synchroteam.com";

    //    Debug port
    //    private static int debug_port = 8001;
    // ******************************************** End of code - Sync variables for Devel ***********************

    private TableOrder tableOrder;
    private Boolean firstSynch = false;

    /**
     * Instantiates a new dao object.
     */
    public Dao() {
        super();
    }

    /**
     * Instantiates a new dao object.
     *
     * @param ctx the ctx
     */
    public Dao(Context ctx) {
        connectDatabase(ctx);
        tableOrder = new TableOrder();
    }

    public static int calculateInSampleSize(
            BitmapFactory.Options options, int reqWidth, int reqHeight) {
        // Raw height and width of image
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;

        if (height > reqHeight || width > reqWidth) {

            final int halfHeight = height / 2;
            final int halfWidth = width / 2;

            // Calculate the largest inSampleSize value that is a power of 2 and keeps both
            // height and width larger than the requested height and width.
            while ((halfHeight / inSampleSize) >= reqHeight
                    && (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2;
            }
        }

        return inSampleSize;
    }

    public synchronized void deleteAllTables(Context ctx) {

        deleteAllTables("t_session_nosync", ctx);
        deleteAllTables("T_ATTRIB_MESSAGES_OPER", ctx);
        deleteAllTables("T_ATTRIB_MODULES", ctx);
        deleteAllTables("T_CLIENTS", ctx);
        deleteAllTables("T_CUSTOMERS", ctx);
        deleteAllTables("T_EQUIPEMENTS_CLIENTS", ctx);
        deleteAllTables("T_TEMPS_INTERV", ctx);

        deleteAllTables("T_INTERVENTIONS", ctx);
        deleteAllTables("T_MESSAGES_OPERATEUR", ctx);
        deleteAllTables("T_PHOTOS_PDA", ctx);
        deleteAllTables("T_SAISIE_RAPPORT", ctx);
        deleteAllTables("T_SITES_CLIENTS", ctx);
        deleteAllTables("T_SORTIE_PIECE", ctx);

        deleteAllTables("T_USERS", ctx);
        // deleteAllTables("T_VAL_CUSTOM_FIELDS", ctx);
        deleteAllTables("TREF_CATEGORIE_PIECE", ctx);
        deleteAllTables("TREF_COMMENTAIRES_FILS", ctx);
        deleteAllTables("TREF_COMMENTAIRES_PERE", ctx);
        deleteAllTables("TREF_MODELE_FAMILLE", ctx);

        deleteAllTables("TREF_MODELE_ITEM", ctx);
        deleteAllTables("TREF_MODELE_RAPPORT", ctx);
        deleteAllTables("TREF_MODELE_VALUE_ITEM", ctx);
        deleteAllTables("TREF_MODULES", ctx);
        deleteAllTables("TREF_PIECES", ctx);
        deleteAllTables("TREF_STATUT_INTERVENTION", ctx);
        deleteAllTables("TREF_TRADUCTIONS", ctx);

        deleteAllTables("TREF_TRADUCTIONS_CUST", ctx);
        deleteAllTables("TREF_TYPE_INTERVENTION", ctx);
        // deleteAllTables("TREF_CUSTOM_FIELDS", ctx);
        deleteAllTables("TREF_GESTION_ACCES", ctx);
        deleteAllTables("TREF_TYPINT_RAPPORT", ctx);
        deleteAllTables("TDALKIA_LISTE_OPERATIONS", ctx);
        deleteAllTables("TDALKIA_BT_FIS", ctx);

        deleteAllTables("TDALKIA_REFUS", ctx);
        deleteAllTables("TREF_TYPE_CONGE", ctx);
        deleteAllTables("T_CONGE", ctx);
        deleteAllTables("T_ATTACHMENTS", ctx);
        deleteAllTables("T_FACTURES", ctx);
        deleteAllTables("T_LIGNES_FACTURE", ctx);
        deleteAllTables("T_TAXRATES", ctx);
        deleteAllTables("T_STOCKS", ctx);
        deleteAllTables("T_PIECE_SERIALS", ctx);
        deleteAllTables("T_PIECE_DEMANDE", ctx);

        deleteAllTables("T_SAISIE_BLOC", ctx);
        deleteAllTables("TREF_MODELE_BLOC", ctx);
        deleteAllTables("T_STOCK_PIECES", ctx);

        deleteAllTables("T_PAYMENTS", ctx);
        deleteAllTables("T_PAYMENTS_LOG", ctx);
        deleteAllTables("C_CONNECTIONS", ctx);
        deleteAllTables("T_REPRISE_PIECE", ctx);
    }

    public synchronized void deleteAllTables(String tablesname, Context ctx) {

        try {
            Log.e("DAO TABLE NAME  ", "  " + tablesname);
            ps = getConnectionObj().prepareStatement("DELETE FROM " + tablesname);
            ps.execute();

//            ps.close();
//            connDao.commit();

            //connection.commit();

            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (ps != null) {
                try {
                    ps.close();
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

    }

    /**
     * Gets connection object
     *
     * @return connection
     */
    private synchronized Connection getConnectionObj() {

        //new changes
        if (connDao == null) {
            try {
                connDao = DatabaseManager.connect(config);
            } catch (ULjException e) {
                connDao = releaseAllConnections();
                e.printStackTrace();
            } finally {
                if (connDao == null) {
                    try {
                        connDao = DatabaseManager.connect(config);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }

        return connDao;
    }

    /**
     * After 10th sync we got an exception, not a normal sync.
     * 1. start a job.
     * 2. then came back and start another one .
     * 3. Likewise, we get an exception while starting the 11th job.
     * Exception ::  "Database server connection limit exceeded".
     * Hence release all the connections and reconnect a new one.
     *
     * @return new connection object.
     */
    private synchronized Connection releaseAllConnections() {

        try {
            DatabaseManager.release();
            if (connDao != null)
                connDao.release();
            connDao = DatabaseManager.connect(config);

        } catch (Exception e) {
            Logger.printException(e);
        }
        return connDao;
    }

    /**
     * *** Model Bean.
     *
     * @param idTypeInterv the id type interv
     * @return the default modele rapport
     * @author Previous Developer
     */
    public synchronized ModeleRapport getDefaultModeleRapport(int idTypeInterv) {
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        ModeleRapport mr = null;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT b.ID_MODELE_RAPPORT,b.NM_MODELE_RAPPORT," +
                            "b.FL_DEFAULT FROM TREF_TYPINT_RAPPORT a,TREF_MODELE_RAPPORT b " +
                            "WHERE b.DT_SUPPR IS NULL AND a.ID_MODELE_RAPPORT=b.ID_MODELE_RAPPORT AND a.ID_TYPE_INTERVENTION="
                            + idTypeInterv);
            cursor = preparedStatement.executeQuery();
            if (cursor.next()) {
                mr = new ModeleRapport(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3));

            } else {
                mr = null;

            }
            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            Logger.printException(e);
            mr = null;
        }

        return mr;
    }

    /**
     * Gets the list of clients.
     *
     * @return the clients
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Client> getClients() {
        ArrayList<Client> listClt = new ArrayList<Client>();

        String query;

        query = "SELECT "
                + "ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_CP," +
                "ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT " +
                "FROM T_CLIENTS WHERE DT_SUPPR IS NULL"
                + " ORDER BY NM_CLIENT";
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }

                Client clt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)));
                listClt.add(clt);
            }

            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        Logger.output("CLients>>>>>>>>>>>>>", listClt.size() + "");
        return listClt;

    }

    public synchronized ArrayList<Client> getClientDetail(int siteClientId) {
        ArrayList<Client> listClt = new ArrayList<Client>();

        String query;

        query = "SELECT "
                + "ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT FROM T_CLIENTS "
                + " WHERE ID_CLIENT = " + siteClientId;
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                Client clt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)));
                listClt.add(clt);
            }
            cursor.close();
            preparedStatement.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return listClt;

    }

    /**
     * Gets the clients count.
     *
     * @return the clients
     */
    public synchronized int getClientsCount() {
        // ArrayList<Client> listClt = new ArrayList<Client>();
        int clientCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT count(*) FROM T_CLIENTS");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientCount = cursor.getInt(1);

            }

            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return clientCount;
    }

    /**
     * Gets the Sites Count.
     *
     * @param idClient the id client
     * @return the clients
     */
    public synchronized int getSiteCount(int idClient) {
        int siteCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT count(*) FROM T_SITES_CLIENTS WHERE  DT_SUPPR IS NULL AND ID_CLIENT="
                            + idClient);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {

                siteCount = cursor.getInt(1);
            }

            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return siteCount;
    }

    /**
     * Gets the sites for a particular client.
     *
     * @param idClient the id client
     * @return the sites for client
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Site> getSitesForClient(int idClient) {
        ArrayList<Site> listSite = new ArrayList<Site>();

        String query;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;

        query = "SELECT  ID_SITE_CLIENT,NM_SITE,ADR_SITE_RUE,ADR_SITE_VILLE,ADR_SITE_GLOBALE," +
                "ADR_SITE_COMPLEMENT,GPS_POSX_SITE,GPS_POSY_SITE,ADR_SITE_CP,ADR_SITE_PAYS,REF_CUSTOMER FROM T_SITES_CLIENTS WHERE ID_CLIENT="
                + idClient + "AND T_SITES_CLIENTS.DT_SUPPR IS NULL ORDER BY NM_SITE";

        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                Site site = new Site(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)));
                listSite.add(site);
            }
            cursor.close();
            preparedStatement.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return listSite;

    }

    public synchronized ArrayList<Site> getSitesDetail(int idSite) {
        ArrayList<Site> listSite = new ArrayList<Site>();

        String query;

        query = "SELECT  ID_SITE_CLIENT,ID_CLIENT,NM_SITE,ADR_SITE_RUE," +
                "ADR_SITE_VILLE,ADR_SITE_GLOBALE,ADR_SITE_COMPLEMENT," +
                "GPS_POSX_SITE,GPS_POSY_SITE,ADR_SITE_CP,ADR_SITE_PAYS FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT="
                + idSite;
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {

                if ((cursor.getInt(2) > 0)
                        && (getClientDetail(cursor.getInt(2)).size() != 0)) {

                    Site site = new Site(cursor.getInt(1), cursor.getInt(2),
                            encodeString(cursor.getBytes(3)),
                            encodeString(cursor.getBytes(4)),
                            encodeString(cursor.getBytes(5)),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            encodeString(cursor.getBytes(10)),
                            encodeString(cursor.getBytes(11)));
                    listSite.add(site);

                }

            }
            cursor.close();
            preparedStatement.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return listSite;

    }

    /**
     * Gets the equipments for a particular site.
     *
     * @param idClient       the id client
     * @param index          the index
     * @param idSite         the id site
     * @param equipmentCount the equipment count
     * @return the equipements for site
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Equipement> getEquipementsForSite(int idClient, int index,
                                                                    int idSite, int equipmentCount) {
        ArrayList<Equipement> listEqp = new ArrayList<Equipement>();

        String sql = "";

//
        if (idSite != -1 && idClient != -1) {
            sql = "SELECT ID_EQUIPEMENT_CLIENT,NM_EQUIPEMENT,ID_SITE_CLIENT,REF_CUSTOMER FROM T_EQUIPEMENTS_CLIENTS WHERE ID_CLIENT="
                    + idClient + " AND (ID_SITE_CLIENT=" + idSite + " ) AND T_EQUIPEMENTS_CLIENTS.DT_SUPPR IS NULL  ORDER BY NM_EQUIPEMENT";


        } else if (idSite == -1) {
            sql = "SELECT ID_EQUIPEMENT_CLIENT,NM_EQUIPEMENT,ID_SITE_CLIENT,REF_CUSTOMER,REF_CUSTOMER FROM T_EQUIPEMENTS_CLIENTS WHERE ID_CLIENT="
                    + idClient + " AND T_EQUIPEMENTS_CLIENTS.DT_SUPPR IS NULL  ORDER BY NM_EQUIPEMENT";

        } else if (idClient == -1) {

            sql = "SELECT ID_EQUIPEMENT_CLIENT,NM_EQUIPEMENT,ID_SITE_CLIENT FROM T_EQUIPEMENTS_CLIENTS WHERE ID_SITE_CLIENT=" + idSite + " AND T_EQUIPEMENTS_CLIENTS.DT_SUPPR IS NULL  ORDER BY NM_EQUIPEMENT";
        }

        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(sql);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                Equipement eqp = new Equipement(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        encodeString(cursor.getBytes(4)));
                listEqp.add(eqp);
            }

            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return listEqp;

    }


    /**
     * Gets the counts of equipments for a site.
     *
     * @param idClient the id client
     * @param idSite   the id site
     * @return the equipements for site
     */
    public synchronized int getEquipementsForSiteCount(int idClient, int idSite) {
        int equipmentCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;

        try {
            String sql = "SELECT count(*) FROM T_EQUIPEMENTS_CLIENTS  WHERE  ";
            if (idSite != -1 && idClient != -1) {
                sql += " DT_SUPPR IS NULL AND ID_CLIENT="
                        + idClient + " AND ID_SITE_CLIENT=" + idSite;

            } else if (idSite != -1) {
                sql += "DT_SUPPR IS NULL AND ID_SITE_CLIENT=" + idSite;
            } else if (idClient != -1) {
                sql += "DT_SUPPR IS NULL AND ID_CLIENT=" + idClient;
            }


            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(sql);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {

                equipmentCount = cursor.getInt(1);

            }
            Log.e("size", equipmentCount + "");

            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            Logger.printException(e);

        }

        return equipmentCount;
    }

    /**
     * Updates the new start date and end date to replan a job .
     *
     * @param idInterv the id interv
     * @param dateDeb  the date deb
     * @param dateFin  the date fin
     */
    public synchronized boolean replanifInterv(String idInterv, String dateDeb, String dateFin) {
        return executeDDL("UPDATE T_INTERVENTIONS SET DT_DEB_PREV=DATETIME('"
                + dateDeb + "'),DT_FIN_PREV=DATETIME('" + dateFin
                + "') WHERE ID_INTERVENTION='" + idInterv + "'");
    }

    /**
     * Declines a Job.
     *
     * @param idIntervention the id intervention
     */
    public synchronized void rejectIntervention(String idIntervention) {
        executeDDL("UPDATE T_INTERVENTIONS SET " + "DT_DEB_PREV = NULL,"
                + "DT_FIN_PREV = NULL," + "ID_USER = NULL,"
                + "CD_STATUT_INTERV = 0 " + "WHERE ID_INTERVENTION='"
                + idIntervention + "'");
    }

    /**
     * Close database.
     */
    public synchronized void closeDatabase() {
        try {
            if (connDao != null) {

                connDao.commit();

                connDao.release();

            }
        } catch (Exception e) {
            Logger.printException(e);
        }

    }


    //dev v51.0.3
    public synchronized CurrentJobDataBeanNew getCurrentJobsForSortingNew(Date date, int userId) {

        Vector<CommonJobBean> currentJobsBeans = new Vector<>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            // query="SELECT * FROM T_INTERVENTIONS WHERE DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd')='"+currentDate+"'";

            // System.out.println(query);
            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            }


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                CommonJobBean model = new CommonJobBean();
                model.setId(encodeString(cursor.getBytes(1)));
                model.setDesc(encodeString(cursor.getBytes(2)));
                model.setPriorite(cursor.getInt(3));
                model.setDt_deb_prev(cursor.getString(4));
                model.setDt_fin_prev(cursor.getString(5));
                model.setAdr_interv_rue(encodeString(cursor.getBytes(6)));
                model.setAdr_interv_cp(encodeString(cursor.getBytes(7)));
                model.setAdr_interv_ville(encodeString(cursor.getBytes(8)));
                model.setAdr_interv_pays(encodeString(cursor.getBytes(9)));
                model.setCd_status_interv(cursor.getInt(10));
                model.setNom_client_interv(encodeString(cursor.getBytes(11)));
                model.setNom_contact(encodeString(cursor.getBytes(12)));
                model.setTel_contact(encodeString(cursor.getBytes(13)));
                model.setNom_site_interv(encodeString(cursor.getBytes(14)));
                model.setType_Interv(encodeString(cursor.getBytes(15)));
                model.setId_model_rapport(cursor.getInt(16));
                model.setIdUser(cursor.getInt(17));
                model.setLat(cursor.getString(19));
                model.setLon(cursor.getString(18));
                model.setAdr_interv_globale(cursor.getString(20));
                model.setAdr_interv_complement(cursor.getString(21));
                model.setNo_interv(cursor.getInt(22));
                model.setNom_client_sign(cursor.getString(23));
                model.setNom_tech_sign(cursor.getString(24));
                model.setNom_facture_sign(cursor.getString(25));
                model.setNom_equipement(encodeString(cursor.getBytes(26)));
                model.setIdClient(cursor.getInt(27));
                model.setIdSite(cursor.getInt(28));
                model.setIdEquipement(cursor.getInt(29));
                model.setMobileContact(encodeString(cursor.getBytes(30)));
                model.setDt_meeting(cursor.getString(31));
                model.setRef_customer(cursor.getString(32));
                model.setId_interv_mere(cursor.getString(33));
                model.setHeaderDate(headerDate);
                model.setDtCreated(cursor.getString(36));


                model.setDt_deb_real(cursor.getString(34));
                model.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(model);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        CurrentJobDataBeanNew currentJobDataBean = new CurrentJobDataBeanNew(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    /**
     * This function Fetches:- 1.All Scheduled Jobs which are sheduled on the
     * date Passed. 2.All the started Jobs which are still running on the date
     * Passed 3.All the suspended jobs which are suspended on the date Passed.
     * 4.All the Auxillary Jobs which are scheduled on the date Passed. 5.All
     * the Auxillary Jobs which are Started if today is the current date of
     * device. 6.All the Auxillary Jobs which are suspended Which were Initially
     * started on the date Passed.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention now
     */
    public synchronized CurrentJobDataBean getCurrentJobsNearBy(Date date, int userId, String gpsX, String gpsY) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                        + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                        + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                        + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                        + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                        + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                        + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";
            }

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }


        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    /**
     * Fetches All the upcomming jobs.
     *
     * @return the all intervention next
     */
    public synchronized Vector<CommonJobBean> getAllInterventionNext() {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3 ORDER BY DT_DEB_PREV";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            String headerDate = null;
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                tmp.add(currentJobsBean);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    /**
     * Fetches All the upcomming jobs.
     *
     * @return the all intervention next
     */
    public synchronized Vector<CommonJobBean> getUpcomingJobsByLocation(String gpsX, String gpsY) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3 "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            String headerDate = null;
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                tmp.add(currentJobsBean);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    /**
     * Fetches all the job whose DT_FIN_PREV is less than current date and whose
     * last suspended date is less than current date .
     *
     * @param userId the user id
     * @return the all intervention before
     */
    public synchronized Vector<CommonJobBean> getAllInterventionBefore(int userId) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2
                    + " ORDER BY DT_DEB_PREV";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND "
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                    + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                    + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4 ORDER BY DT_DEB_PREV";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND " + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND date(DT_DEB_REAL) < CURRENT DATE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // Collections.sort(tmp, new Comparator<CommonJobBean>() {
        //
        // @Override
        // public int compare(CommonJobBean lhs, CommonJobBean rhs) {
        // return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
        // }
        //
        // });

        return tmp;
    }

    /**
     * Fetches all the job whose DT_FIN_PREV is less than current date and whose
     * last suspended date is less than current date .
     *
     * @param userId the user id
     * @return the all intervention before
     */
    public synchronized Vector<CommonJobBean> getLateJobs(int userId) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (" +
                    "( (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2
                    + ") OR ("
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                    + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                    + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4" +
                    ") OR (" +
                    "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND date(DT_DEB_REAL) < CURRENT DATE" +
                    "))"
                    + " ORDER BY DT_DEB_PREV";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        // Collections.sort(tmp, new Comparator<CommonJobBean>() {
        //
        // @Override
        // public int compare(CommonJobBean lhs, CommonJobBean rhs) {
        // return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
        // }
        //
        // });

        return tmp;
    }

    /**
     * Fetches all the job whose DT_FIN_PREV is less than current date and whose
     * last suspended date is less than current date .
     *
     * @param userId the user id
     * @return the all intervention before
     */
    public synchronized Vector<CommonJobBean> getLateJobsUpdated(int userId) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION WHERE " +
//                    "T_INTERVENTIONS.ID_USER =" + userId
//                    + " AND " +
                    "T_INTERVENTIONS.DT_SUPPR IS NULL AND (" +
                    "(T_INTERVENTIONS.CD_STATUT_INTERV in (4) AND " +
                    "T_INTERVENTIONS.DT_DEB_REAL < CURRENT TIMESTAMP) OR " +
                    "(T_INTERVENTIONS.CD_STATUT_INTERV in(1,2) AND " +
                    "T_INTERVENTIONS.DT_FIN_PREV < CURRENT TIMESTAMP)) AND " +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        Collections.sort(tmp, new Comparator<CommonJobBean>() {

            @Override
            public int compare(CommonJobBean lhs, CommonJobBean rhs) {
                return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
            }

        });


        return tmp;
    }

    /**
     * Fetches all the late jobs based on location
     *
     * @param userId the user id
     * @return the all intervention before
     */
    public synchronized Vector<CommonJobBean> getLateJobsNearByUpdated(int userId, String gpsX, String gpsY) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {


            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION WHERE " +
//                    "T_INTERVENTIONS.ID_USER =" + userId
//                    + " AND " +
                    "T_INTERVENTIONS.DT_SUPPR IS NULL AND (" +
                    "(T_INTERVENTIONS.CD_STATUT_INTERV in (4) AND " +
                    "T_INTERVENTIONS.DT_DEB_REAL < CURRENT TIMESTAMP) OR " +
                    "(T_INTERVENTIONS.CD_STATUT_INTERV in(1,2) AND " +
                    "T_INTERVENTIONS.DT_FIN_PREV < CURRENT TIMESTAMP)) AND " +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";


            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        Collections.sort(tmp, new Comparator<CommonJobBean>() {

            @Override
            public int compare(CommonJobBean lhs, CommonJobBean rhs) {
                return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
            }

        });

        return tmp;
    }

    /**
     * Fetches all the late jobs based on location
     *
     * @param userId the user id
     * @return the all intervention before
     */
    public synchronized Vector<CommonJobBean> getLateJobsNearBy(int userId, String gpsX, String gpsY) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (" +
                    "( (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2
                    + ") OR ("
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                    + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                    + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4" +
                    ") OR (" +
                    "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND date(DT_DEB_REAL) < CURRENT DATE" +
                    "))"
                    + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            String headerDate = "";
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean deadlineJobBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                deadlineJobBean.setDt_deb_real(cursor.getString(34));
                deadlineJobBean.setDt_fin_real(cursor.getString(35));

                tmp.add(deadlineJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        // Collections.sort(tmp, new Comparator<CommonJobBean>() {
        //
        // @Override
        // public int compare(CommonJobBean lhs, CommonJobBean rhs) {
        // return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
        // }
        //
        // });

        return tmp;
    }

    /**
     * Fetches all completed jobs.
     *
     * @return the all intervention before
     */
    public synchronized Vector<ReportsJobBean> getAllInterventionCompletedNew(String lastDate) {
//        try {
//            int cdStatus = getStatus("69063922-edc6-11e8-8000-d049fd69af7f");
//            if (cdStatus != -1) {
//                Logger.log(TAG, "cdStatus of job 69063922-edc6-11e8-8000-d049fd69af7f----->" + cdStatus);
//            } else {
//                Logger.log(TAG, "job 69063922-edc6-11e8-8000-d049fd69af7f not found----->" + cdStatus);
//            }
////            checkReportAll();
//
//        } catch (Exception e) {
//            Logger.log(TAG, "Exception while getting all reports----->" + e);
//        }
        Vector<ReportsJobBean> tmp = new Vector<ReportsJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND "
                    + "dateformat(DT_FIN_REAL,'yyyy-mm-dd') >='" + lastDate + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }
//                Logger.log(TAG,"REPORT DETAIL RESULT QUERY===>"+encodeString(cursor.getBytes(1)));

                ReportsJobBean reportsJobBean = new ReportsJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        cursor.getString(4), cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)), cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate);

                reportsJobBean.setDt_deb_real(cursor.getString(34));
                reportsJobBean.setDt_fin_real(cursor.getString(35));


                tmp.add(reportsJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    //v51.0.3 devel
    public synchronized Vector<CommonJobBean> getAllInterventionCompletedNewNew(String lastDate) {
//        try {
//            int cdStatus = getStatus("69063922-edc6-11e8-8000-d049fd69af7f");
//            if (cdStatus != -1) {
//                Logger.log(TAG, "cdStatus of job 69063922-edc6-11e8-8000-d049fd69af7f----->" + cdStatus);
//            } else {
//                Logger.log(TAG, "job 69063922-edc6-11e8-8000-d049fd69af7f not found----->" + cdStatus);
//            }
////            checkReportAll();
//
//        } catch (Exception e) {
//            Logger.log(TAG, "Exception while getting all reports----->" + e);
//        }
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND "
                    + "dateformat(DT_FIN_REAL,'yyyy-mm-dd') >='" + lastDate + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {

                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean model = new CommonJobBean();
                model.setId(encodeString(cursor.getBytes(1)));
                model.setDesc(encodeString(cursor.getBytes(2)));
                model.setPriorite(cursor.getInt(3));
                model.setDt_deb_prev(cursor.getString(4));
                model.setDt_fin_prev(cursor.getString(5));
                model.setAdr_interv_rue(encodeString(cursor.getBytes(6)));
                model.setAdr_interv_cp(encodeString(cursor.getBytes(7)));
                model.setAdr_interv_ville(encodeString(cursor.getBytes(8)));
                model.setAdr_interv_pays(encodeString(cursor.getBytes(9)));
                model.setCd_status_interv(cursor.getInt(10));
                model.setNom_client_interv(encodeString(cursor.getBytes(11)));
                model.setNom_contact(encodeString(cursor.getBytes(12)));
                model.setTel_contact(encodeString(cursor.getBytes(13)));
                model.setNom_site_interv(encodeString(cursor.getBytes(14)));
                model.setType_Interv(encodeString(cursor.getBytes(15)));
                model.setId_model_rapport(cursor.getInt(16));
                model.setIdUser(cursor.getInt(17));
                model.setLat(cursor.getString(19));
                model.setLon(cursor.getString(18));
                model.setAdr_interv_globale(cursor.getString(20));
                model.setAdr_interv_complement(cursor.getString(21));
                model.setNo_interv(cursor.getInt(22));
                model.setNom_client_sign(cursor.getString(23));
                model.setNom_tech_sign(cursor.getString(24));
                model.setNom_facture_sign(cursor.getString(25));
                model.setNom_equipement(encodeString(cursor.getBytes(26)));
                model.setIdClient(cursor.getInt(27));
                model.setIdSite(cursor.getInt(28));
                model.setIdEquipement(cursor.getInt(29));
                model.setMobileContact(encodeString(cursor.getBytes(30)));
                model.setDt_meeting(cursor.getString(31));
                model.setRef_customer(cursor.getString(32));
                model.setId_interv_mere(cursor.getString(33));
                model.setHeaderDate(headerDate);
                model.setDtCreated("");
                model.setDt_deb_real(cursor.getString(34));
                model.setDt_fin_real(cursor.getString(35));
                tmp.add(model);


//            ReportsJobBean reportsJobBean = new ReportsJobBean(
//                    encodeString(cursor.getBytes(1)),
//                    encodeString(cursor.getBytes(2)), cursor.getInt(3),
//                    cursor.getString(4), cursor.getString(5),
//                    encodeString(cursor.getBytes(6)),
//                    encodeString(cursor.getBytes(7)),
//                    encodeString(cursor.getBytes(8)),
//                    encodeString(cursor.getBytes(9)), cursor.getInt(10),
//                    encodeString(cursor.getBytes(11)),
//                    encodeString(cursor.getBytes(12)),
//                    encodeString(cursor.getBytes(13)),
//                    encodeString(cursor.getBytes(14)),
//                    encodeString(cursor.getBytes(15)),
//                    cursor.getInt(16),
//                    cursor.getInt(17),
//                    cursor.getString(19),
//                    cursor.getString(18),
//                    cursor.getString(20),
//                    cursor.getString(21),
//                    cursor.getInt(22),
//                    cursor.getString(23),
//                    cursor.getString(24),
//                    cursor.getString(25),
//                    encodeString(cursor.getBytes(26)),
//                    cursor.getInt(27),
//                    cursor.getInt(28),
//                    cursor.getInt(29),
//                    encodeString(cursor.getBytes(30)),
//                    cursor.getString(31),
//                    cursor.getString(32),
//                    cursor.getString(33),
//                    headerDate);
//
//            reportsJobBean.setDt_deb_real(cursor.getString(34));
//            reportsJobBean.setDt_fin_real(cursor.getString(35));
//            tmp.add(reportsJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    private synchronized void checkReportAll() throws Exception {
        String date = null;
        String prevDate = null;
        /*
         * new changes.
         */
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date());
        calendar.add(Calendar.DATE, -30);
        prevDate = dateFormat.format(calendar.getTime());
        Logger.log(TAG, "REPORT_TEST  prevDate----->" + prevDate);

        Calendar calendarNow = Calendar.getInstance();
        calendarNow.setTime(new Date());
        date = dateFormat.format(calendarNow.getTime());
        Logger.log(TAG, "REPORT_TEST  date----->" + date);

        int reportCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();

            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT * FROM T_INTERVENTIONS WHERE (CD_STATUT_INTERV = 5 OR CD_STATUT_INTERV = 6) AND "
                            + "((DATEFORMAT(DT_FIN_REAL,'yyyy-MM-dd') >='"
                            + prevDate
                            + "') AND (DATEFORMAT(DT_FIN_REAL,'yyyy-MM-dd') <='"
                            + date
                            + "'))");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                reportCount++;
                Logger.log(TAG, "REPORT_TEST  reportCount----->" + reportCount);
            }
        } catch (Exception e) {
            Logger.printException(e);
            reportCount = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        Logger.log(TAG, "REPORT_TEST  reportCount----->" + reportCount);
    }

    /**
     * Fetches all completed jobs.
     *
     * @return the all intervention before
     */
    public synchronized Vector<ReportsJobBean> getCompletedJobsNearBy(String lastDate, String gpsX, String gpsY) {
        Vector<ReportsJobBean> tmp = new Vector<ReportsJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND dateformat(DT_FIN_REAL,'yyyy-mm-dd') >='"
                    + lastDate + "' "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                ReportsJobBean reportsJobBean = new ReportsJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        cursor.getString(4), cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)), cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate);

                reportsJobBean.setDt_deb_real(cursor.getString(34));
                reportsJobBean.setDt_fin_real(cursor.getString(35));
                tmp.add(reportsJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    /**
     * Fetches all the completed jobs on a particular date .
     *
     * @param date the date
     * @return the all intervention before
     */
    public synchronized Vector<ReportsJobBean> getCompletedJobsByDateNearBy(String date, String gpsX, String gpsY) {
        Vector<ReportsJobBean> tmp = new Vector<ReportsJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND CD_STATUT_INTERV ='5' AND dateformat(DT_FIN_REAL,'yyyy-mm-dd')='"
                    + date + "' "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                ReportsJobBean reportsJobBean = new ReportsJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        cursor.getString(4), cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)), cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate);

                reportsJobBean.setDt_deb_real(cursor.getString(34));
                reportsJobBean.setDt_fin_real(cursor.getString(35));
                tmp.add(reportsJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    /**
     * Fetches all the completed jobs on a particular date .
     *
     * @param date the date
     * @return the all intervention before
     */
    public synchronized Vector<ReportsJobBean> getAllInterventionCompletedDate(String date) {
        Vector<ReportsJobBean> tmp = new Vector<ReportsJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND " +
                    "dateformat(DT_FIN_REAL,'yyyy-mm-dd')='"
                    + date + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                ReportsJobBean reportsJobBean = new ReportsJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        cursor.getString(4), cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)), cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate);

                reportsJobBean.setDt_deb_real(cursor.getString(34));
                reportsJobBean.setDt_fin_real(cursor.getString(35));
                tmp.add(reportsJobBean);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    /**
     * Gets the id of a customer customer.
     *
     * @return the id customer
     */
    public synchronized int getIdCustomer() {
        int id = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_CUSTOMER FROM T_CUSTOMERS");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                id = cursor.getInt(1);
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                id = -1;
            }

        } catch (Exception e) {
            Logger.printException(e);
            id = -1;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return id;
    }

    /**
     * Fetches Information od Add Icon.
     *
     * @return the adds the interv flag
     */
    public synchronized int getAddIntervFlag() {
        int id = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj()
                    .prepareStatement("SELECT FL_HORS_PROGRAMME FROM T_CUSTOMERS");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                id = cursor.getInt(1);
            }
            cursor.close();
            stmt.close();

//            connDao.commit();

        } catch (Exception e) {
            Logger.printException(e);
            id = -1;
        }
        return id;
    }

    /**
     * Gets the devise customer.
     *
     * @return the devise customer (Symbol of currency)
     * @author Previous Developer
     */
    public synchronized String getDeviseCustomer() {
        String str = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT NM_DEVISE FROM T_CUSTOMERS");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                str = encodeString(cursor.getBytes(1));
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                str = "";
            }

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (str.trim().length() > 0) {
            Logger.log(TAG, "Currency string if is :" + str);
            if (str.trim().length() == 3) {
                try {
                    Currency curr = Currency.getInstance(str);
                    return curr.getSymbol();
                } catch (Exception e) {
                    return str;
                }
            } else {
                return str;
            }
        } else {
            return str;
        }
    }

    /**
     * @return currency code
     * @author Trident
     */
    public synchronized String getDeviseCustomerCurrencyCode() {
        String str = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT NM_DEVISE FROM T_CUSTOMERS");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                str = encodeString(cursor.getBytes(1));
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
//                return str;
            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                str = "";
            }

        } catch (Exception e) {
            Logger.printException(e);
            str = "";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return str;

    }

    /**
     * Gets the modele rapport.
     *
     * @return the modele rapport
     * @author Previous Developer
     */
    public synchronized ArrayList<ModeleRapport> getModeleRapport() {
        ArrayList<ModeleRapport> al = new ArrayList<ModeleRapport>();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {

            // ResultSet cursor = connDao
            // .prepareStatement(
            // "SELECT ID_MODELE_RAPPORT,NM_MODELE_RAPPORT,FL_DEFAULT FROM TREF_MODELE_RAPPORT WHERE DT_SUPPR IS NULL order by NM_MODELE_RAPPORT")
            // .executeQuery();

            // New changes.....create prepared statement and closed it after
            // executing the query. Previously, it was written in a single
            // ResultSet statement. So, sometimes it causes the temporary tables
            // connection issue.
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT ID_MODELE_RAPPORT,NM_MODELE_RAPPORT,FL_DEFAULT FROM TREF_MODELE_RAPPORT " +
                            "WHERE DT_SUPPR IS NULL AND FL_PUBLIE = 1 order by NM_MODELE_RAPPORT");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                ModeleRapport mr = new ModeleRapport(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3));
                Logger.output(TAG, " name : " + encodeString(cursor.getBytes(2)));

                al.add(mr);
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            al = new ArrayList<ModeleRapport>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return al;
    }

    /**
     * Gets the type of intervention.
     *
     * @return the type intervention
     */
    public synchronized ArrayList<TypeIntervention> getTypeIntervention() {
        ArrayList<TypeIntervention> al = new ArrayList<TypeIntervention>();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;

        // "SELECT ID_TYPE_INTERVENTION,NM_TYPE_INTERVENTION,FL_DEFAULT,HR_DUREE_INTERVENTION FROM TREF_TYPE_INTERVENTION order by FL_DEFAULT DESC"
        // "SELECT ID_TYPE_INTERVENTION,NM_TYPE_INTERVENTION,FL_DEFAULT,HR_DUREE_INTERVENTION FROM TREF_TYPE_INTERVENTION order by NM_TYPE_INTERVENTION"

        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT ID_TYPE_INTERVENTION,NM_TYPE_INTERVENTION,FL_DEFAULT,HR_DUREE_INTERVENTION FROM TREF_TYPE_INTERVENTION WHERE DT_SUPPR IS NULL order by NM_TYPE_INTERVENTION");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                TypeIntervention ti = new TypeIntervention(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
                        cursor.getString(4));
                al.add(ti);
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            al = new ArrayList<TypeIntervention>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return al;
    }

    /**
     * creates a substring from 0th index to (N-1)th index.
     *
     * @param str the str
     * @param n   the n
     * @return the string
     * @author Previous Developer
     */
    public String cutString(String str, int n) {
        if (str != null && str.length() > n)
            return str = str.substring(0, n);
        else
            return str;
    }

    /**
     * Connect database and init connection parameters.
     *
     * @param ctx the ctx
     * @author Previous Developer
     */
    public synchronized void connectDatabase(Context ctx) {
        try {
            connDao = null;

            this.context = ctx;

            config = DatabaseManager
                    .createConfigurationFileAndroid(dbName, ctx);
            connDao = DatabaseManager.connect(config);

            String login = SharedPref.getLoginUSer(context);
            // For migrating to 55
            if ((getUserScript().equals("st_ver54")) && Dao.script.equals("st_ver55")) {
                SharedPref.setScriptUpdated(true, context);

                Logger.log(TAG, "SCRIPT UPDATION LOGIN USER GET =====>" + login);
                String userName = getUserLogin(login);
                SharedPref.setLoginUser(userName, context);
                Logger.log(TAG, "SCRIPT UPDATION LOGIN USER=====>" + userName);
                Logger.log(TAG, "SCRIPT UPDATION LOGIN USER=====> st_ver54");

                migrateV54ToV55();

                setUserScript(Dao.script);

            }else if ((getUserScript().equals("st_ver53")) && Dao.script.equals("st_ver55")) {
                SharedPref.setScriptUpdated(true, context);
                String userName = getUserLogin(login);
                SharedPref.setLoginUser(userName, context);
                Logger.log(TAG, "SCRIPT UPDATION LOGIN USER=====>" + userName);

                migrateV53ToV54();
                migrateV54ToV55();

                setUserScript(Dao.script);

            }  else if ((getUserScript().equals("st_ver52")) && Dao.script.equals("st_ver54")) {
                // For migrating from 52 to 54
                SharedPref.setScriptUpdated(true, context);
                String userName = getUserLogin(login);
                SharedPref.setLoginUser(userName, context);

                migrateV52ToV53();
                migrateV53ToV54();
                migrateV54ToV55();

                setUserScript(Dao.script);

            }

            //Check Indexes on the fly
            executeDDL("CREATE INDEX IF NOT EXISTS TREF_PIECES_NM_PIECE_INDEX ON TREF_PIECES (NM_PIECE)");
            executeDDL("CREATE INDEX TREF_CATEGORIE_PIECE_NM_CATEGORIE_PIECE_INDEX ON TREF_CATEGORIE_PIECE (NM_CATEGORIE_PIECE)");
            executeDDL("CREATE INDEX T_CLIENT_INDEX ON T_CLIENTS (NM_CLIENT)");

        } catch (Exception e) {
            if (e.getMessage() != null
                    && (e.getMessage().toString().contains("[-954]"))) { // Cas de
                // la DB
                // qui n'existe
                // pas
                // Logger.printException(e);
                try {

                    Logger.log("DB", "Start");

//                    config.setCreationString("utf8_encoding=true");
                    config.setCreationString("page_size=8k;utf8_encoding=true");

                    connDao = DatabaseManager.createDatabase(config);

                    executeDDL(t.getT_attrib_messsages_oper());
                    executeDDL(t.getT_attrib_modules());
                    executeDDL(t.getT_clients());
                    executeDDL(t.getT_customers());
                    executeDDL(t.getT_equipements_clients());
                    executeDDL(t.getT_interventions());
                    executeDDL(t.getT_messages_operateur());
                    executeDDL(t.getT_photo_pda());
                    executeDDL(t.getT_saisie_rapport());
                    executeDDL(t.getT_session());
                    executeDDL(t.getT_sites_client());
                    executeDDL(t.getT_sortie_piece());
                    executeDDL(t.getT_temps_interv());
                    executeDDL(t.getT_users());
                    // executeDDL(t.getT_val_custom_fields());
                    executeDDL(t.getTref_categorie_piece());
//					executeDDL(t.getTref_commentaires_fils());
//					executeDDL(t.getTref_commentaires_pere());
                    executeDDL(t.getTref_modele_famille());
                    executeDDL(t.getTref_modele_item());
                    executeDDL(t.getTref_modele_rapport());
                    executeDDL(t.getTref_modele_value_item());
                    executeDDL(t.getTref_modules());
                    executeDDL(t.getTref_pieces());
                    executeDDL(t.getTref_statut_intervention());
                    executeDDL(t.getTref_traduction_cust());
                    executeDDL(t.getTref_traductions());
                    executeDDL(t.getTref_type_intervention());
                    // executeDDL(t.getTref_custom_fields());
                    executeDDL(t.getTref_gestion_acces());

                    executeDDL(t.getTref_typint_rapport());
                    // executeDDL(t.getTdalkia_liste_operation());
                    // executeDDL(t.getTdalkia_bt_fis());
                    // executeDDL(t.getTdalkia_refus());
                    executeDDL(t.getTref_type_conge());
                    executeDDL(t.getT_conge());
                    executeDDL(t.getT_clients_index());
                    executeDDL(t.getT_sites_clients_index());
                    executeDDL(t.getT_equipment_client_index());
                    executeDDL(t.getT_intervention_dt_deb_previndex());
                    executeDDL(t.getT_intervention_dt_fin_realindex());
                    executeDDL(t.getT_attrib_messages_oer_dt_modif_index());
                    executeDDL(t.getT_attrib_messages_oer_fl_lu_index());
                    executeDDL(t.getT_Attachment());
                    executeDDL(t.getT_Lignes_Facture());
                    executeDDL(t.getT_Factures());
                    executeDDL(t.getT_Taxrates());
                    executeDDL(t.getT_Stocks());
                    executeDDL(t.getT_Piece_Serials());
                    executeDDL(t.getT_Piece_Demande());
                    executeDDL(t.getTref_modele_bloc());
                    executeDDL(t.getT_saisie_bloc());
                    executeDDL(t.getT_stock_pieces());
                    executeDDL(t.getT_payments());
                    executeDDL(t.getT_payments_log());
                    executeDDL(t.getC_connections());
                    executeDDL(t.getAlter_T_STOCK_PIECES());
                    executeDDLNew(t.getT_REPRISE_PIECE());
                    executeDDLNew(t.getT_JOB_WINDOWS());


                    executeAlterFK48();
//                    executeAlterFK49();
                    executeDDLNew(t.getAlter_T_PIECE_SERIALS());
                    //v51.0.02 new table

                    executeDDL(t.getT_tref_tags());
                    executeDDL(t.getT_groups_user());
                    executeDDL(t.getT_facture_tax());

                    //v53 new tables
                    executeDDLNew(t.getT_incidents());
                    executeDDLNew(t.getT_incidents_log());

                    //v52 index addition
                    executeDDL(t.getT_clients_index_search());
                    executeDDL(t.getT_sites_clients_index_search());

                    //v55 new tables
//                    executeDDLNew(t.getGps_steps());
//                    executeDDLNew(t.getGps_steps_index());

                    executeAlter53();
                    migrateV53ToV54();
                    migrateV54ToV55();
                    setFirstLine();

                    setUserScript(Dao.script);

                    Logger.log("DB", "Created");

                } catch (Exception ex) {
                    ex.printStackTrace();
                    Logger.printException(ex);

                }
            }
        }
    }

    private void migrateV54ToV55() {
        TablesUpdated55 tablesUpdated = new TablesUpdated55();
        try {

            executeDDL(tablesUpdated.getAlter_T_FACTURES());
            executeDDL(tablesUpdated.getAlter_TREF_GESTION_ACCES());
            executeDDL(tablesUpdated.getAlter_TREF_GESTION_ACCES_1());
            executeDDL(tablesUpdated.getAlter_T_USERS());
            executeDDL(tablesUpdated.getAlter_T_USERS_1());
//            executeDDL(tablesUpdated.getGps_steps());
//            executeDDL(tablesUpdated.getGps_steps_index());
            executeDDL(tablesUpdated.getAlter_T_CLIENTS());
            executeDDL(tablesUpdated.getAlter_T_SITES_CLIENTS());
            executeDDL(tablesUpdated.getAlter_T_EQUIPEMENTS_CLIENTS());

//            executeDDL(tablesUpdated.getAlter_T_FACTURES_1());
            getValueFactures();
//            updateFactures(0);

        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    private void migrateV53ToV54() {
        TablesUpdated54 tablesUpdated = new TablesUpdated54();
        try {

            executeDDL(tablesUpdated.getAlter_T_TEMPS_INTERV_1());
            executeDDL(tablesUpdated.getAlter_T_TEMPS_INTERV_2());
            executeDDL(tablesUpdated.getAlter_T_INTERVENTIONS_1());
            executeDDL(tablesUpdated.getAlter_T_SITES_CLIENTS_1());
            executeDDL(tablesUpdated.getAlter_T_CLIENTS_1());

        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    private void migrateV52ToV53() {
        TablesUpdated53 tablesUpdated = new TablesUpdated53();
        try {

            executeDDL(tablesUpdated.getAlter_T_FACTURES_1());
            executeDDL(tablesUpdated.getAlter_T_FACTURES_2());
            executeDDL(tablesUpdated.getAlter_T_FACTURES_3());

            executeDDL(tablesUpdated.getT_incidents());
            executeDDL(tablesUpdated.getT_incidents_log());


        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
        }
    }

    private void migrateV51ToV54() {
        TablesUpdated52 tablesUpdated = new TablesUpdated52();
        try {

            executeDDL(tablesUpdated.getAlter_TREF_GESTION_ACCES_1());
            executeDDL(tablesUpdated.getAlter_TREF_GESTION_ACCES_2());
            executeDDL(tablesUpdated.getAlter_TREF_GESTION_ACCES_3());
            executeDDL(tablesUpdated.getAlter_T_USERS_1());
            executeDDL(tablesUpdated.getAlter_T_USERS_2());
            executeDDL(tablesUpdated.getAlter_T_USERS_3());
            executeDDL(tablesUpdated.getAlter_TREF_PIECES_1());
            executeDDL(tablesUpdated.getAlter_TREF_PIECES_2());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_1());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_2());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_3());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_4());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_5());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_6());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_7());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_7());
            executeDDL(tablesUpdated.getAlter_T_TAXRATES_1());
            executeDDL(tablesUpdated.getAlter_TREF_TYPE_INTERVENTION_1());
            executeDDL(tablesUpdated.getAlter_T_CUSTOMERS_1());
            executeDDL(tablesUpdated.getAlter_T_FACTURES_1());
            executeDDL(tablesUpdated.getT_groups_user());
            executeDDL(tablesUpdated.getT_tref_tags());
            executeDDL(tablesUpdated.getT_facture_tax());
            executeDDL(tablesUpdated.getAlter_T_LIGNES_FACTURE_8());


        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    /**
     * Update factures table where no_int_factures is null
     */
    public synchronized void getValueFactures() {

        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT * FROM T_FACTURES WHERE NO_INT_FACTURE_DEVIS = NULL ";

            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                updateFactures(0);

                Logger.log(TAG, "MIGRATE NO_INT_FACTURE_DEVIS DAO====>" + cursor.getString(12));
            }
            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Update the status of NO_INT_FACTURE_DEVIS when the value is null.
     *
     * @param statut the statut
     *
     */
    public synchronized boolean updateFactures(int statut) {
        return executeDDL("UPDATE T_FACTURES SET NO_INT_FACTURE_DEVIS='"
                + statut + "' WHERE NO_INT_FACTURE_DEVIS=NULL");

    }

    private void executeAlterFK49() {
        TablesUpdated49 tablesUpdated = new TablesUpdated49();
        try {

            removeInterventionFK();
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_1());
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_2());
            executeDDL(tablesUpdated.getAlter_T_PIECE_SERIALS_1());
            executeDDL(tablesUpdated.getAlter_T_PIECE_SERIALS_2());
            executeDDL(tablesUpdated.getAlter_T_PIECE_SERIALS_3());
            executeDDL(tablesUpdated.getAlter_T_PIECE_SERIALS_4());
            executeDDL(tablesUpdated.getT_reprise_piece());
            executeDDL(tablesUpdated.getInsert_T_REPRISE_PIECE());
//                    executeDDL(tablesUpdated.getAlter_T_PIECE_SERIALS_5());

            /* REMOVE COLUMNS RELATED TO REMOVING PARTS FROM T_SORTIE_PIECE */
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_3());
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_4());
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_5());
            executeDDL(tablesUpdated.getAlter_T_SORTIE_PIECE_6());

        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    private void executeAlterFK48() {
        TablesUpdated48New tablesUpdated = new TablesUpdated48New();
        try {

            executeDDL(tablesUpdated.getAlter_T_ATTRIB_MESSAGES_OPER_1());
            executeDDL(tablesUpdated.getAlter_T_ATTRIB_MESSAGES_OPER_2());
            executeDDL(tablesUpdated.getAlter_T_ATTRIB_MODULES_1());
            executeDDL(tablesUpdated.getAlter_T_ATTRIB_MODULES_2());
            executeDDL(tablesUpdated.getAlter_T_CLIENTS_1());
            executeDDL(tablesUpdated.getAlter_T_EQUIPEMENTS_CLIENTS_1());
            executeDDL(tablesUpdated.alter_T_EQUIPEMENTS_CLIENTS_2());
            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_1());
            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_2());
            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_3());
            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_4());

            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_5());

//            reports intervention n completed job not showing
//            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_6());

            //auxillary jobs not showing if we include the below query
//            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_7());
            removeInterventionFK();

            //exception T_PROJECTS not found
            executeDDL(tablesUpdated.alter_T_INTERVENTIONS_8());

            executeDDL(tablesUpdated.alter_T_SAISIE_RAPPORT_1());
            executeDDL(tablesUpdated.alter_T_SITES_CLIENTS_1());
            executeDDL(tablesUpdated.alter_T_SITES_CLIENTS_2());
            executeDDL(tablesUpdated.alter_T_TEMPS_INTERV_1());
            //exception Table 'TREF_PROFILS' not found
            executeDDL(tablesUpdated.alter_T_USERS_1());
            executeDDL(tablesUpdated.alter_T_USERS_2());
            executeDDL(tablesUpdated.alter_TREF_MODELE_ITEM_1());
            executeDDL(tablesUpdated.alter_TREF_MODELE_RAPPORT_1());
            executeDDL(tablesUpdated.alter_TREF_MODELE_VALUE_ITEM_1());
            executeDDL(tablesUpdated.alter_TREF_TRADUCTIONS_CUST_1());
            executeDDL(tablesUpdated.alter_TREF_TYPE_INTERVENTION_1());
            executeDDL(tablesUpdated.alter_TREF_TYPINT_RAPPORT_1());
            executeDDL(tablesUpdated.alter_TREF_TYPINT_RAPPORT_2());
            executeDDL(tablesUpdated.alter_T_ATTACHMENTS_1());
            executeDDL(tablesUpdated.alter_T_PIECE_DEMANDE_2());
            executeDDL(tablesUpdated.alter_T_PIECE_DEMANDE_3());
            executeDDL(tablesUpdated.alter_T_PIECE_DEMANDE_4());
            executeDDL(tablesUpdated.alter_T_SAISIE_BLOC_1());
            executeDDL(tablesUpdated.alter_T_SAISIE_BLOC_2());
            executeDDL(tablesUpdated.alter_T_SAISIE_BLOC_3());
            //shared block not added
//            executeDDL(tablesUpdated.alter_T_SAISIE_BLOC_4());
            executeDDL(tablesUpdated.alter_TREF_MODELE_BLOC_1());
            executeDDL(tablesUpdated.alter_TREF_MODELE_BLOC_2());
            executeDDL(tablesUpdated.alter_TREF_MODELE_BLOC_3());
            executeDDL(tablesUpdated.alter_T_STOCK_PIECES_1());
            executeDDL(tablesUpdated.alter_T_STOCK_PIECES_2());
            executeDDL(tablesUpdated.alter_T_PAYMENTS_LOG_1());
            executeDDL(tablesUpdated.getTref_pieces_index());
            executeDDL(tablesUpdated.getTref_categorie_piece_index());
            executeDDL(tablesUpdated.alter_T_SORTIE_PIECE_1());
            executeDDL(tablesUpdated.alter_TREF_CATEGORIE_PIECE_1());
            executeDDL(tablesUpdated.alter_TREF_PIECES_1());
            executeDDL(tablesUpdated.alter_T_STOCKS_1());
            executeDDL(tablesUpdated.alter_T_PIECE_SERIALS_1());
            executeDDL(tablesUpdated.alter_T_PIECE_SERIALS_2());
            executeDDL(tablesUpdated.alter_T_PIECE_DEMANDE_1());


        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    private void executeAlter53() {
        TablesUpdated53 tablesUpdated = new TablesUpdated53();
        try {

            //v53 alter commands
            executeDDL(tablesUpdated.getAlter_T_FACTURES_1());
            executeDDL(tablesUpdated.getAlter_T_FACTURES_2());
            executeDDL(tablesUpdated.getAlter_T_FACTURES_3());

        } catch (Exception e) {
            Logger.printException(e);
        }
    }

    public synchronized void sync(String user, String pwd) throws Exception, ParseException {

        Logger.log(TAG, "DURING SYNC NORMAL ====>" + user + " ; " + pwd);
        AuthData getAuthandExpriryToken = getUserToken();
        if (getAuthandExpriryToken != null) {
            boolean isExpiry = DateFormatUtils.getFormattedDateFromAPIDateBase(getAuthandExpriryToken.getExpiry());
            if (isExpiry) {
                syncx(user, pwd, false);
            } else {
                SynchroteamUitls.ISTokonExpiryGotoLogin(context);
            }
        } else {
            SynchroteamUitls.ISTokonExpiryGotoLogin(context);
        }
    }

    //********************************************* devel Code for Sync**************************************

    public synchronized void syncx(String user, String pwd, Boolean pFirstSynch) throws Exception, ParseException {

        firstSynch = pFirstSynch;

        boolean stdSSL = SharedPref.getSyncStdSsl(context);
        boolean debugSSL = SharedPref.getSyncDebugSsl(context);

        host = SharedPref.getSyncStdServer(context);
        port = SharedPref.getSyncStdPort(context);

        debug_host = SharedPref.getSyncDebugServer(context);
        debug_port = SharedPref.getSyncDebugPort(context);

        if (host == null || debug_host == null) {
            hitSyncServerInTheCaseOfNullHost(getUserDomain());
        }

        // checking host is null or not
        if (host != null && debug_host != null) {

            boolean isDebugEnabled = SharedPref.getDebugEnabled(context);
            boolean isScriptUpdated = SharedPref.getScriptUpdated(context);

            String domain = getUserDomain();
            SyncParms _syncParms;
            //Connection connection = getConnectionObj();
            try {
                if (isDebugEnabled) {
                    if (isScriptUpdated) {
                        _syncParms = getConnectionObj().createSyncParms(domain + "_" + user + "/#/"
                                + script + PREVIOUS_VERSION, script);
                    } else {
                        _syncParms = getConnectionObj().createSyncParms(domain + "_" + user + "/#/"
                                + script, script);
                    }
                    _syncParms.setPassword(pwd);

                    if (DialogUtils.showProgress) {
                        _syncParms.setSyncObserver(new MyObserver());
                    }

                    _syncParms.setAcknowledgeDownload(true);

                    if (debugSSL) {

                        StreamHTTPSParms _streamParms = (StreamHTTPSParms) _syncParms
                                .getStreamParms();

                        //For Ultralite17, we need to set the certificate name, company and unit.
                        _streamParms.setCertificateName(context.getString(R.string.certificate_name));
                        _streamParms.setCertificateCompany(context.getString(R.string.certificate_company));
                        _streamParms.setCertificateUnit(context.getString(R.string.certificate_unit));
                        _streamParms.setTrustedCertificates(context.getString(R.string.textPemCertificatePath));

                        _streamParms.setPort(debug_port);
                        _streamParms.setHost(debug_host);

                    } else {
                        StreamHTTPParms _streamParms = (StreamHTTPParms) _syncParms.getStreamParms();
                        _streamParms.setPort(debug_port);
                        _streamParms.setHost(debug_host);
                    }

                } else {
                    if (stdSSL) {
                        if (isScriptUpdated) {
                            _syncParms = getConnectionObj().createSyncParms(SyncParms.HTTPS_STREAM,
                                    domain + "_" + user + "/#/" + script + PREVIOUS_VERSION, script);
                        } else {
                            _syncParms = getConnectionObj().createSyncParms(SyncParms.HTTPS_STREAM,
                                    domain + "_" + user + "/#/" + script, script);
                        }
                    } else {
                        if (isScriptUpdated) {
                            _syncParms = getConnectionObj().createSyncParms(domain + "_" + user + "/#/"
                                    + script + PREVIOUS_VERSION, script);
                        } else {
                            _syncParms = getConnectionObj().createSyncParms(domain + "_" + user + "/#/"
                                    + script, script);
                        }
                    }


                    _syncParms.setPassword(pwd);
                    if (DialogUtils.showProgress) {
                        _syncParms.setSyncObserver(new MyObserver());
                    }

                    _syncParms.setAcknowledgeDownload(true);

                    if (stdSSL) {
                        StreamHTTPSParms _streamParms = (StreamHTTPSParms) _syncParms.getStreamParms();

                        //For Ultralite17, we need to set the certificate name, company and unit.
                        _streamParms.setCertificateName(context.getString(R.string.certificate_name));
                        _streamParms.setCertificateCompany(context.getString(R.string.certificate_company));
                        _streamParms.setCertificateUnit(context.getString(R.string.certificate_unit));
                        _streamParms.setTrustedCertificates(context.getString(R.string.textPemCertificatePath));
                        _streamParms.setPort(port);
                        _streamParms.setHost(host);

                    } else {
                        StreamHTTPParms _streamParms = (StreamHTTPParms) _syncParms.getStreamParms();
                        _streamParms.setPort(port);
                        _streamParms.setHost(host);
                    }

                }

                /** set table orders to avoid sync issues */
                _syncParms.setTableOrder(tableOrder.getOrderedTables());

                getConnectionObj().synchronize(_syncParms);
                setLastSynch();
                //connection.release();
                if (isScriptUpdated) {
                    SharedPref.setScriptUpdated(false, context);
                }
            } catch (Exception e) {
                Logger.log(TAG, "EXCEPTION SYNC NORMAL ====>");

                Logger.printException(e);
                throw e;
            }

            if (isDebugEnabled) {
                SharedPref.setDebugEnableSync(false, context);
            }

        } else {
//            Toast.makeText(context, context.getString(R.string.msg_synch_error), Toast.LENGTH_SHORT).show();
            showSyncFailureMsgDialog(context.getString(R.string.msg_synch_error_new));
        }


    }

    /**
     * For showing the synchronization failure messages
     */
    protected void showSyncFailureMsgDialog(String syncFailureMsg) {

        if (context != null) {
            SynchronizationErrorDialog synchronizationErrorDialog = new SynchronizationErrorDialog
                    ((Activity) context, syncFailureMsg, new SynchronizationErrorDialog
                            .SynchronizationErrorInterface() {
                        @Override
                        public void doOnOkayClick() {
                            //perform any action
                        }
                    });

            synchronizationErrorDialog.show();
        }
    }

    /***
     * Gets the data of User which is undergoing the current session with App
     *
     * @return User
     */

//    public synchronized User getUserexpriry() {
//        PreparedStatement stmt = null;
//        ResultSet cursor = null;
//        User user = null;
//        try {
//
//            if (connDao == null) {
//                connDao = DatabaseManager.connect(config);
//            }
////            Connection connNew = getConnectionObj();
//            stmt = getConnectionObj()
//                    .prepareStatement("SELECT LOGIN_USER,PWD_USER,NOM_USER,PRENOM_USER,ID_STOCK,ID_USER FROM T_USERS");
//            cursor = stmt.executeQuery();
//            cursor.next();
//
//            user = new User(encodeString(cursor.getBytes(1)),
//                    encodeString(cursor.getBytes(2)),
//                    encodeString(cursor.getBytes(3)),
//                    encodeString(cursor.getBytes(4)), cursor.getString(5),
//                    cursor.getInt(6));
////            cursor.close();
////            stmt.close();
////            connDao.commit();
////            connNew.release();
//        } catch (Exception exc) {
//            user = null;
//
//        } finally {
//            if (cursor != null) {
//                try {
//                    cursor.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            if (stmt != null) {
//                try {
//                    stmt.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            try {
//                connDao.commit();
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
//        return user;
//    }
    public synchronized User getUser() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        User user = null;
        String login = SharedPref.getLoginUSer(context);
        Logger.log(TAG, "SCRIPT UPDATION LOGIN USER GET =====>" + login);
        try {
            String query="SELECT LOGIN_USER," +
                    "AUTH_TOKEN," +
                    "NOM_USER," +
                    "PRENOM_USER," +
                    "ID_STOCK," +
                    "ID_USER," +
                    "ID_PROFIL," +
                    "FL_SUBCONTRACTOR FROM T_USERS " +
                    "WHERE LOGIN_USER='" + login + "'";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            cursor.next();

            user = new User(encodeString(cursor.getBytes(1)),
                    cursor.getString(2),
                    encodeString(cursor.getBytes(3)),
                    encodeString(cursor.getBytes(4)), cursor.getString(5),
                    cursor.getInt(6),cursor.getInt(7),cursor.getInt(8));
            cursor.close();
            stmt.close();
//            connDao.commit();
//            connNew.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            user = null;

        }
        return user;
    }

    public synchronized int getUserID() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int user = 0;
        String login = SharedPref.getLoginUSer(context);

        try {

//            if (connDao == null) {
//                connDao = DatabaseManager.connect(config);
//            }

//            Connection connNew = getConnectionObj();
//            stmt = getConnectionObj()
//                    .prepareStatement("SELECT LOGIN_USER,sync,NOM_USER,PRENOM_USER,ID_STOCK,ID_USER FROM T_USERS");

            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_USER FROM T_USERS " +
                            "WHERE LOGIN_USER='" + login + "'");


            cursor = stmt.executeQuery();
            cursor.next();

            user = cursor.getInt(1);

//            cursor.close();
//            stmt.close();
//            connDao.commit();
//            connNew.release();
        } catch (Exception exc) {
            Logger.log(TAG, "USER EXCEPTION DURING LOGIN ===>" + exc);
            user = 0;

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return user;
    }

    public synchronized AuthData getUserToken() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        AuthData user = null;
        int idUser = getUserID();
        try {

            if (connDao == null) {
                connDao = DatabaseManager.connect(config);
            }

            String query="SELECT AUTH_TOKEN,AUTH_EXPIRY FROM T_USERS WHERE ID_USER = " + idUser;
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            cursor.next();
            user = new AuthData();
            user.setAuth(cursor.getString(1));
            user.setExpiry(cursor.getString(2));
            if (cursor.getString(1) == null || cursor.getString(2) == null) {
                user = null;
            }

            cursor.close();
            stmt.close();
//            connDao.commit();
//            connNew.release();
        } catch (Exception exc) {
            user = null;

        }
        return user;
    }

    /**
     * Sets the last synch time in Database and in locale Shared prefrence.
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized void setLastSynch() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        executeDDL("UPDATE t_session_nosync SET LAST_SYNCH=DATETIME('" + s
                + "') where id='UNIQUELINE'");

        SharedPref.settimeSyncronised(System.currentTimeMillis(), context);

    }

    /**
     * 78 t tm
     * Fetch the last sync time from DB.
     *
     * @return the last synch
     */
    public synchronized String getLastSynch() {
        try {
            PreparedStatement stmt = connDao
                    .prepareStatement("SELECT LAST_SYNCH FROM t_session_nosync");
            ResultSet cursor = stmt.executeQuery();

            if (cursor.next()) {
                String str = cursor.getString(1);
                cursor.close();
                stmt.close();
                connDao.commit();
                if (str != null)
                    return str;
                else {
                    return "";
                }
            } else {
                cursor.close();
                stmt.close();
                connDao.commit();
                return "";
            }

        } catch (Exception e) {
            Logger.printException(e);
            return "";
        }

    }

    /**
     * Gets the user domain.
     *
     * @return the user domain
     */
    public synchronized String getUserDomain() {
        String dmn = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT DOMAIN FROM t_session_nosync");
            cursor = stmt.executeQuery();
            // Logger.log(TAG, "cursor : " + cursor.getString(1));
            if (cursor.next()) {
                dmn = cursor.getString(1);
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                dmn = "";
            }

        } catch (Exception e) {
            Logger.printException(e);
            e.printStackTrace();
            dmn = "";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (dmn != null)
            return dmn;
        else
            return "";
    }

    /**
     * Sets the user domain.
     *
     * @param domain the new user domain
     */
    public synchronized void setUserDomain(String domain) {
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE t_session_nosync set DOMAIN= ? ");
            ps.set(1, toBinary(domain));
            ps.execute();

//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
            e.printStackTrace();
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Gets the user script.
     *
     * @return the user script
     */
    public synchronized String getUserScript() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String script = "";
        try {
            if (connDao == null) {
                return "";
            }
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT SCRIPT FROM t_session_nosync");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                script = cursor.getString(1);

//                 cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                script = "";
            }

        } catch (ULjException e) {
            Logger.printException(e);

        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (script != null)
            return script;
        else
            return "";
    }

    /**
     * Sets the user script.
     *
     * @param script the new user script
     */
    public synchronized void setUserScript(String script) {
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE t_session_nosync set SCRIPT= ? ");
            ps.set(1, toBinary(script));
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Gets the user current version.
     *
     * @return the user script
     */
    public synchronized String getUserVersion() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String script = "";

        int idUser = getUserID();
        try {
            if (connDao == null) {
                return "";
            }
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT APP_VERSION FROM T_USERS WHERE ID_USER = " + idUser);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                script = cursor.getString(1);

                Logger.log(TAG, "APP_VERSION=====>" + script);

            } else {
                script = "";
            }

        } catch (ULjException e) {
            Logger.printException(e);

        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (script != null)
            return script;
        else
            return "";
    }

    /**
     * This function returns the last sync date from DB.
     *
     * @return the string
     * @author Previous Developer
     */
    public synchronized String checkSynch() {

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String date = "";
        try {

            //if conection object is null initialize again
            if (connDao == null) {
                connDao = DatabaseManager.connect(config);
            }
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT LAST_SYNCH FROM t_session_nosync");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                date = cursor.getString(1);

//                cursor.close();
//                stmt.close();
//                connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                date = "";
            }
        } catch (Exception e) {
            Logger.printException(e);

            date = "";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (date != null)
            return date;
        else
            return "";
    }

    /**
     * insert the first line in t_session_nosync Table.
     *
     * @author Previous Developer
     */
    public synchronized void setFirstLine() {
        executeDDL("INSERT INTO t_session_nosync(ID,STRT,HOST,PORT,SCRIPT,DRPSYNCH,LNG,LAST_SYNCH) VALUES ('UNIQUELINE','"
                + "" + "','" + "" + "','" + "" + "','" + "" + "',0,'FR',NULL)");
    }

    public synchronized int getNbreInterv() {
        String sql_string = "SELECT count(*) FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV < 5 AND DT_SUPPR is NULL";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int res = 0;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            cursor.next();
            res = cursor.getInt(1);
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            return res;
        } catch (Exception e) {
            res = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return res;
    }

    /**
     * Gets the nbre msg.
     *
     * @return the nbre msg
     * @author Previous Developer
     */
    public synchronized int getNbreMsg() {
        String sql_string = "SELECT count(*) FROM T_MESSAGES_OPERATEUR," +
                "T_ATTRIB_MESSAGES_OPER WHERE " +
                "T_MESSAGES_OPERATEUR.ID_MESSAGE=T_ATTRIB_MESSAGES_OPER.ID_MESSAGE" +
                " AND T_ATTRIB_MESSAGES_OPER.DT_SUPPR is NULL " +
                "AND T_ATTRIB_MESSAGES_OPER.FL_LU = 0";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int res = 0;
        try {
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            cursor.first();
            res = cursor.getInt(1);

            cursor.close();
            stmt.close();

//            connDao.commit();

        } catch (Exception e) {
            res = 0;
        }
        return res;
    }

    /**
     * Return Previous login date.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized boolean checkDateLogin() {

        int idUser = getUserID();

        String sql_string = "SELECT * FROM T_USERS WHERE DT_VERIF_PWD=CURRENT DATE AND ID_USER = " + idUser;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        boolean result = false;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                result = true;
            } else {
//                cursor.close();
//                stmt.close();
//                connection.commit();
//                connDao.commit();
                //connection.release();
                result = false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Check auth token login value
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized boolean checkAuthTokenLogin() {

        boolean result = false;
        AuthData getAuthandExpriryToken = getUserToken();
        if (getAuthandExpriryToken != null) {

            Logger.log(TAG, "AUTHEN TOKEN VALUE EXPIRY TIME ====>" + getAuthandExpriryToken.getExpiry());
            boolean isExpired = DateFormatUtils.getFormattedDateFromAPIDateBase(getAuthandExpriryToken.getExpiry());
            if (isExpired) {
                result = false;
            } else {
                result = true;
            }
        } else {
            result = true;
        }
        Logger.log(TAG, "AUTHEN TOKEN VALUE RESULT ====>" + result);
        return result;
    }

    /**
     * Update the status of Job to Scheduled,Started,Suspended or completed.
     *
     * @param statut   the statut
     * @param idInterv the idinterv
     */
    public synchronized boolean updateStatutInterv(int statut, String idInterv) {
        return executeDDL("UPDATE T_INTERVENTIONS SET CD_STATUT_INTERV='"
                + statut + "' WHERE ID_INTERVENTION='" + idInterv + "'");
    }

    public synchronized boolean updateTechName(int techName, String idInterv) {
        return executeDDL("UPDATE T_TEMPS_INTERV SET ID_USER='"
                + techName + "' WHERE ID_TEMPS_INTERV='" + idInterv + "'");
    }

    public synchronized void setAuthToken1(String userName, String token, String time, int userId) {
        executeDDL("UPDATE T_USERS SET AUTH_TOKEN= '" + token + "' , AUTH_EXPIRY= '" + time +
                "' WHERE LOGIN_USER='" + userName + "' AND ID_USER=  " + userId);
    }

    public synchronized void setAuthToken(String userName, String password, String token, String time) {
        PreparedStatement ps = null;
        int idUser = getUserID();
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_USERS SET AUTH_TOKEN= 's', AUTH_EXPIRY= CURRENT DATE WHERE LOGIN_USER= ? AND ID_USER= ?");


//            ps.set(1, token);
//            ps.set(2, time);
            ps.set(1, toBinary(userName));
            ps.set(2, idUser);


            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public synchronized void setDateLogin(String userName, String password, int userID) {


        executeDDL("UPDATE T_USERS SET DT_VERIF_PWD=CURRENT DATE" +
                " WHERE LOGIN_USER='" + userName + "' " +
                "and AUTH_TOKEN ='" + password + "'" +
                "and ID_USER ='" + userID + "'");
//        PreparedStatement ps = null;
//        try {
//            //Connection connection = getConnectionObj();
//            ps = getConnectionObj()
//                    .prepareStatement("UPDATE T_USERS SET DT_VERIF_PWD=CURRENT DATE WHERE LOGIN_USER= ? AND AUTH_TOKEN = ? ");
//
//            ps.set(1, toBinary(userName));
//             ps.set(2, password);
//
//            ps.execute();
////            ps.close();
//            //connection.commit();
////            connDao.commit();
//            //connection.release();
//        } catch (Exception e) {
//            Logger.printException(e);
//        } finally {
//            if (ps != null) {
//                try {
//                    ps.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            try {
//                connDao.commit();
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
    }

    /**
     * Reset the login time.
     */
    public synchronized void resetDateLogin() {
        int idUser = getUserID();
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("UPDATE T_USERS SET DT_VERIF_PWD=NULL WHERE  ID_USER = " + idUser);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Sets the start time of a job in T_TEMPS_INTERV and if is job scheduled
     * than T_INTERVENTIONS is also updated.
     *
     * @param idInterv the id interv
     * @param idUser   the id user
     * @param status   the status
     * @return the long
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized long setTimeStartInterv(String idInterv,
                                                int idUser, int status, String tempId) {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        long timeInMillSec = System.currentTimeMillis();
        String s = sdf.format(timeInMillSec);

        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
        String s1 = sdf1.format(System.currentTimeMillis());

        if ((status == KEYS.CurrentJobs.JOB_NOT_STARTED1)
                || (status == KEYS.CurrentJobs.JOB_NOT_STARTED2)) {
            executeDDL("UPDATE T_INTERVENTIONS SET CD_STATUT_INTERV = 3, DT_DEB_REAL = CURRENT TIMESTAMP WHERE ID_INTERVENTION ='"
                    + idInterv + "'");
        }

        /*
         * check if a line with idInterv is already inserted. if true means do
         * nothing, else insert a new line.
         */
        // String debutTime = getDebutTime(idInterv);
        // debutTime = debutTime.substring(0, debutTime.indexOf("."));
        //
        // if (!debutTime.equalsIgnoreCase(s)) {

//        String newdDtFinPrev=getNewUpdatedDtFinPrevForStartJobResumeJob(idInterv);

        String updatedDtFinPrev = getUpdatedDtFinPrevForStartJobResumeJob(idInterv);

        boolean valueAlreadyPresent = getValueForTempInterv(idInterv, idUser);

        if (!valueAlreadyPresent) {
//            executeDDL("INSERT INTO T_TEMPS_INTERV(ID_TEMPS_INTERV,ID_INTERVENTION," +
//                    "ID_USER,DT_DEPART," +
//                    "DT_DEBUT,DT_FIN," +
//                    "DT_RETOUR,DT_MODIF," +
//                    "DT_SUPPR,FL_SCHEDULED,FL_AUXILIARY,DT_FIN_PREV,FL_SCHEDULED,FL_AUXILIARY)" +
//                    " VALUES('" + tempId
//                    + "','" + idInterv + "','" + idUser + "',DATETIME('" + s
//                    + "'),DATETIME('" + s
//                    + "'),NULL,NULL,CURRENT TIMESTAMP,NULL,0,0,'" + updatedDtFinPrev + "',1,0)");
//
            executeDDL("INSERT INTO T_TEMPS_INTERV VALUES('" + tempId
                    + "','" + idInterv + "','" + idUser + "',DATETIME('" + s
                    + "'),DATETIME('" + s
                    + "'),NULL,NULL,CURRENT TIMESTAMP,NULL,'" + updatedDtFinPrev + "',0,0)");
//            updateTechName(idUser, tempId);
        }


//        String test="INSERT INTO T_TEMPS_INTERV (ID_INTERVENTION,ID_USER, " +
//                "ID_TEMPS_INTERV,DT_DEPART,DT_DEBUT,DT_FIN_PREV) VALUES " +
//                "(?,?,?,CURRENT TIMESTAMP,CURRENT TIMESTAMP,NULL)";

        return timeInMillSec;
    }

    /**
     * Sets the start time of a job in T_TEMPS_INTERV and if is job scheduled
     * than T_INTERVENTIONS is also updated.
     *
     * @param idInterv the id interv
     * @param idUser   the id user
     * @param status   the status
     * @return the long
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized long setTimeStartIntervResume(String idInterv, int idUser, int status) {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        long timeInMillSec = System.currentTimeMillis();
        String s = sdf.format(timeInMillSec);

        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
        String s1 = sdf1.format(System.currentTimeMillis());

        if ((status == KEYS.CurrentJobs.JOB_NOT_STARTED1)
                || (status == KEYS.CurrentJobs.JOB_NOT_STARTED2)) {
//            executeDDL("UPDATE T_INTERVENTIONS SET CD_STATUT_INTERV = 3, DT_DEB_REAL = CURRENT TIMESTAMP WHERE ID_INTERVENTION ='"
//                    + idInterv + "'");

            //not updating the DT_DEB_REAL while resuming the intervention
            executeDDL("UPDATE T_INTERVENTIONS SET CD_STATUT_INTERV = 3  WHERE ID_INTERVENTION ='"
                    + idInterv + "'");
        }

        //compare


        String dtFinPrev;

        // Update DT_FIN_PREV when Resume the job for new line (for resume state. i.e, restart)
//        if (checkConditionsForRestartJob(idInterv)) {
//            // as by requirement, if true comes, this table should be updated
//            dtFinPrev = getDtDebutAddWithOneHourForRestartJob(idInterv);
//        } else {
//            dtFinPrev = getUpdatedDtFinPrevForStartJobResumeJob(idInterv);
//        }

        //TODO updated logic for the resume DT_FIN_PREV
        String currentDt_Debut = sdf.format(timeInMillSec);

        if (checkConditionForRestartJobUpdated(idInterv)) {
            dtFinPrev = DateFormatUtils.addHourToDateTime(currentDt_Debut, 1);
        } else {
            dtFinPrev = getTempDtFinPrevForJob(idInterv);
        }


        boolean valueAlreadyPresent = getValueForTempInterv(idInterv, idUser);

        if (!valueAlreadyPresent) {
//            executeDDL("INSERT INTO T_TEMPS_INTERV(ID_TEMPS_INTERV,ID_INTERVENTION," +
//                    "ID_USER,DT_DEPART," +
//                    "DT_DEBUT,DT_FIN," +
//                    "DT_RETOUR,DT_MODIF," +
//                    "DT_SUPPR,FL_SCHEDULED,FL_AUXILIARY,DT_FIN_PREV) " +
//                    "VALUES('" + getUniqueId()
//                    + "','" + idInterv + "','" + idUser + "',DATETIME('" + s
//                    + "'),DATETIME('" + s
//                    + "'),NULL,NULL,CURRENT TIMESTAMP,NULL,0,0,'" + dtFinPrev + "')");

            executeDDL("INSERT INTO T_TEMPS_INTERV VALUES('" + getUniqueId()
                    + "','" + idInterv + "','" + idUser + "',DATETIME('" + s
                    + "'),DATETIME('" + s
                    + "'),NULL,NULL,CURRENT TIMESTAMP,NULL,'" + dtFinPrev + "',0,0)");
        }


        return timeInMillSec;
    }

    public synchronized String getUniqueId() {
        String uniqueId = "";
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("Select NEWID() AS UNIQUE_ID");
            ResultSet resultSet = ps.executeQuery();

            while (resultSet.next()) {
                uniqueId = resultSet.getString("UNIQUE_ID");

                Logger.log("New Id>>>>", uniqueId);

            }
            resultSet.close();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return uniqueId;

    }

    /**
     * Sets the Suspended time of a job in T_TEMPS_INTERV Table.
     *
     * @param s the new time clot interv
     */
    public synchronized void setTimeClotInterv(String s) {
        executeDDL("UPDATE T_TEMPS_INTERV SET DT_FIN=DATETIME('"
                + s
                + "'),DT_RETOUR=DATETIME('"
                + s
                + "') WHERE DT_DEBUT=( SELECT MAX(DT_DEBUT) FROM T_TEMPS_INTERV )");
    }

    /**
     * Sets the time clot intervention.
     *
     * @param idInterv the new time clot intervention
     * @param userId   the user id
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized void setTimeClotInterventionForJobFinish(String idInterv, String userId) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        String s = sdf.format(System.currentTimeMillis());


        Logger.log(TAG, "CHECKFINAL TIME ENDTIME VALUE====>" + s);

        if (userId.trim().length() == 0) {
            int u = getUser().getId();
            userId = String.valueOf(u);

        }

        String startTime = getStartTimeInJobDetails(idInterv);
        Logger.log(TAG, "JOB CHECK TIME START STARTTIME  DIFF====>" + startTime);
        Logger.log(TAG, "JOB CHECK TIME START ENDTIME  DIFF====>" + s);
        if (startTime != null) {
            long checkTime = getJobSuspendTime(s, startTime);

            if (checkTime <= 0) {
                try {
                    Date finalDate = sdf.parse(startTime);
                    Calendar cal = Calendar.getInstance();
                    cal.setTime(finalDate);
                    cal.add(Calendar.MINUTE, 1);
                    s = sdf.format(cal.getTime());
                } catch (ParseException e) {
                    s = sdf.format(System.currentTimeMillis());
                    e.printStackTrace();
                }
            }
        }

        Logger.log(TAG, "JOB CHECK TIME START ENDTIME_UPDATED  DIFF====>" + s);

        executeDDL("UPDATE T_TEMPS_INTERV SET DT_FIN=DATETIME('" + s
                + "'), DT_RETOUR=DATETIME('" + s + "'), DT_FIN_PREV=DATETIME('" + s + "') WHERE ID_INTERVENTION ='"
                + idInterv + "' AND ID_USER='" + userId
                + "' AND DT_FIN IS NULL AND DT_RETOUR IS NULL");

    }

    /**
     * Sets the time clot intervention.
     *
     * @param idInterv the new time clot intervention
     * @param userId   the user id
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized void setTimeClotIntervention(String idInterv, String userId, String jobPauseDateTime) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        String s = sdf.format(System.currentTimeMillis());


        String startTime = getTimeDebut(idInterv);
        Logger.log(TAG, "JOB CHECK TIME START STARTTIME  DIFF====>" + startTime);
        Logger.log(TAG, "JOB CHECK TIME START DT_FIN  DIFF====>" + s);
        if (startTime != null) {
            long checkTime = getJobSuspendTime(s, startTime);

            if (checkTime <= 0) {
                try {
                    Date finalDate = sdf.parse(startTime);
                    Calendar cal = Calendar.getInstance();
                    cal.setTime(finalDate);
                    cal.add(Calendar.MINUTE, 1);
                    s = sdf.format(cal.getTime());
                } catch (ParseException e) {
                    s = sdf.format(System.currentTimeMillis());
                    e.printStackTrace();
                }
            }
        }

        Logger.log(TAG, "JOB CHECK TIME START DT_FIN_Updated  DIFF====>" + s);
        // for updating the clock out time
        if (jobPauseDateTime != null && jobPauseDateTime.length() > 0) {
            try {
                if (startTime != null) {
                    long checkTime = getJobSuspendTime(jobPauseDateTime, startTime);

                    if (checkTime <= 0) {
                        try {
                            Date finalDate = sdf.parse(startTime);
                            Calendar cal = Calendar.getInstance();
                            cal.setTime(finalDate);
                            cal.add(Calendar.MINUTE, 2);
                            jobPauseDateTime = sdf.format(cal.getTime());
                        } catch (ParseException e) {
                            e.printStackTrace();
                        }
                    }
                }

                Date date = sdf.parse(jobPauseDateTime);
                long updatedPauseDate = date.getTime() - 1000;
                Date updatedSuspendDate = new Date(updatedPauseDate);
                String clockOutDate = sdf.format(updatedSuspendDate);
                s = clockOutDate;
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }

        if (userId.trim().length() == 0) {
            int u = getUser().getId();
            userId = String.valueOf(u);
        }
        executeDDL("UPDATE T_TEMPS_INTERV SET DT_FIN=DATETIME('" + s
                + "'), DT_RETOUR=DATETIME('" + s + "') WHERE ID_INTERVENTION ='"
                + idInterv + "' AND ID_USER='" + userId
                + "' AND DT_FIN IS NULL AND DT_RETOUR IS NULL");

    }

    public synchronized String getTimeDebut(String jobId) {
        String jobSuspendedTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_DEBUT  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
                    + jobId + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    if (!TextUtils.isEmpty(resultSet.getString(1))) {
                        jobSuspendedTime = resultSet.getString(1);
                        Logger.log(TAG, "JOB CHECK TIME START ====>" + resultSet.getString(1));

                    }

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return jobSuspendedTime;

    }

    /**
     * Sets the real start date when a job is started first time in
     * T_intervention Table.
     *
     * @param idInterv the new real start date
     */
    public synchronized void setRealStartDate(String idInterv) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        executeDDL("UPDATE T_INTERVENTIONS SET DT_DEB_REAL=DATETIME('" + s
                + "') WHERE ID_INTERVENTION='" + idInterv + "'");
    }

    /**
     * Sets the real end date When a job is stopped.
     *
     * @param idInterv the new real end date
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized void setRealEndDate(String idInterv) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        String startTime = getStartTimeInJobDetails(idInterv);

        if (startTime != null) {
            long checkTime = getJobSuspendTime(s, startTime);

            if (checkTime <= 0) {
                try {
                    Date finalDate = sdf.parse(startTime);
                    Calendar cal = Calendar.getInstance();
                    cal.setTime(finalDate);
                    cal.add(Calendar.MINUTE, 1);
                    s = sdf.format(cal.getTime());
                } catch (ParseException e) {
                    s = sdf.format(System.currentTimeMillis());
                    e.printStackTrace();
                }
            }
        }
        executeDDL("UPDATE T_INTERVENTIONS SET DT_FIN_REAL=DATETIME('" + s
                + "') WHERE ID_INTERVENTION='" + idInterv + "'");
    }

    public synchronized String getStartTimeInJobDetails(String idIntervention) {
        String jobTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_DEB_REAL FROM T_INTERVENTIONS WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                try {

                    jobTime = resultSet.getString(1);

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobTime;
    }

    /**
     * * to check if user started has job or not.
     *
     * @param idUser the id user
     * @return the int
     */
    public synchronized int checkIntervStatus(int idUser) {
        String sql_string = "SELECT COUNT(*) FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV = 3 AND DT_SUPPR IS NULL AND ID_USER = "
                + idUser;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                if (cursor.getInt(1) != 0) {
                    cursor.close();
                    stmt.close();
                    //connection.commit();
                    connDao.commit();
                    //connection.release();
                    return 1;
                }
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * Check interv status .
     *
     * @param idInterv the id interv
     * @param idUser   the id user
     * @return the int
     */
    public synchronized int checkIntervStatus(String idInterv, int idUser) {
        String sql_string = "SELECT COUNT(*) FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV = 3 AND ID_INTERVENTION <> '"
                + idInterv + "' AND DT_SUPPR IS NULL AND ID_USER = " + idUser;
        PreparedStatement stmt;
        ResultSet cursor;
        try {
            stmt = connDao.prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                if (cursor.getInt(1) != 0) {
                    cursor.close();
                    stmt.close();
                    connDao.commit();
                    return 1;
                }
            }
            cursor.close();
            stmt.close();
            connDao.commit();
            return 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * overloaded method Gets the all famille .
     *
     * @param idModel the id model
     * @return the all famille
     */
    public synchronized Vector<Famille> getAllFamille(int idModel) {
        Vector<Famille> tmp = new Vector<Famille>();
        String query;

        try {
            query = "SELECT ID_MODELE_FAMILLE,NM_MODELE_FAMILLE FROM TREF_MODELE_FAMILLE WHERE ID_MODELE_RAPPORT="
                    + idModel
                    + " ORDER BY TRIE_CONDITION_FAMILLE,ID_MODELE_FAMILLE";
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                Logger.output("TREF_MODELE_FAMILLE", "id " + cursor.getInt(1) + " name " + encodeString(cursor.getBytes(2)));
                Famille fm = new Famille(cursor.getInt(1));

                tmp.add(fm);
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        }
        return tmp;
    }

    public synchronized byte[] getPhotoImage(String comment, String idInter, int iteration) {

        String query = "SELECT PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION = '"
                + idInter
                + "'"
                + " AND  COMMENTAIRE_PHOTO_PDA = '"
                + comment
                + "'"
                + " AND ITERATION =" + iteration;
        byte[] image = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                image = cursor.getBytes(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return image;

    }

    public synchronized void deletePhotoImage(String comment, String idInter, int iteration) {

        executeDDL("DELETE FROM T_PHOTOS_PDA WHERE ID_INTERVENTION = '"
                + idInter + "'" + " AND  COMMENTAIRE_PHOTO_PDA = '" + comment
                + "'" + " AND ITERATION = " + iteration);

    }

    /**
     * Update value.
     *
     * @param val      the val
     * @param com      the com
     * @param idItem   the id item
     * @param idInterv the id interv
     * @param conf     the conf
     */
    public synchronized void updateValue(String val, String com, int idItem,
                                         String idInterv, int conf) {

        String sql = "SELECT COUNT(*) FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM ="
                + idItem + " AND ID_INTERVENTION = '" + idInterv + "'";
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            cursor = getConnectionObj().prepareStatement(sql).executeQuery();
            cursor.next();
            int res = cursor.getInt(1);

            if (res != 0) {

                if (conf == 1 && Integer.parseInt(val) == 0)
                    executeDDL("DELETE FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM="
                            + idItem
                            + " AND ID_INTERVENTION='"
                            + idInterv
                            + "'");
                else {
                    PreparedStatement ps = null;
                    try {
                        ps = getConnectionObj()
                                .prepareStatement("UPDATE T_SAISIE_RAPPORT SET VALEUR_ITEM = ?,COMMENTAIRE_ITEM = ? ,DT_SUPPR=NULL WHERE ID_MODELE_ITEM = ? AND ID_INTERVENTION = ? ");

                        ps.set(1, toBinary(cutString(val, 512)));
                        ps.set(2, toBinary(cutString(com, 3072)));
                        ps.set(3, idItem);
                        ps.set(4, toBinary(idInterv));

                        ps.execute();
//                        ps.close();
                        //connection.commit();
//                        connDao.commit();
                    } catch (Exception e) {
                        Logger.printException(e);
                    } finally {

                        if (ps != null) {
                            try {
                                ps.close();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        try {
                            connDao.commit();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }

            } else {
                if (conf != 1 || Integer.parseInt(val) != 0) {
                    PreparedStatement ps = null;
                    try {
                        ps = getConnectionObj()
                                .prepareStatement("INSERT INTO T_SAISIE_RAPPORT VALUES(?,?,?,?,CURRENT TIMESTAMP,NULL)");

                        ps.set(1, toBinary(idInterv));
                        ps.set(2, idItem);
                        ps.set(3, toBinary(cutString(val, 512)));
                        ps.set(4, toBinary(cutString(com, 3072)));

                        ps.execute();
//                        ps.close();
                        //connection.commit();
//                        connDao.commit();
                    } catch (Exception e) {
                        Logger.printException(e);
                    } finally {

                        if (ps != null) {
                            try {
                                ps.close();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        try {
                            connDao.commit();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
//            cursor.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Execute ddl.
     *
     * @param sql the sql
     */
    public synchronized boolean executeDDL(String sql) {

        Logger.log("TAG", "executing sql statements---->" + sql);

        boolean flag = false;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement(sql);
            boolean i = ps.execute();
            // Toast.makeText(context,i+"",Toast.LENGTH_SHORT).show();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            flag = true;
        } catch (Exception e) {
            Logger.log("TAG", "executing sql statements exception---->" + e);
            Logger.printException(e);

        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return flag;

    }

    /**
     * Execute ddl.
     *
     * @param sql the sql
     */
    public synchronized boolean executeDDLNew(String sql) {
        Logger.log("TAG", "executing sql statements---->" + sql);
        boolean flag = false;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement(sql);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            flag = true;
        } catch (Exception e) {
            Logger.log("TAG", "executing sql statements exception---->" + e);
            Logger.printException(e);

        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return flag;

    }

    // -----------------------------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------------
    // -----------------------------------NEED--TO--CHANGE--------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------------
    // -----------------------------------------------------------------------------------------------------------------------

    /**
     * Gets the item values.
     *
     * @param idItem the id item
     * @return the item values
     */
    public synchronized ArrayList<String> getItemValues(String idItem) {
        ArrayList<String> tab = new ArrayList<String>();

        String query = "SELECT NM_VALUE_ITEM FROM TREF_MODELE_VALUE_ITEM WHERE ID_MODELE_ITEM ="
                + idItem + " AND DT_SUPPR IS NULL ORDER BY DT_MODIF";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                tab.add(encodeString(cursor.getBytes(1)));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return tab;
    }

    /**
     * Check synchronisation.
     *
     * @param oper the oper
     * @return the int
     */
    public synchronized int checkSynchronisation(int oper) {
        String sql = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int res = 0;
        try {

            if (oper == 1) {
                sql = "SELECT FL_SYNC_DEBUT FROM T_CUSTOMERS";//start
                Logger.log("suspend", "3");
            }
            else if (oper == 2) {
                sql = "SELECT FL_SYNC_REPRENDRE FROM T_CUSTOMERS";//resume
                Logger.log("suspend","3");
                }
            else if (oper == 3) {
                sql = "SELECT FL_SYNC_SUSPENDRE FROM T_CUSTOMERS";//suspend
                Logger.log("suspend","3");
            }
            else if (oper == 4)
                sql = "SELECT FL_SYNC_FIN FROM T_CUSTOMERS";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            cursor.next();
            res = cursor.getInt(1);
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            Log.i("Flag", "FL :" + res);

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return res;
    }

    /**
     * Update DT_FIN_PREV when start job
     *
     * @param dateFinishPrev
     * @param idIntervention
     * @return
     */
    public synchronized boolean updateDtFinPrev(String dateFinishPrev,
                                                String idIntervention) {

        String id_TEMPS_INTERV = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        boolean result = false;
        try {
            String query = "SELECT TOP 1 ID_TEMPS_INTERV,DT_FIN_PREV FROM T_TEMPS_INTERV" +
                    " WHERE ID_INTERVENTION = '" + idIntervention + "' AND FL_SCHEDULED=0 ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                id_TEMPS_INTERV = cursor.getString(1);
                Logger.log(TAG, "CHECK JOB START STOP id_TEMPS_INTERV " + id_TEMPS_INTERV + "dt_fin_prev " + dateFinishPrev);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        PreparedStatement ps = null;
        PreparedStatement ps1 = null;
        ResultSet curs = null;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_TEMPS_INTERV SET DT_FIN_PREV = ?, ID_INTERVENTION = ? WHERE ID_TEMPS_INTERV = ?");
            ps.set(1, dateFinishPrev);
            ps.set(2, idIntervention);
            ps.set(3, id_TEMPS_INTERV);


            ps.execute();
//            ps.close();

            ps1 = getConnectionObj().prepareStatement("SELECT DT_FIN_PREV FROM T_TEMPS_INTERV WHERE ID_TEMPS_INTERV = '" + id_TEMPS_INTERV + "'");
            curs = ps1.executeQuery();
            if (curs.next()) {
                Logger.log(TAG, "CHECK JOB START STOP table dt_fin_prev : " + curs.getString(1));
            }
//            curs.close();
//            ps1.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (curs != null) {
                try {
                    curs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (ps1 != null) {
                try {
                    ps1.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public synchronized void testDtFinPrev(String idIntervention) {
        try {
            //Connection connection = getConnectionObj();
            PreparedStatement ps;
            ps = getConnectionObj()
                    .prepareStatement("SELECT ID_USER FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = ?");
            ps.set(1, idIntervention);
            ResultSet curs = ps.executeQuery();
            while (curs.next()) {
                Logger.log(TAG, "TECHNECIAN ID NAME AFTER JOB START : " + curs.getInt(1));

            }
            ps.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public synchronized AuthExpiryModel getAuth(String login) {

        int idUser = getUserID();

        AuthExpiryModel da = new AuthExpiryModel();
        try {
            //Connection connection = getConnectionObj();

            String str = "SELECT  LOGIN_USER, NOM_USER FROM T_USERS WHERE LOGIN_USER ='" + login + "' AND ID_USER = " + idUser;
            PreparedStatement ps;
            ps = getConnectionObj()
                    .prepareStatement(str);

            ResultSet curs = ps.executeQuery();
            while (curs.next()) {

                da.setAuth(curs.getString(1));
                da.setExpiry(curs.getString(2));
                Logger.log(TAG, "dtFin : " + curs.getString(1));
                Logger.log(TAG, "dtFinPrev : " + curs.getString(2));
            }

            ps.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return da;

    }

    public synchronized String getTempDtFinPrevForJob(String idIntervention) {

        String updatedDtFinPrev = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT DT_DEB_PREV, DT_FIN_PREV, DT_DEB_REAL FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String DT_DEB_REAL = null, DT_FIN_PREV = null, DT_DEB_PREV = null;

            while (cursor.next()) {

                DT_FIN_PREV = cursor.getString(2);
                DT_DEB_PREV = cursor.getString(1);
                DT_DEB_REAL = cursor.getString(3);

            }


//            Logger.log("STR_RESTRT", "TEMP DT_DEB_PREV " + DT_DEB_PREV);
//            Logger.log("STR_RESTRT", "TEMP DT_FIN_PREV " + DT_FIN_PREV);
//            Logger.log("STR_RESTRT", "TEMP DT_DEB_REAL " + DT_DEB_REAL);


            String temp = subtractTwoDateTimeStamps(DT_FIN_PREV, DT_DEB_PREV);
            updatedDtFinPrev = addTwoDateTimeStamps(DT_DEB_REAL, temp);

//            Logger.log("STR_RESTRT", "TEMP UPDATED TEMP_DT_FIN_PREV RESULT " + updatedDtFinPrev);

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return updatedDtFinPrev;
    }

    public synchronized String getUpdatedDtFinPrevForStartJobResumeJob(String idIntervention) {

        String updatedDtFinPrev = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT DT_DEB_REAL, DT_FIN_PREV, DT_DEB_PREV FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String DT_DEB_REAL = null, DT_FIN_PREV = null, DT_DEB_PREV = null;

            while (cursor.next()) {
                DT_DEB_REAL = cursor.getString(1);
                DT_FIN_PREV = cursor.getString(2);
                DT_DEB_PREV = cursor.getString(3);
            }

//            Logger.log("STR_RESTRT", "DT_DEB_REAL " + DT_DEB_REAL);
//            Logger.log("STR_RESTRT", "DT_FIN_PREV " + DT_FIN_PREV);
//            Logger.log("STR_RESTRT", "DT_DEB_PREV " + DT_DEB_PREV);

            String temp = subtractTwoDateTimeStamps(DT_FIN_PREV, DT_DEB_PREV);
            updatedDtFinPrev = addTwoDateTimeStamps(DT_DEB_REAL, temp);

//            Logger.log("STR_RESTRT", "RESULT " + updatedDtFinPrev);

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return updatedDtFinPrev;
    }

    /**
     * Getting DT_FIN for restarting job and Stop Job
     *
     * @param idIntervention
     * @return
     */
    public synchronized String getDtFinForRestartJobAndStopJob(String idIntervention) {
        String dt_Fin = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT DT_FIN FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dt_Fin = cursor.getString(1);
                Logger.log("  PAU_STOP", "CHECK JOB START STOP Dt_Fin " + dt_Fin);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return dt_Fin;

    }

    /**
     * checking with conditions for Restart the job
     *
     * @param idIntervention
     * @return true, false
     */
    public synchronized Boolean checkConditionsForRestartJob(String idIntervention) {
        String dt_Fin_Prev = null;
        String dt_Debut = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT DT_FIN_PREV FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dt_Fin_Prev = cursor.getString(1);
//                Logger.log("RESTART", "Dt_fin_prev " + dt_Fin_Prev);
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        }


        try {
            String query = "SELECT DT_DEBUT FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dt_Debut = cursor.getString(1);
//                Logger.log("RESTART", "Dt_Debut " + dt_Debut);
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        }


//        Log.e("RESTART", "COMPARE " + DateFormatUtils.isFirstDateBeforeSecondDate(dt_Fin_Prev, dt_Debut));

        return DateFormatUtils.isFirstDateBeforeSecondDate(dt_Fin_Prev, dt_Debut);

    }

    public synchronized Boolean checkConditionForRestartJobUpdated(String idIntervention) {
        //new logic for checking
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
        long timeInMillSec = System.currentTimeMillis();
        String tempDt_Debut = sdf.format(timeInMillSec);

        String tempDtFinPrev = getTempDtFinPrevForJob(idIntervention);

        Logger.log("STR_RESTRT", "TEMP CONDITION CHECK DT_DEBUT " + tempDt_Debut);
        Logger.log("STR_RESTRT", "TEMP CONDITION CHECK tempDtFinPrev " + tempDtFinPrev);


        return DateFormatUtils.isFirstDateBeforeSecondDate(tempDtFinPrev, tempDt_Debut);
    }

    public synchronized String getDtDebutAddWithOneHourForRestartJob(String idIntervention) {
        String dt_Debut = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT DT_DEBUT FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dt_Debut = cursor.getString(1);
            }

            Logger.log("RESTART", "Dt_Debut " + dt_Debut);

            dt_Debut = DateFormatUtils.addHourToDateTime(dt_Debut, 1);

            Logger.log("RESTART", "Dt_Debut_1hr " + dt_Debut);

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return dt_Debut;

    }

    /**
     * Gets the nbre nl.
     *
     * @return the nbre nl
     */
    public synchronized int getNbreNL() {
        PreparedStatement stmt;
        ResultSet cursor;

        try {
            String sql = "SELECT COUNT(*) FROM T_ATTRIB_MESSAGES_OPER WHERE FL_LU=0 AND DT_SUPPR is NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            cursor.next();
            int res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return res;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }
    }

    /**
     * convert byte to Encoded string .
     *
     * @param b the b
     * @return the string
     */
    public String encodeString(byte[] b) {
        try {
            return new String(b, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            Logger.printException(e);
            return "";
        }
    }

    /**
     * convert a string To binary.
     *
     * @param s the s
     * @return the byte[]
     */
    public byte[] toBinary(String s) {
        try {
            return s.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            Logger.printException(e);
            return null;
        }
    }

    /**
     * Delete item.
     *
     * @param idItem   the id item
     * @param idInterv the id interv
     */
    public synchronized void deleteItem(int idItem, String idInterv) {
        executeDDL("DELETE FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM="
                + idItem + " AND ID_INTERVENTION='" + idInterv + "'");
    }

    /**
     * Delete saisie piece.
     *
     * @param idPiece  the id piece
     * @param idInterv the id interv
     */
    public synchronized void deleteSaisiePiece(String idPiece, String idInterv) {
        executeDDL("DELETE FROM T_SORTIE_PIECE WHERE ID_PIECE='" + idPiece
                + "' AND ID_INTERVENTION='" + idInterv + "'");
    }

    /**
     * Check signature.
     *
     * @param idInterv the id interv
     * @return the string
     */
    public synchronized String checkSignature(String idInterv) {
        String str = "";
        String com = "";
        int drp1 = 0, drp2 = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT COMMENTAIRE_PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                com = encodeString(cursor.getBytes(1));
                if (com.equals("SIGN_USER"))
                    drp1 = 1;
                if (com.equals("SIGN_CLIENT"))
                    drp2 = 1;
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (drp1 == 0 && drp2 == 0)
            str = "SIGN";
        else if (drp1 == 1 && drp2 == 0)
            str = "SIGN_USER";
        else if (drp1 == 0 && drp2 == 1)
            str = "SIGN_CLIENT";
        else if (drp1 == 1 && drp2 == 1)
            str = "SIGN_DONE";

        return str;
    }

    /**
     * Check signaturefacture.
     *
     * @param idInterv the id interv
     * @param sign     the sign
     * @return the int
     */
    public synchronized int checkSignaturefacture(String idInterv, String sign) {
        String com = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int result = 0;
        try {

            String query = "SELECT COMMENTAIRE_PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                com = encodeString(cursor.getBytes(1));
                if (com.equals(sign))
                    result = 1;
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Delete signature.
     *
     * @param idInterv the id interv
     * @param sign     the sign
     */
    public synchronized boolean deleteSignature(String idInterv, String sign) {
        try {
            if (checkSignaturefacture(idInterv, sign) == 1) {
                executeDDL("DELETE FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                        + idInterv + "' AND COMMENTAIRE_PHOTO_PDA ='" + sign + "'");
            }
            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }

    }

    /**
     * Ajout intervention.
     *
     * @param dateDeb      the date deb
     * @param dateFin      the date fin
     * @param idModel      the id model
     * @param idType       the id type
     * @param nmClt        the nm clt
     * @param nmSite       the nm site
     * @param adresse      the adresse
     * @param adrCompl     the adr compl
     * @param cdStatut     the cd statut
     * @param idClient     the id client
     * @param idSite       the id site
     * @param idEquipement the id equipement
     * @param nmEquipement the nm equipement
     * @param y            the y
     * @param x            the x
     * @param desc         the desc
     * @param rue          the rue
     * @param ville        the ville
     * @param dateMeeting  the date meeting
     * @param photo_Pdas   the photo_ pdas
     * @param cp           the cp
     * @param pays         the pays
     * @return true, if successful
     */
    @SuppressLint("SimpleDateFormat")
    public synchronized boolean ajoutIntervention(String idInterv, String dateDeb, String dateFin,
                                                  int idModel, int idType, String nmClt, String nmSite,
                                                  String adresse, String adrCompl, int cdStatut, int idClient,
                                                  int idSite, int idEquipement, String nmEquipement, String y,
                                                  String x, String desc, String rue, String ville,
                                                  String dateMeeting, String firstNameContact,
                                                  String lastNameContact, String telContact,
                                                  String mobileContact, String emailContact,
                                                  ArrayList<Photo_Pda> photo_Pdas, String cp, String pays,
                                                  String add_province) {

//    if (adresse!=null &&adresse.contains("'")) {
//        adresse = adresse.replace("'", "''");
//        }
//        if (adrCompl!=null &&adrCompl.contains("'")) {
//            adrCompl = adrCompl.replace("'", "''").trim();
//        }
//        if (rue!=null &&rue.contains("'")) {
//            rue = rue.replace("'", "''");
//        }
//        if (ville!=null &&ville.contains("'")) {
//            ville = ville.replace("'", "''");
//        }

        if (adresse != null && adresse.contains("'")) {
            adresse = adresse.replace("'", "''");
        }
        if (adrCompl != null && adrCompl.contains("'")) {
            adrCompl = adrCompl.replace("'", "''").trim();
        }
        if (rue != null && rue.contains("'")) {
            rue = rue.replace("'", "''");
        }
        if (ville != null && ville.contains("'")) {
            ville = ville.replace("'", "''");
        }

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
        String s1 = sdf1.format(System.currentTimeMillis());

        int u = getUser().getId();

        String idUser = String.valueOf(u);
        int idCustomer = getIdCustomer();

        if (dateDeb == null) {
            dateDeb = "NULL";
            idUser = "NULL";
        } else
            dateDeb = "'" + dateDeb + "'";

        if (dateFin == null)
            dateFin = "NULL";
        else
            dateFin = "'" + dateFin + "'";

        if (dateMeeting == null) {
            dateMeeting = "NULL";
        } else
            dateMeeting = "'" + dateMeeting + "'";

//        //v54 changes
//        if (TextUtils.isEmpty(cp))
//            cp = "NULL";
//
//        if (TextUtils.isEmpty(pays))
//            pays = "NULL";

//        if (TextUtils.isEmpty(x))
//            x = "NULL";
//
//        if (TextUtils.isEmpty(y))
//            y = "NULL";

        try {
            PreparedStatement ps = null;
            //Connection connection = getConnectionObj();
            String query = "INSERT INTO T_INTERVENTIONS ("
                    + "ID_INTERVENTION,"
                    + "ID_CUSTOMER,"
                    + "ID_TYPE_INTERVENTION,"
                    + "ID_CLIENT,"
                    + "ID_USER,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "DT_DEB_REAL,"
                    + "DT_FIN_REAL,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "SIGN_CLIENT,"
                    + "SIGN_USER,"
                    + "TXT_COMMENTAIRE_INTERV,"
                    + "CD_STATUT_INTERV,"
                    + "ID_USER_VALIDATION,"
                    + "DT_VALIDATION,"
                    + "DT_MODIF,"
                    + "DT_SUPPR,"
                    + "NOM_CLIENT_INTERV,"
                    + "ID_MODELE_RAPPORT,"
                    + "REF_CUSTOMER,"
                    + "ID_SITE,"
                    + "ID_EQUIPEMENT,"
                    + "NOM_CONTACT,"
                    + "PRENOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "MOBILE_CONTACT, "
                    + "EMAIL_CONTACT, "
                    + "NOM_SITE_INTERV,"
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ADR_INTERV_GLOBALE, "
                    + "ID_USER_LAST_MODIF, "
                    + "DESCR_INTERVENTION, "
                    + "ADR_INTERV_COMPLEMENT, "
                    + "DT_MEETING, " + "ADR_INTERV_PROVINCE,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV )" + " VALUES('"
                    + idInterv
                    + "',"
                    + idCustomer
                    + ","
                    + idType
                    + ",?,"
                    + idUser
                    + ",'',1,"
                    + dateDeb
                    + ","
                    + dateFin
                    + ",NULL,NULL,?,'" + cp + "',?,'" + pays + "',"
                    + "NULL,NULL,NULL,"
                    + cdStatut
                    + ",NULL,NULL,'"
                    + s
                    + ":00.000',NULL,?,"
                    + idModel
                    + ",NULL,?,?,?,?,?,?,?,?,?,?,?,?,?," + dateMeeting + ",?";

            if (!TextUtils.isEmpty(x) && x.trim().length() > 0)
                query += "," + x;
            else
                query += ",NULL";

            if (!TextUtils.isEmpty(y) && y.trim().length() > 0)
                query += "," + y;
            else
                query += ",NULL";

            query += ")";

            Logger.log("TAG", "DULICATON QUERY IS INSERT ===>" + query);

            ps = getConnectionObj().prepareStatement(query);

            if (idClient == -1)
                ps.setNull(1);
            else
                ps.set(1, idClient);

            ps.set(2, cutString(rue, 256));
            ps.set(3, cutString(ville, 256));

//            //new changes
//            if (TextUtils.isEmpty(x))
//                ps.setNull(4);
//            else
//            ps.set(4, cutString(x, 256));
//
//            if (TextUtils.isEmpty(y))
//                ps.setNull(5);
//            else
//            ps.set(5, cutString(y, 256));

            ps.set(4, toBinary(cutString(nmClt, 512)));

            if (idSite == -1)
                ps.setNull(5);
            else
                ps.set(5, idSite);

            if (idEquipement == -1)
                ps.setNull(6);
            else
                ps.set(6, idEquipement);

            if (nmSite == null)
                nmSite = "";

            if (nmEquipement == null)
                nmEquipement = "";


            ps.set(7, cutString(lastNameContact, 256));
            ps.set(8, cutString(firstNameContact, 256));
            ps.set(9, cutString(telContact, 256));
            ps.set(10, cutString(mobileContact, 256));
            ps.set(11, cutString(emailContact, 256));
            ps.set(12, toBinary(cutString(nmSite, 512)));
            ps.set(13, toBinary(cutString(nmEquipement, 512)));
            ps.set(14, toBinary(cutString(adresse, 512)));
            ps.set(15, u);

            ps.set(16, toBinary(cutString(desc, 2048)));
            ps.set(17, toBinary(cutString(adrCompl, 256)));
            ps.set(18, cutString(add_province, 256));

            ps.execute();
            ps.close();
            //connection.commit();
            connDao.commit();

            for (Photo_Pda photo_Pda : photo_Pdas) {
                PreparedStatement psPhoto = null;
                try {
                    psPhoto = getConnectionObj()
                            .prepareStatement("INSERT INTO T_PHOTOS_PDA(ID_PHOTO_PDA,ID_INTERVENTION,PHOTO_PDA,COMMENTAIRE_PHOTO_PDA,EXTENSION) VALUES(?,?,?,?,?)");

                    psPhoto.set(1, getUniqueId());
                    psPhoto.set(2, idInterv);
                    psPhoto.set(4, toBinary(photo_Pda.getCommentaire()));
                    psPhoto.set(5, toBinary(photo_Pda.getExtention()));

                    OutputStream os = psPhoto.getBlobOutputStream(3);


                    String filePath = photo_Pda.getFilePath();
                    if (filePath != null) {
                        try {
                            writeImgWithEXIF(filePath, os);
//                            writeImgWithEXIFOOM(filePath, os);
                        } catch (OutOfMemoryError ofMemoryError) {
                            writeImgWithEXIFOOM(filePath, os);
                        } catch (Exception e) {
                            Logger.log(TAG, "Error ocurred while saving image");
                        }
                    } else {
                        os.write(photo_Pda.getPhoto());
                    }

//                    Bitmap bitmap = BitmapFactory.decodeByteArray(
//                            photo_Pda.getPhoto(), 0,
//                            photo_Pda.getPhoto().length);
//
//                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);

                    // for (int readNum; (readNum = fis.read(data)) != -1;)
                    // {
                    // os.write(data, 0, readNum);
                    // }

                    os.close();
                    psPhoto.execute();
                    psPhoto.close();

                    //connection.commit();
                    connDao.commit();

                    PreparedStatement preparedStatement = getConnectionObj()
                            .prepareStatement("Select NEWID()");

                    ResultSet cursor = preparedStatement.executeQuery();

                    while (cursor.next()) {
                        Logger.log("New Id", cursor.getString(1));

                    }

                    cursor.close();
                    preparedStatement.close();
                    //connection.commit();
                    connDao.commit();
                } catch (Exception e) {
                    Logger.printException(e);
                }

            }

            //connection.release();
            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }

    public synchronized boolean addUnavailability(String uniqueId, int unavailabilityType,
                                                  int userId, String startDate, String endDate, String notesdesc) {

        uniqueId = getUniqueId();

//        if (startDate == null) {
//            startDate = "NULL";
//        } else
//            startDate = "'" + startDate + "'";
//
//        if (endDate == null)
//            endDate = "NULL";
//        else
//            endDate = "'" + endDate + "'";

        int u = getUser().getId();
        String idUser = String.valueOf(u);
        PreparedStatement ps = null;
        boolean result = false;
        try {

            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (ID_REMOTE,ID_TYPE_CONGE,ID_USER,DT_DEBUT,DT_FIN,NOTES )"
                    + "VALUES(?,?,?,?,?,?)");

            //old code
//            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (" + "ID_REMOTE,"
//                    + "ID_TYPE_CONGE," + "ID_USER," + "DT_DEBUT," + "DT_FIN,"
//                    + "NOTES )" + "VALUES('" + uniqueId + "',"
//                    + unavailabilityType + "," + idUser + "," + startDate + ","
//                    + endDate + ",'" + notesdesc + "')");

            ps.set(1, uniqueId);
            ps.set(2, unavailabilityType);
            ps.set(3, idUser);
            ps.set(4, startDate);
            ps.set(5, endDate);
            ps.set(6, notesdesc);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();

        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    // ------------------------------------------------------------------------------------------------------------------------------

    public synchronized String addUnavailabilityAndReturnID(String uniqueId, int unavailabilityType, int userId, String startDate, String endDate, String notesdesc) {

//        if (startDate == null) {
//            startDate = "NULL";
//        } else
//            startDate = "'" + startDate + "'";
//
//        if (endDate == null)
//            endDate = "NULL";
//        else
//            endDate = "'" + endDate + "'";

        Logger.log(TAG, "UPDATE END TIME ACTIVITY STARTTIME =====>" + startDate);
        Logger.log(TAG, "UPDATE END TIME ACTIVITY ENDTIME =====>" + endDate);


        String result = null;
        PreparedStatement ps = null;
        try {

            int u = getUser().getId();
            String idUser = String.valueOf(u);

            uniqueId = getUniqueId();


            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (ID_REMOTE,ID_TYPE_CONGE,ID_USER,DT_DEBUT,DT_FIN,NOTES )"
                    + "VALUES(?,?,?,?,?,?)");

            //old code
//            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (" + "ID_REMOTE,"
//                    + "ID_TYPE_CONGE," + "ID_USER," + "DT_DEBUT," + "DT_FIN,"
//                    + "NOTES )" + "VALUES('" + uniqueId + "',"
//                    + unavailabilityType + "," + idUser + "," + startDate + ","
//                    + endDate + ",'" + notesdesc + "')");

            ps.set(1, uniqueId);
            ps.set(2, unavailabilityType);
            ps.set(3, idUser);
            ps.set(4, startDate);
            ps.set(5, endDate);
            ps.set(6, notesdesc);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = uniqueId;
        } catch (Exception e) {
            e.printStackTrace();
            result = null;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * Gets the all msg.
     *
     * @return the all msg
     */
    public synchronized ArrayList<Message_oper> getAllMsg() {
        ArrayList<Message_oper> messages = new ArrayList<Message_oper>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT T_MESSAGES_OPERATEUR.ID_MESSAGE, TITRE_MESSAGE ,CORP_MESSAGE ,PRIORITE_MESSAGE,T_ATTRIB_MESSAGES_OPER.FL_LU FROM T_MESSAGES_OPERATEUR,T_ATTRIB_MESSAGES_OPER  WHERE T_MESSAGES_OPERATEUR.ID_MESSAGE=T_ATTRIB_MESSAGES_OPER.ID_MESSAGE AND T_ATTRIB_MESSAGES_OPER.DT_SUPPR is NULL ORDER BY T_ATTRIB_MESSAGES_OPER.FL_LU ASC,T_ATTRIB_MESSAGES_OPER.DT_MODIF DESC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                Message_oper message = new Message_oper(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)), cursor.getInt(4),
                        cursor.getInt(5));
                messages.add(message);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return messages;
    }

    /**
     * Delete msg.
     *
     * @param id the id
     */
    public synchronized void deleteMsg(int id) {
        executeDDL("DELETE FROM T_ATTRIB_MESSAGES_OPER WHERE id_message='" + id
                + "'");
    }

    // /**
    // * Gets the all categorie.
    // *
    // * @param idIntervention
    // * the id intervention
    // * @param i
    // * the i
    // * @return the all categorie
    // */
    // public ArrayList<Categorie> getAllCategorie(String idIntervention, int i)
    // {
    // ArrayList<Categorie> cats = new ArrayList<Categorie>();
    // String query = "";
    // try {
    //
    // if (getCountCat() > 6 && getCountPiece("0") > 1000) {
    // query = "SELECT TOP 20 START AT " + i
    // + " ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
    // + "FROM TREF_CATEGORIE_PIECE where DT_SUPPR is NULL "
    // + " ORDER BY NM_CATEGORIE_PIECE ";
    // } else {
    // query =
    // "SELECT  distinct TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
    // +
    // "FROM TREF_CATEGORIE_PIECE,TREF_PIECES where TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE "
    // +
    // "AND TREF_CATEGORIE_PIECE.DT_SUPPR is NULL AND TREF_PIECES.DT_SUPPR is NULL ORDER BY NM_CATEGORIE_PIECE ";
    // }
    //
    // PreparedStatement stmt = connDao.prepareStatement(query);
    // ResultSet cursor = stmt.executeQuery();
    // while (cursor.next()) {
    //
    // ArrayList<HashMap<String, String>> pices = getPieceByCategorie(
    // String.valueOf(cursor.getInt(1)), idIntervention);
    //
    // Categorie map = new Categorie(cursor.getInt(1),
    // encodeString(cursor.getBytes(2)), pices);
    //
    // cats.add(map);
    // }
    // cursor.close();
    // stmt.close();
    // connDao.commit();
    // } catch (Exception e) {
    // e.printStackTrace();
    // }
    // return cats;
    // }

    // public ArrayList<Categorie> getAllCategorie(int i) {
    // ArrayList<Categorie> cats = new ArrayList<Categorie>();
    // String query = "";
    // try {
    //
    // if (getCountCat() > 6 && getCountPiece("0") > 1000) {
    // query = "SELECT TOP 20 START AT " + i
    // + " ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
    // + "FROM TREF_CATEGORIE_PIECE where DT_SUPPR is NULL "
    // + " ORDER BY NM_CATEGORIE_PIECE ";
    // } else {
    // query =
    // "SELECT  distinct TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
    // +
    // "FROM TREF_CATEGORIE_PIECE,TREF_PIECES where TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE "
    // +
    // "AND TREF_CATEGORIE_PIECE.DT_SUPPR is NULL AND TREF_PIECES.DT_SUPPR is NULL ORDER BY NM_CATEGORIE_PIECE ";
    // }
    //
    // PreparedStatement stmt = connDao.prepareStatement(query);
    // ResultSet cursor = stmt.executeQuery();
    // while (cursor.next()) {
    //
    // Categorie categorie = new Categorie(cursor.getInt(1),
    // encodeString(cursor.getBytes(2)));
    //
    // cats.add(categorie);
    // }
    // cursor.close();
    // stmt.close();
    // } catch (Exception e) {
    // e.printStackTrace();
    // }
    // return cats;
    // }

    /**
     * Maj msg lu.
     *
     * @param id the id
     */
    public synchronized void majMsgLu(int id) {
        executeDDL("UPDATE T_ATTRIB_MESSAGES_OPER SET FL_LU = '1' WHERE ID_MESSAGE='"
                + id + "'");
    }

    /**
     * Gets the all categorie niveau.
     *
     * @param i           the i
     * @param nom         the nom
     * @param scrollIndex the scroll index
     * @return the all categorie niveau
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Categorie> getAllCategorieNiveau(int i, String nom,
                                                                   int scrollIndex) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();
        String query = "";

        query = "SELECT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
                + "FROM TREF_CATEGORIE_PIECE where TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";


        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    public class _categoryFilter {

        boolean isInventory = false;
        public boolean inStock = false;
        public boolean isRequested = false;
        public String category = "";
        public int index;
        public int scrollIndex;
        public int categoryId = 0;
        public String searchText = "";


        public void resetCategory(String newCategory) {
            this.category = newCategory;
            this.categoryId = 0;
        }

    }

    /**
     * method to fetch the category name for the inventory list
     *
     * @return
     */
    public synchronized ArrayList<Categorie> _categoryNameList(_categoryFilter filter) {
        ArrayList<Categorie> categoryList = new ArrayList<>();
        ArrayList<String> catNameList = new ArrayList<>();
        try {

            PreparedStatement stmt = _categoryNameListQuery(filter, false);
            if (stmt == null) return categoryList;

            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");
                //new logic
                int idCat;
                if ((temp.length - (filter.index + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[filter.index], temp.length, filter.index + 1);
                    if (!categoryList.contains(map))
                        categoryList.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[filter.index], temp.length, filter.index + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        categoryList.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[filter.index]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return categoryList;
    }

    private PreparedStatement _categoryNameListQuery(_categoryFilter filter, boolean isCount) {


        //isInventory false & isStockChecked true
        String query1 =
                "(TREF_PIECES LEFT JOIN T_STOCK_PIECES ON T_STOCK_PIECES.ID_PIECE " +
                        "= TREF_PIECES.ID_PIECE) LEFT JOIN TREF_CATEGORIE_PIECE cat" +
                        "ON cat.ID_CATEGORIE_PIECE = " +
                        "TREF_PIECES.ID_CATEGORIE_PIECE where TREF_PIECES.DT_SUPPR IS NULL " +

                        "AND T_STOCK_PIECES.QUANTITY > 0 " +
                        "AND TREF_PIECES.FL_TRACK_STOCK = 1";

        //isInventory false & isStockChecked false
        query1 = "FROM TREF_CATEGORIE_PIECE where " +
                "TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";

        //isInventory true & isStockChecked false && isRequested false
        query1 = "TREF_PIECES INNER JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE WHERE " +
                "TREF_PIECES.DT_SUPPR IS NULL " +

                "AND TREF_PIECES.FL_TRACK_STOCK = 1";


        //isInventory true & isStockChecked true && isRequested true
        query1 = "FROM ((TREF_PIECES p LEFT JOIN TREF_CATEGORIE_PIECE cat ON " +
                "cat.ID_CATEGORIE_PIECE = " +
                "p.ID_CATEGORIE_PIECE) LEFT JOIN " +
                "T_STOCK_PIECES s ON s.ID_PIECE = p.ID_PIECE)" +
                " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = " +
                "p.ID_PIECE " +

                "WHERE p.DT_SUPPR IS NULL" +
                " AND p.FL_TRACK_STOCK = 1 AND" +
                " d.FL_TRANSFER = 0 AND " +
                "d.DT_COMPLETED IS NULL AND s.QUANTITY > 0";


        //isInventory true & isStockChecked true && isRequested false
        query1 = "(TREF_PIECES p LEFT JOIN T_STOCK_PIECES s ON s.ID_PIECE " +
                "= p.ID_PIECE) LEFT JOIN TREF_CATEGORIE_PIECE cat" +
                "ON cat.ID_CATEGORIE_PIECE = " +
                "p.ID_CATEGORIE_PIECE where " +
                "p.DT_SUPPR IS NULL " +

                "AND s.QUANTITY > 0 " +
                "AND p.FL_TRACK_STOCK = 1";

        //isInventory true & isStockChecked false && isRequested true
        query1 = "FROM ((TREF_PIECES p LEFT JOIN TREF_CATEGORIE_PIECE cat ON " +
                "cat.ID_CATEGORIE_PIECE = " +
                "p.ID_CATEGORIE_PIECE)  " +
                " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = " +
                "p.ID_PIECE " +
                "WHERE p.DT_SUPPR IS NULL" +

                " AND p.FL_TRACK_STOCK = 1" +
                " AND d.FL_TRANSFER = 0" +
                " AND d.DT_COMPLETED IS NULL ";


        //Setup Base Query
        String query = "SELECT cat.ID_CATEGORIE_PIECE, " +
                "cat.NM_CATEGORIE_PIECE FROM ";

//        if (isCount) query = "SELECT count(*) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL #WHERE#";

        String joins = "";
        String where = "";

        if (filter.inStock) {
            where += " AND s.QUANTITY > 0 ";
            where += " AND p.FL_TRACK_STOCK = 1 ";
        }
        if (filter.isRequested) {
            joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
            where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";
        }
        if (!TextUtils.isEmpty(filter.category) && filter.categoryId == 0) { //We've select a category, get the ID
            filter.categoryId = _inventoryPartListCategoryId(filter.category);
        }
        if (filter.categoryId > 0) {
            where += " AND p.ID_CATEGORIE_PIECE = :categoryId ";
        }


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        //Order by clause when not counting
        query += isCount ? "" : " ORDER BY p.NM_PIECE ASC";

        Logger.log("Q", query.replace(":searchText", "%" + filter.searchText + "%").replace(":categoryId", String.valueOf(filter.categoryId)));

        try {

            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            if (filter.categoryId > 0) stmt.set("categoryId", filter.categoryId);
            if (!TextUtils.isEmpty(filter.searchText))
                stmt.set("searchText", "%" + filter.searchText + "%");

            return stmt;

        } catch (Exception e) {

            e.printStackTrace();
            Logger.printException(e);
            return null;

        }
    }

    public synchronized ArrayList<Categorie> getStockCategorieNiveauNew(int i, String nom,
                                                                        int scrollIndex) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query = "SELECT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, " +
                "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE FROM " +
                "(TREF_PIECES LEFT JOIN T_STOCK_PIECES ON T_STOCK_PIECES.ID_PIECE " +
                "= TREF_PIECES.ID_PIECE) LEFT JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE where " +
                "TREF_PIECES.DT_SUPPR IS NULL AND T_STOCK_PIECES.QUANTITY > 0 " +
                "AND TREF_PIECES.FL_TRACK_STOCK = 1";

        if (!TextUtils.isEmpty(nom))
            query += "AND TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }


        return cats;
    }

    /**
     * Gets the all categorie niveau.
     *
     * @param i           the i
     * @param nom         the nom
     * @param scrollIndex the scroll index
     * @return the all categorie niveau
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Categorie> getAllCategoryInventory(int i, String nom,
                                                                     int scrollIndex) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();
        int cnt = 0;
        //new query changes
        query = "SELECT DISTINCT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, " +
                "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE FROM " +
                "TREF_PIECES INNER JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE WHERE " +
                "TREF_PIECES.DT_SUPPR IS NULL " +
                "AND TREF_PIECES.FL_TRACK_STOCK = 1";

        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");


            cursor = stmt.executeQuery();
            while (cursor.next()) {
                cnt++;
                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                    Logger.log(TAG, "SUB_CATEGORY item name is =====>" + map.getNomcat());
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + map.getNomcat());
                    }
                }


            }

            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    public synchronized ArrayList<Categorie> getStockRequestCategoryInventoryNew(int i, String nom,
                                                                                 int scrollIndex) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query = "SELECT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE," +
                " TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE " +
                "FROM ((TREF_PIECES LEFT JOIN TREF_CATEGORIE_PIECE ON " +
                "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE) LEFT JOIN " +
                "T_STOCK_PIECES ON T_STOCK_PIECES.ID_PIECE = TREF_PIECES.ID_PIECE)" +
                " LEFT JOIN T_PIECE_DEMANDE ON T_PIECE_DEMANDE.ID_PIECE = " +
                "TREF_PIECES.ID_PIECE WHERE TREF_PIECES.DT_SUPPR IS NULL" +
                " AND TREF_PIECES.FL_TRACK_STOCK = 1 AND" +
                " T_PIECE_DEMANDE.FL_TRANSFER = 0 AND " +
                "T_PIECE_DEMANDE.DT_COMPLETED IS NULL AND T_STOCK_PIECES.QUANTITY > 0";

        if (!TextUtils.isEmpty(nom))
            query += "AND TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

    /**
     * Gets the all inventory categories with pending request.
     *
     * @param i           the i
     * @param nom         the nom
     * @param scrollIndex the scroll index
     * @return the all categorie niveau
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Categorie> getRequestCategoryInventory(int i, String nom,
                                                                         int scrollIndex) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query = "SELECT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
                + "FROM TREF_CATEGORIE_PIECE " +
                "where ID_CATEGORIE_PIECE IN (SELECT TREF_PIECES.ID_CATEGORIE_PIECE FROM TREF_PIECES WHERE DT_SUPPR IS NULL AND FL_TRACK_STOCK = 1 " +
                "AND TREF_PIECES.ID_PIECE IN (SELECT T_PIECE_DEMANDE.ID_PIECE FROM T_PIECE_DEMANDE WHERE TREF_PIECES.ID_PIECE = T_PIECE_DEMANDE.ID_PIECE AND FL_TRANSFER = 0 AND DT_COMPLETED IS NULL)) ";

        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    /**
     * Gets the niveau categorie.
     *
     * @return the niveau categorie
     */
    public synchronized Boolean getNiveauCategorie() {

        String query = "";
        Boolean drp = false;
        try {

            query = "SELECT NM_CATEGORIE_PIECE "
                    + "FROM TREF_CATEGORIE_PIECE where DT_SUPPR is NULL "
                    + "ORDER BY NM_CATEGORIE_PIECE ";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(1));

                String[] temp = nm.split("\\|");

                if (temp.length == 1) {
                    drp = false;
                } else
                    drp = true;
                break;
            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
            Logger.printException(e);
        }
        return drp;
    }

    /**
     * Gets the count cat.
     *
     * @param nomCat the nom cat
     * @return the count cat
     */
    public synchronized int getCountCat(String nomCat) {
        String query = "SELECT count(*) FROM TREF_CATEGORIE_PIECE where DT_SUPPR is NULL";

        if (!TextUtils.isEmpty(nomCat))
            query += " AND NM_CATEGORIE_PIECE LIKE ? ";

        ResultSet cursor;
        try {
            PreparedStatement stmt = connDao.prepareStatement(query);
            if (!TextUtils.isEmpty(nomCat))
                stmt.set(1, nomCat + "%");

            cursor = stmt.executeQuery();

            cursor.next();
            int res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return res;
        } catch (Exception e) {
            return 0;
        }

    }

    /**
     * Gets the piece by categorie.
     *
     * @param idCat          the id cat
     * @param idIntervention the id intervention
     * @param index          the index
     * @param numberOfPices  the number of pices
     * @return the piece by categorie
     */
    public synchronized ArrayList<CatalougePieces> getPieceByCategorie(String idCat,
                                                                       String idIntervention,
                                                                       int index, int numberOfPices) {
        ArrayList<CatalougePieces> listPiece = new ArrayList<CatalougePieces>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            if (numberOfPices >= 20) {
                query = "SELECT TOP 20 START AT "
                        + index
                        + " ID_PIECE, NM_PIECE ,PRIX_PIECE FROM TREF_PIECES WHERE ID_CATEGORIE_PIECE ='"
                        + idCat + "' AND DT_SUPPR is NULL ORDER BY NM_PIECE ";
            } else {
                query = "SELECT ID_PIECE, NM_PIECE ,PRIX_PIECE FROM TREF_PIECES WHERE ID_CATEGORIE_PIECE ='"
                        + idCat + "' AND DT_SUPPR is NULL ORDER BY NM_PIECE ";
            }
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                // HashMap<String, String> map = new HashMap<String, String>();

                String numberOfpices = getNumberOfPices(
                        String.valueOf(cursor.getInt(1)), idIntervention);

                CatalougePieces catalougePices = new CatalougePieces(
                        String.valueOf(cursor.getInt(1)),
                        encodeString(cursor.getBytes(2)), String.valueOf(cursor
                        .getFloat(3)), numberOfpices);

                listPiece.add(catalougePices);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listPiece;
    }

    /**
     * Gets the number of pices.
     *
     * @param id             the id
     * @param idIntervention the id intervention
     * @return the number of pices
     */
    public synchronized String getNumberOfPices(String id, String idIntervention) {
        String query = "SELECT QUANTITE_SORTIE FROM T_SORTIE_PIECE where ID_PIECE='"
                + id + "' AND ID_INTERVENTION='" + idIntervention + "'";
        String pices = "0";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                pices = String.valueOf(cursor.getFloat(1));
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            pices = "0";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return pices;
    }

    /**
     * Gets the count piece.
     *
     * @param idCat the id cat
     * @return the count piece
     */
    public synchronized int getCountPiece(String idCat) {
        String query = "SELECT count(*) FROM TREF_PIECES WHERE DT_SUPPR is NULL ";
        if (!idCat.equals("0"))
            query += "AND ID_CATEGORIE_PIECE ='" + idCat + "' ";

        PreparedStatement stmt;
        ResultSet cursor;
        try {
            stmt = connDao.prepareStatement(query);
            cursor = stmt.executeQuery();
            cursor.next();
            int res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return res;
        } catch (Exception e) {
            return 0;
        }

    }

    /**
     * Gets the sortiepiece.
     *
     * @param idInter the id inter
     * @return the sortiepiece
     */
    public synchronized Vector<SortiePiece> getSortiepiece(String idInter) {
        Vector<SortiePiece> st = new Vector<SortiePiece>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

//            String query = " SELECT "
//                    + " TREF_PIECES.ID_PIECE,"
//                    + " NM_PIECE,"
//                    + " PRIX_PIECE,"
//                    + " FL_SERIALIZABLE,"
//                    + " QUANTITE_SORTIE, "
//                    + " NM_CATEGORIE_PIECE, "
//                    + " FL_FACTURABLE "
//                    + " SERIAL_REPRISE,"
//                    + " QUANTITE_REPRISE "
//                    + " FROM "
//                    + " T_SORTIE_PIECE ,TREF_PIECES ,TREF_CATEGORIE_PIECE "
//                    + " WHERE TREF_PIECES.ID_PIECE = T_SORTIE_PIECE.ID_PIECE "
//                    + " AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
//                    + " AND T_SORTIE_PIECE.QUANTITE_SORTIE > 0"
//                    + " AND ID_INTERVENTION = '" + idInter + "'";


            String query = " SELECT "
                    + " TREF_PIECES.ID_PIECE,"
                    + " NM_PIECE,"
                    + " PRIX_PIECE,"
                    + " FL_SERIALIZABLE,"
                    + " QUANTITE_SORTIE, "
                    + " NM_CATEGORIE_PIECE, "
                    + " FL_FACTURABLE, "
                    + " SERIAL_SORTIE, "
                    + " FL_TRACK_STOCK "
                    + " FROM "
                    + " T_SORTIE_PIECE ,TREF_PIECES ,TREF_CATEGORIE_PIECE "
                    + " WHERE TREF_PIECES.ID_PIECE = T_SORTIE_PIECE.ID_PIECE "
                    + " AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
//                    + " AND T_SORTIE_PIECE.QUANTITE_SORTIE > 0"

                    + " AND (T_SORTIE_PIECE.QUANTITE_SORTIE ='0' OR T_SORTIE_PIECE.QUANTITE_SORTIE >'0')"
                    + " AND ID_INTERVENTION = '" + idInter + "'";


            // + "' AND T_SORTIE_PIECE.QUANTITE_SORTIE >= 1 ";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                SortiePiece sp = new SortiePiece(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getDouble(3),
                        cursor.getInt(4), cursor.getDouble(5),
                        encodeString(cursor.getBytes(6)), cursor.getInt(7),
                        "", 0, encodeString(cursor.getBytes(8)), cursor.getInt(9));

//                SortiePiece sp = new SortiePiece(cursor.getInt(1),
//                        encodeString(cursor.getBytes(2)), cursor.getDouble(3),
//                        cursor.getInt(4), cursor.getDouble(5),
//                        encodeString(cursor.getBytes(6)), cursor.getInt(7),
//                        "", 0, "");

                st.add(sp);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return st;
    }

    /**
     * Insert sortie piece.
     *
     * @param idIter   the id iter
     * @param idPiece  the id piece
     * @param quantite the quantite
     * @param valDepot the val depot
     */
    public synchronized void insertSortiePiece(String idIter, String idPiece,
                                               String quantite, int valDepot, String serialSortie) {

        executeDDL("INSERT INTO T_SORTIE_PIECE(ID_INTERVENTION,ID_PIECE,QUANTITE_SORTIE,FL_FACTURABLE,SERIAL_SORTIE) VALUES ('"
                + idIter
                + "','"
                + idPiece
                + "','"
                + quantite
                + "',"
                + valDepot
                + ",'"
                + serialSortie
                + "')");
    }

    /**
     * Gets the nom cat by id.
     *
     * @param idpiece the idpiece
     * @return the nom cat by id
     */
    public synchronized String getNomCatById(int idpiece) {

        try {
            String query = "SELECT NM_CATEGORIE_PIECE FROM TREF_CATEGORIE_PIECE, TREF_PIECES WHERE TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE AND TREF_PIECES.ID_PIECE='"
                    + idpiece + "'";
            PreparedStatement stmt;
            stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            if (cursor.next()) {
                String nomCat = encodeString(cursor.getBytes(1));
                cursor.close();
                stmt.close();
                connDao.commit();
                return nomCat;
            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
            Logger.printException(e);
        }
        return null;
    }

    /**
     * Gets the nom piece by id.
     *
     * @param idpiece the idpiece
     * @return the nom piece by id
     */
    public synchronized String getNomPieceById(int idpiece) {

        try {
            String query = "SELECT NM_PIECE FROM TREF_PIECES WHERE ID_PIECE = '"
                    + idpiece + "' ";
            PreparedStatement stmt;
            stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            if (cursor.next()) {
                String nomCat = encodeString(cursor.getBytes(1));
                cursor.close();
                stmt.close();
                connDao.commit();
                return nomCat;
            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
            Logger.printException(e);
        }
        return null;
    }

    /**
     * Gets the nbre sor pie by id pie and id inter.
     *
     * @param idPiece the id piece
     * @param idInter the id inter
     * @return the nbre sor pie by id pie and id inter
     */
    public synchronized String[] getNbreSorPieByIdPieAndIdInter(String idPiece,
                                                                String idInter) {
        String sql_string = "SELECT QUANTITE_SORTIE,FL_FACTURABLE FROM T_SORTIE_PIECE WHERE ID_INTERVENTION='"
                + idInter + "' AND ID_PIECE='" + idPiece + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String[] tableau = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                tableau = new String[]{Float.toString(cursor.getFloat(1)),
                        Integer.toString(cursor.getInt(2))};
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            tableau = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tableau;
    }

    /**
     * Maj quantite.
     *
     * @param idPiece  the id piece
     * @param idInter  the id inter
     * @param qt       the qt
     * @param valDepot the val depot
     */
    public synchronized void majQuantite(String idPiece, String idInter, String qt,
                                         int valDepot, String serialSortie) {

        executeDDL("UPDATE T_SORTIE_PIECE SET QUANTITE_SORTIE =" + qt
                + ",SERIAL_SORTIE='" + serialSortie + "',FL_FACTURABLE =" + valDepot + " WHERE ID_INTERVENTION='"
                + idInter + "' AND ID_PIECE='" + idPiece + "'");
    }

    /**
     * Gets the discription of intervention by id.
     *
     * @param idInter the id inter
     * @return the intervention by id
     */
    public synchronized Description getInterventionById(String idInter) {
        Description desc = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT  "
                    + "T_INTERVENTIONS.NOM_CLIENT_INTERV,"
                    + "T_INTERVENTIONS.ADR_INTERV_RUE,"
                    + "T_INTERVENTIONS.ADR_INTERV_CP,"
                    + "T_INTERVENTIONS.ADR_INTERV_VILLE,"
                    + "T_INTERVENTIONS.ADR_INTERV_PAYS,"
                    + "T_INTERVENTIONS.NOM_CONTACT,"
                    + "T_INTERVENTIONS.TEL_CONTACT,"
                    + "T_INTERVENTIONS.DT_DEB_PREV,"
                    + "T_INTERVENTIONS.DT_FIN_PREV,"
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.DESCR_INTERVENTION,"
                    + "T_INTERVENTIONS.ADR_INTERV_GLOBALE,"
                    + "T_INTERVENTIONS.ADR_INTERV_COMPLEMENT,"
                    + "T_INTERVENTIONS.NO_INT_CUST,"
                    + "T_INTERVENTIONS.MOBILE_CONTACT, "
                    + "T_INTERVENTIONS.REF_CUSTOMER, "
                    + "T_INTERVENTIONS.PUBLIC_LINK, "
                    + "T_INTERVENTIONS.PRENOM_CONTACT, "
                    + "T_INTERVENTIONS.EMAIL_CONTACT, "
                    + "T_CLIENTS.PUBLIC_LINK, "
                    + "T_CLIENTS.ID_CLIENT "
//                    + "FROM TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT,T_INTERVENTIONS  "
                    + "FROM TREF_TYPE_INTERVENTION,T_INTERVENTIONS  "
                    + "LEFT JOIN T_CLIENTS "
                    + "ON T_INTERVENTIONS.ID_CLIENT = T_CLIENTS.ID_CLIENT "
                    + " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION = TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT = TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_INTERVENTION= '" + idInter + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                desc = new Description(encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        cursor.getString(8),
                        cursor.getString(9),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        cursor.getString(12),
                        cursor.getString(13),
                        cursor.getInt(14),
                        cursor.getString(15),
                        encodeString(cursor.getBytes(16)),
                        cursor.getString(17),
                        encodeString(cursor.getBytes(18)),
                        encodeString(cursor.getBytes(19)),
                        cursor.getString(20),
                        cursor.getInt(21));
            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return desc;
    }

    /**
     * Gets the model report of intervention by id.
     *
     * @param idInter the id inter
     * @return the intervention by id
     */
    public synchronized String getModelReportNameById(String idInter) {

        String modeleIntervention = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT  "
                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT"
                    + " FROM TREF_MODELE_RAPPORT  "
                    + " WHERE "
                    + "ID_MODELE_RAPPORT = (SELECT ID_MODELE_RAPPORT FROM T_INTERVENTIONS "
                    + "WHERE ID_INTERVENTION= '" + idInter + "')";
//
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                modeleIntervention = encodeString(cursor.getBytes(1));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return modeleIntervention;

    }

    //TODO check for iteration in T_SAISIE_RAPPORT

    /**
     * Gets the public links of intervention by ID .
     *
     * @param idInter the id inter
     * @return the intervention by id
     */
    public synchronized Description getPublicLinksById(String idInter) {
        Description desc = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT  "
                    + "T_INTERVENTIONS.PUBLIC_LINK, "
                    + "T_CLIENTS.PUBLIC_LINK "
                    + "FROM TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT,T_INTERVENTIONS  "
                    + "LEFT JOIN T_CLIENTS "
                    + "ON T_INTERVENTIONS.ID_CLIENT = T_CLIENTS.ID_CLIENT "
                    + " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION = TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION AND "
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT = TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_INTERVENTION= '" + idInter + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                desc = new Description(encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)));
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return desc;
    }

    /**
     * Gets the all photo by id intervention.
     *
     * @param idInter the id inter
     * @return the all photo by id intervention
     */
    public synchronized Vector<Photo_Pda> getAllPhotoByIdIntervention(String idInter) {
        Vector<Photo_Pda> ph = new Vector<Photo_Pda>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT ID_PHOTO_PDA, ID_INTERVENTION,COMMENTAIRE_PHOTO_PDA,PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION= '"
                    + idInter
                    + "' AND DT_SUPPR is NULL AND COMMENTAIRE_PHOTO_PDA <> 'SIGN_CLIENT' AND "
                    + "COMMENTAIRE_PHOTO_PDA <> 'SIGN_USER' AND COMMENTAIRE_PHOTO_PDA <> 'SIGN_FACTURE' AND "
                    + "COMMENTAIRE_PHOTO_PDA NOT IN ( SELECT ('SIGN_'||ID_MODELE_ITEM) FROM T_SAISIE_RAPPORT "
                    + "WHERE ID_INTERVENTION = '"
                    + idInter
                    + "' AND DT_SUPPR IS NULL)";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                Photo_Pda p = new Photo_Pda(cursor.getString(1),
                        cursor.getString(2), encodeString(cursor.getBytes(3)),
                        cursor.getBytes(4));
                ph.add(p);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return ph;
    }

    /**
     * Resize bitmap.
     *
     * @param bitmap    the bitmap
     * @param newHeight
     * @param newWidth
     * @return the bitmap
     */
    public synchronized Bitmap resizeBitmap(Bitmap bitmap, int newWidth, int newHeight,
                                            int rotate) {
        int width, height;
        float scaleWidth, scaleHeight;
        Matrix matrix;
        width = bitmap.getWidth();
        height = bitmap.getHeight();
        Logger.log("Dao>>>>>> Width Height ", width + " " + height + " ");

        scaleWidth = ((float) newWidth) / width;
        scaleHeight = ((float) newHeight) / height;
        float scale = Math.min(scaleWidth, scaleHeight);
        scale = Math.min(scale, 1);
        matrix = new Matrix();
        matrix.postScale(scale, scale);
        matrix.postRotate(rotate);
        Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height,
                matrix, true);
        Logger.log("Dao>>>>>> Width Height New ", resizedBitmap.getWidth()
                + " " + resizedBitmap.getHeight());
        return (resizedBitmap);

    }

    /**
     * Insert photo.
     *
     * @param idInter     the id inter
     * @param file        the file
     * @param commentaire the commentaire
     * @param extension   the extension
     */
    public synchronized void insertPhoto(String idInter, String file,
                                         String commentaire, String extension, int iteration) {
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("INSERT INTO T_PHOTOS_PDA(ID_PHOTO_PDA,ID_INTERVENTION,PHOTO_PDA,COMMENTAIRE_PHOTO_PDA,EXTENSION,ITERATION) VALUES(?,?,?,?,?,?)");

            ps.set(1, getUniqueId());
            ps.set(2, idInter);
            ps.set(4, toBinary(commentaire));
            ps.set(5, toBinary(extension));
            ps.set(6, iteration);

            OutputStream os = ps.getBlobOutputStream(3);

            try {
                writeImgWithEXIF(file, os);
//                writeImgWithEXIFOOM(file, os);
            } catch (OutOfMemoryError ofMemoryError) {
                writeImgWithEXIFOOM(file, os);
            } catch (Exception e) {
                Logger.log(TAG, "Error ocurred while saving image");
            }

            os.close();
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (ULjException e) {
            Logger.printException(e);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Writes images to the db after resizing the bitmap & also preserving the EXIF datas after compressing.
     *
     * @param file
     * @param os
     * @throws IOException
     */
    private synchronized void writeImgWithEXIF(String file, OutputStream os) throws IOException {
        FileInputStream fis = new FileInputStream(file);
        // byte[] data = new byte[1024];
        Bitmap bm = BitmapFactory.decodeStream(fis);

        /** New changes */

        File capturedFile = new File(file);
        int rotate = 0;

        try {
            ExifInterface exif = new ExifInterface(
                    capturedFile.getAbsolutePath());
            int orientation = exif.getAttributeInt(
                    ExifInterface.TAG_ORIENTATION,
                    ExifInterface.ORIENTATION_NORMAL);

            switch (orientation) {
                case ExifInterface.ORIENTATION_ROTATE_270:
                    rotate = 270;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_180:
                    rotate = 180;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_90:
                    rotate = 90;
                    break;
            }
        } catch (Exception e) {
            Logger.printException(e);
        }

        /** New changes */
        int resisingWidth;
        int resisingHeight;
        int maxResolution = 1024;
        int imgWidth = bm.getWidth();
        int imgHeight = bm.getHeight();
        if (imgWidth > 1024 || imgHeight > 1024) {
            float imgRatio = (float) imgWidth / imgHeight;

            if (imgRatio > 1) {
                resisingWidth = maxResolution;
                resisingHeight = (int) (resisingWidth / imgRatio);
            } else {
                resisingHeight = maxResolution;
                resisingWidth = (int) (resisingHeight * imgRatio);
            }
        } else {
            resisingWidth = imgWidth;
            resisingHeight = imgHeight;
        }

        /** new changes */
//        //To preserve the EXIF data (lat, long & date) we need to save the compressed image in sd card and then get the image from the path.
        Bitmap bm2 = resizeBitmap(bm, resisingWidth, resisingHeight, rotate); //resizing bitmap

        //save the compressed image in external storage
        File file1 = getTempImgFile();
        FileOutputStream fff = new FileOutputStream(file1);
        bm2.compress(Bitmap.CompressFormat.JPEG, 100, fff);
        fff.close();

        //copy exif from the original image and save it into compressed image
//        ExifData.copyExif(capturedFile.getAbsolutePath(), file1.getAbsolutePath());

        //Instead of compressing the image to save, here we write the image as byte array to prevent the EXIF data loss.
        FileInputStream fis1 = new FileInputStream(file1.getAbsolutePath());
        byte[] data = new byte[1024];
        for (int readNum; (readNum = fis1.read(data)) != -1; ) {
            os.write(data, 0, readNum);
        }

        fis1.close();
        fis.close();
    }

    /**
     * Writes images to the db after resizing the bitmap when we get out of memory exception
     * & also preserving the EXIF datas after compressing.
     *
     * @param file
     * @param os
     * @throws IOException
     */
    private synchronized void writeImgWithEXIFOOM(String file, OutputStream os) throws IOException {


        /** Get the rotation value */

        File capturedFile = new File(file);
        int rotate = 0;
        try {
            ExifInterface exif = new ExifInterface(
                    capturedFile.getAbsolutePath());
            int orientation = exif.getAttributeInt(
                    ExifInterface.TAG_ORIENTATION,
                    ExifInterface.ORIENTATION_NORMAL);

            switch (orientation) {
                case ExifInterface.ORIENTATION_ROTATE_270:
                    rotate = 270;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_180:
                    rotate = 180;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_90:
                    rotate = 90;
                    break;
            }
        } catch (Exception e) {
            Logger.printException(e);
        }

        Bitmap bm2 = decodeFile(capturedFile);
        try {
            //save the compressed image in external storage
            File file1 = getTempImgFile();
            FileOutputStream fff = new FileOutputStream(file1);
            bm2.compress(Bitmap.CompressFormat.JPEG, 70, fff);
            fff.close();


            //Instead of compressing the image to save, here we write the image as byte array to prevent the EXIF data loss.
            FileInputStream fis1 = new FileInputStream(file1.getAbsolutePath());
            byte[] data = new byte[(int) file1.length()];
            for (int readNum; (readNum = fis1.read(data)) != -1; ) {
                os.write(data, 0, readNum);
            }
            fis1.close();


        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    private Bitmap decodeFile(File f) {

        Bitmap smallBitmap = null;

        //Decode image size
        BitmapFactory.Options o = new BitmapFactory.Options();
        o.inJustDecodeBounds = true;

        FileInputStream fis = null;
        try {
            fis = new FileInputStream(f);
            BitmapFactory.decodeStream(fis, null, o);
            fis.close();

            int scale = calculateInSampleSize(o, 500, 500);

            //Decode with inSampleSize
            BitmapFactory.Options o2 = new BitmapFactory.Options();
            o2.inSampleSize = scale;
            o2.inJustDecodeBounds = false;
            fis = new FileInputStream(f);
            smallBitmap = BitmapFactory.decodeStream(fis, null, o2);
            fis.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return smallBitmap;
    }

    /**
     * Create a File for saving an image or video.
     *
     * @return the output media file
     */
    private synchronized File getTempImgFile() {
        // To be safe, you should check that the SDCard is mounted
        // using Environment.getExternalStorageState() before doing this.

        //old code
//        File mediaStorageDir = new File(
//                Environment
//                        .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
//                "MyCameraApp");

        //new changes
        File mediaStorageDir = new File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),
                "MyCameraApp");

        // Create the storage directory if it does not exist
        if (!mediaStorageDir.exists()) {
            if (!mediaStorageDir.mkdirs()) {
                return null;
            }
        }

        File mediaFile;
        mediaFile = new File(mediaStorageDir.getPath() + File.separator
                + "TempImg" + ".jpg");

        return mediaFile;
    }

    /**
     * Insert signature.
     *
     * @param idPhoto     the id photo
     * @param idInter     the id inter
     * @param file        the file
     * @param commentaire the commentaire
     * @param extension   the extension
     */
    public synchronized void insertSignature(String idPhoto, String idInter, String file,
                                             String commentaire, String extension, int iteration) {
        PreparedStatement ps = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT ID_PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION= '"
                    + idInter
                    + "' AND COMMENTAIRE_PHOTO_PDA ='"
                    + commentaire
                    + "' AND DT_SUPPR is NULL"
                    + " AND ITERATION =" + iteration;
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next())

                executeDDL("DELETE FROM T_PHOTOS_PDA WHERE ID_INTERVENTION= '"
                        + idInter + "' AND COMMENTAIRE_PHOTO_PDA ='"
                        + commentaire + "'" + " AND ITERATION =" + iteration);

            ps = getConnectionObj()
                    .prepareStatement("INSERT INTO T_PHOTOS_PDA(ID_PHOTO_PDA,ID_INTERVENTION,PHOTO_PDA,COMMENTAIRE_PHOTO_PDA,EXTENSION,ITERATION) VALUES(?,?,?,?,?,?)");

            ps.set(1, getUniqueId());
            ps.set(2, idInter);
            ps.set(4, toBinary(commentaire));
            ps.set(5, toBinary(extension));
            ps.set(6, iteration);

            FileInputStream fis = new FileInputStream(file);
            byte[] data = new byte[1024];
            OutputStream os = ps.getBlobOutputStream(3);

            for (int readNum; (readNum = fis.read(data)) != -1; ) {
                os.write(data, 0, readNum);
            }
            fis.close();
            os.close();
            ps.execute();
//            ps.close();
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (ULjException e) {
            Logger.printException(e);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Gets the photo by id.
     *
     * @param idInter the id inter
     * @param cmt     the cmt
     * @return the photo by id
     */
    public synchronized byte[] getPhotoById(String idInter, String cmt) {
        String sql_string = "SELECT PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                + idInter + "' AND COMMENTAIRE_PHOTO_PDA='" + cmt + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        byte[] res = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                res = cursor.getBytes(1);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            res = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return res;
    }

    /**
     * Gets the photo by id with iteration for child views in report.
     *
     * @param idInter the id inter
     * @param cmt     the cmt
     * @return the photo by id
     */
    public synchronized byte[] getPhotoById(String idInter, String cmt, int iteration) {
        String sql_string = "SELECT PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                + idInter + "' AND COMMENTAIRE_PHOTO_PDA='" + cmt + "'"
                + " AND ITERATION = " + iteration;

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        byte[] res = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                res = cursor.getBytes(1);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            res = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return res;
    }

    /**
     * Modifier photo by id.
     *
     * @param idPhoto the id photo
     * @param cmt     the cmt
     */
    public synchronized void modifierPhotoById(String idPhoto, String cmt) {
        PreparedStatement ps = null;
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PHOTOS_PDA SET COMMENTAIRE_PHOTO_PDA = ? WHERE ID_PHOTO_PDA = ?");
            ps.set(1, toBinary(cmt));
            ps.set(2, idPhoto);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Delete photo.
     *
     * @param idPhoto the id photo
     */
    public synchronized void deletePhoto(String idPhoto) {
        executeDDL("DELETE FROM T_PHOTOS_PDA WHERE ID_PHOTO_PDA = '" + idPhoto
                + "'");
    }


    /**
     * Gets the acces.
     *
     * @return the acces
     */
    public synchronized GestionAcces getAcces() {
        //v52.0.0
        String sql = "SELECT FL_OPTION_TRACKING," +
                "FL_OPTION_HELPSURFING,"
                + "FL_REPLANIFE_INTERV," +
                "FL_DECLINER_INTERV,"
                + "FL_COMMENTS_REPORT, "
                + "FL_MANDATORY_DESCRIPTION, " +
                "FL_FORCE_REPORT_TEMPLATE, "
                + "FL_PAGE_SITES, " +
                "FL_CREATE_UPDATE_INVOICE_QUOTATION, "
                + "FL_MOB_PRICE, " +
                "FL_LIST_CUSTOMERS, "
                + "FL_SECTION_STOCK, " +
                "FL_SECTION_DELSIGN, " +
                "FL_STOCK_TAKEFROM, " +
                "FL_STOCK_SENDTO, " +
                "FL_STOCK_REQUESTFROM," +
                "FL_SIGN_TECH," +
                "FL_SIGN_CUST,NUM_DECIMALS,FL_INV_STRICT " +
                "FROM TREF_GESTION_ACCES";
//        String sql = "SELECT FL_OPTION_TRACKING," + "FL_OPTION_HELPSURFING,"
//                + "FL_REPLANIFE_INTERV," + "FL_DECLINER_INTERV,"
//                + "FL_COMMENTS_REPORT, "
//                + "FL_MANDATORY_DESCRIPTION, FL_FORCE_REPORT_TEMPLATE, "
//                + "FL_PAGE_SITES, " + "FL_CREATE_UPDATE_INVOICE_QUOTATION, "
//                + "FL_MOB_PRICE, " + "FL_LIST_CUSTOMERS, "
//                + "FL_SECTION_STOCK, " + "FL_SECTION_DELSIGN, " +
//                "FL_STOCK_TAKEFROM, " +
//                "FL_STOCK_SENDTO, " +
//                "FL_STOCK_REQUESTFROM " + "FROM TREF_GESTION_ACCES";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        GestionAcces acces = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                acces = new GestionAcces();
                acces.setOptionTaracking(cursor.getInt(1));
                acces.setOptionHelpSurfing(cursor.getInt(2));
                acces.setOptionReplanif(cursor.getInt(3));
                acces.setOptionReject(cursor.getInt(4));
                acces.setFlCommentsRapport(cursor.getInt(5));
                acces.setFlMandatoryDescription(cursor.getInt(6));
                acces.setFlForceReportTemplate(cursor.getInt(7));
                acces.setFlPageSites(cursor.getInt(8));
                acces.setFlCreateUpdateInvoiceQuotation(cursor.getInt(9));
                acces.setFlMobPrice(cursor.getInt(10));
                acces.setFlListCustomers(cursor.getInt(11));
                acces.setFlSectionStock(cursor.getInt(12));
                acces.setFlSectionDelSign(cursor.getInt(13));
                acces.setFlTakeFrom(cursor.getInt(14));
                acces.setFlSendTo(cursor.getInt(15));
                acces.setFlRequestFrom(cursor.getInt(16));
                acces.setFlagSignTech(cursor.getInt(17));
                acces.setFlagSignCust(cursor.getInt(18));
                acces.setNumDecimals(cursor.getInt(19));
                acces.setFlInvoiceStrict(cursor.getBoolean(20));
//                acces = new GestionAcces(cursor.getInt(1),
//                        cursor.getInt(2), cursor.getInt(3), cursor.getInt(4),
//                        cursor.getInt(5), cursor.getInt(6), cursor.getInt(7),
//                        cursor.getInt(8), cursor.getInt(9), cursor.getInt(10),
//                        cursor.getInt(11), cursor.getInt(12), cursor.getInt(13)
//                        , cursor.getInt(14), cursor.getInt(15), cursor.getInt(16),
//                        cursor.getInt(17), cursor.getInt(18));
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else
                acces = null;
        } catch (Exception e) {
            acces = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return acces;
    }


    //v52.0.0 new method
    public synchronized GestionAcces getAccesSignFlag() {
        String sql = "SELECT FL_OPTION_TRACKING," + "FL_OPTION_HELPSURFING,"
                + "FL_REPLANIFE_INTERV," + "FL_DECLINER_INTERV,"
                + "FL_COMMENTS_REPORT, "
                + "FL_MANDATORY_DESCRIPTION, FL_FORCE_REPORT_TEMPLATE, "
                + "FL_PAGE_SITES, " + "FL_CREATE_UPDATE_INVOICE_QUOTATION, "
                + "FL_MOB_PRICE, " + "FL_LIST_CUSTOMERS, "
                + "FL_SECTION_STOCK, " + "FL_SECTION_DELSIGN, " +
                "FL_STOCK_TAKEFROM, " +
                "FL_STOCK_SENDTO, " +
                "FL_STOCK_REQUESTFROM,FL_SIGN_TECH,FL_SIGN_CUST,NUM_DECIMALS " + "FROM TREF_GESTION_ACCES";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        GestionAcces acces = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                acces = new GestionAcces(cursor.getInt(1),
                        cursor.getInt(2), cursor.getInt(3), cursor.getInt(4),
                        cursor.getInt(5), cursor.getInt(6), cursor.getInt(7),
                        cursor.getInt(8), cursor.getInt(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12), cursor.getInt(13)
                        , cursor.getInt(14), cursor.getInt(15), cursor.getInt(16), cursor.getInt(19));
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else
                acces = null;
        } catch (Exception e) {
            acces = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return acces;
    }

    /**
     * Sets the sign client.
     *
     * @param idInterv      the id interv
     * @param nomSignClient the nom sign client
     */
    public synchronized void setSignClient(String idInterv, String nomSignClient) {
        String sql = "";
        try {
            sql = "UPDATE T_INTERVENTIONS SET NM_CLIENT_SIGN =";
            if (nomSignClient.equals(""))
                sql += "NULL";
            else
                sql += "'" + nomSignClient + "'";

            sql += " WHERE ID_INTERVENTION='" + idInterv + "'";

            executeDDL(sql);
        } catch (Exception e) {
            Logger.printException(e);
        }

    }

    public synchronized String getSignClient(String idInterv) {
        // ArrayList<Client> listClt = new ArrayList<Client>();
        String signClient = null;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            // PreparedStatement preparedStatement = connDao
            // .prepareStatement("SELECT NM_CLIENT_SIGN FROM T_INTERVENTIONS");
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT NM_CLIENT_SIGN FROM T_INTERVENTIONS WHERE ID_INTERVENTION='"
                            + idInterv + "'");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                signClient = encodeString(cursor.getBytes(1));

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return signClient;
    }

    /**
     * Sets the sign user.
     *
     * @param idInterv    the id interv
     * @param nomSignUser the nom sign user
     */
    public synchronized void setSignUser(String idInterv, String nomSignUser) {
        String sql = "";
        try {
            sql = "UPDATE T_INTERVENTIONS SET NM_TECH_SIGN=";
            if (nomSignUser.equals(""))
                sql += "NULL";
            else
                sql += "'" + nomSignUser + "'";

            sql += " WHERE ID_INTERVENTION='" + idInterv + "'";

            executeDDL(sql);
        } catch (Exception e) {
            Logger.printException(e);
        }

    }

    public synchronized String getSignUser(String idInterv) {
        // ArrayList<Client> listClt = new ArrayList<Client>();
        String signUser = null;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            // PreparedStatement preparedStatement = connDao
            // .prepareStatement("SELECT NM_TECH_SIGN FROM T_INTERVENTIONS");
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj()
                    .prepareStatement("SELECT NM_TECH_SIGN FROM T_INTERVENTIONS WHERE ID_INTERVENTION='"
                            + idInterv + "'");
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                signUser = encodeString(cursor.getBytes(1));

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return signUser;
    }


    /**
     * Update liste operation.
     *
     * @param idInterv the id interv
     * @param optDesc  the opt desc
     * @param fl       the fl
     */
    public synchronized void updateListeOperation(String idInterv, String optDesc, int fl) {
        PreparedStatement ps;
        try {

            ps = connDao
                    .prepareStatement("UPDATE TDALKIA_LISTE_OPERATIONS SET FL_DONE=? WHERE OPERATION_DESCRIPTION =? AND ID_INTERVENTION=? ");

            ps.set(1, fl);
            ps.set(2, toBinary(optDesc));
            ps.set(3, toBinary(idInterv));
            ps.execute();
            ps.close();
            connDao.commit();

        } catch (Exception ex) {
            Logger.printException(ex);
        }
    }


    /**
     * Gets the custom fields.
     *
     * @param idInterv the id interv
     * @param idClient the id client
     * @param idSite   the id site
     * @param idEquip  the id equip
     * @return the custom fields
     */
    public synchronized Vector<CustomFieldsByVal> getCustomFields(String idInterv,
                                                                  int idClient, int idSite, int idEquip) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NM_CUSTOMS_FIELD,"
                    + " T_VAL_CUSTOM_FIELDS.ID_ELEMENT_CONCERNE, T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NUM_ORDER "
                    + " FROM TREF_CUSTOM_FIELDS LEFT JOIN T_VAL_CUSTOM_FIELDS "
                    + " ON T_VAL_CUSTOM_FIELDS.ID_CUSTOM_FIELD=TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD "
                    + " WHERE ( (TREF_CUSTOM_FIELDS.NM_TABLE='T_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idClient
                    + "') OR "
                    + " (TREF_CUSTOM_FIELDS.NM_TABLE='T_SITES_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idSite
                    + "') OR"
                    + " (TREF_CUSTOM_FIELDS.NM_TABLE='T_EQUIPEMENTS_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idEquip
                    + "') OR "
                    + " (TREF_CUSTOM_FIELDS.NM_TABLE='T_INTERVENTIONS' AND ID_ELEMENT_CONCERNE='"
                    + idInterv
                    + "'))"
                    + " AND TREF_CUSTOM_FIELDS.DT_SUPPR IS NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD <> '' AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD IS NOT NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.DT_SUPPR IS NULL ";
            // ORDER BY TREF_CUSTOM_FIELDS.NM_TABLE,
            // TREF_CUSTOM_FIELDS.NUM_ORDER ";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)), cursor.getInt(6));
                CustomFields.add(listCustomFields);

            }

            Collections.sort(CustomFields);

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;
    }

    /**
     * Sets the id push android.
     *
     * @param idPush the new id push android
     */
    public synchronized void setIdPushAndroid(String idPush) {
        int idUser = getUserID();
        PreparedStatement ps = null;
        Logger.log(TAG, "ID_PUSH_ANDROID value is ===>" + idPush);
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_USERS SET ID_PUSH_ANDROID=? , ID_PUSH_IOS=? WHERE ID_USER = " + idUser);
            ps.set(1, idPush);
            ps.setNull(2);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception ex) {
            Logger.printException(ex);
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Gets the all dat interv date.
     *
     * @return the all dat interv date
     */
    @SuppressLint("UseSparseArrays")

    /**
     * Sets the fis notify.
     */
    public synchronized void setFisNotify() {

        try {

            executeDDL("UPDATE TDALKIA_BT_FIS SET statutFIS='Rec' WHERE FIS_No IS NOT NULL AND (statutFIS IS NULL OR statutFIS='N')");

        } catch (Exception exc) {
            Logger.printException(exc);
        }
    }


    /**
     * Sets the deny fis.
     *
     * @param idInterv the id interv
     * @param code     the code
     * @param desc     the desc
     */
    public void setDenyFis(String idInterv, String code, String desc) {

        PreparedStatement ps;

        try {

            String sql = "UPDATE TDALKIA_BT_FIS SET statutFIS='Ref', DateRefus=CURRENT TIMESTAMP,Reject_Cause=? , "
                    + "DescRefus=? ,DT_MODIF=CURRENT TIMESTAMP WHERE ID_INTERVENTION=?";
            ps = connDao.prepareStatement(sql);
            ps.set(1, code);
            ps.set(2, desc);
            ps.set(3, idInterv);
            ps.execute();
            ps.close();
            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);

        }
    }

    /**
     * Sets the accept fis.
     *
     * @param idInterv the new accept fis
     */
    public void setAcceptFis(String idInterv) {

        try {

            executeDDL("UPDATE TDALKIA_BT_FIS SET statutFIS='A', DT_MODIF=CURRENT TIMESTAMP WHERE ID_INTERVENTION='"
                    + idInterv + "'");
        } catch (Exception exc) {
            Logger.printException(exc);
        }
    }

    /**
     * Gets the nbre bt.
     *
     * @return the nbre bt
     */
    public int getNbreBt() {
        String sql_string = "SELECT count(*) FROM TDALKIA_BT_FIS, T_INTERVENTIONS where FIS_No is null AND "
                + "T_INTERVENTIONS.ID_INTERVENTION = TDALKIA_BT_FIS.ID_INTERVENTION AND CD_STATUT_INTERV < 5 AND TDALKIA_BT_FIS.DT_SUPPR is NULL AND (ID_INTERVENTION_MERE is null or ID_INTERVENTION_MERE ='' or "
                + "ID_INTERVENTION_MERE IN ( SELECT TDALKIA_BT_FIS.ID_INTERVENTION from TDALKIA_BT_FIS where FIS_No is Not null and statutFIS = 'A' AND DT_SUPPR is NULL))";
        PreparedStatement stmt;
        ResultSet cursor;
        try {
            stmt = connDao.prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            cursor.next();
            int res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return res;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * Gets the nbre bt started.
     *
     * @param idMere the id mere
     * @return the nbre bt started
     */
    public int getNbreBtStarted(String idMere) {
        int res = 0;
        try {
            PreparedStatement stmt = connDao
                    .prepareStatement("SELECT count(*) FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV < 3 AND ID_INTERVENTION_MERE ='"
                            + idMere + "'");
            ResultSet cursor = stmt.executeQuery();
            cursor.next();
            res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return res;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }
    }

    /**
     * Gets the nbre interv started.
     *
     * @param idMere the id mere
     * @return the nbre interv started
     */
    public int getNbreIntervStarted(String idMere) {
        int res = 0;
        try {
            PreparedStatement stmt = connDao
                    .prepareStatement("SELECT count(*) FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV > 2 AND ID_INTERVENTION ='"
                            + idMere + "'");
            ResultSet cursor = stmt.executeQuery();
            cursor.next();
            res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return res;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }
    }

    /**
     * Gets the list refus.
     *
     * @return the list refus
     */
    public Map<String, String> getListRefus() {
        HashMap<String, String> hashtable = new HashMap<String, String>();

        try {

            String query = " SELECT CODE_REFUS, DESCIPTION_REFUS FROM TDALKIA_REFUS WHERE DT_SUPPR IS NULL";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {

                hashtable.put(cursor.getString(1), cursor.getString(2));

            }
            // hashtable.put(null, "(None)");
            cursor.close();
            stmt.close();
            connDao.commit();
            return hashtable;
        } catch (Exception exc) {
            Logger.printException(exc);
            return null;
        }
    }

    /**
     * Gets the search description.
     *
     * @param idelement the idelement
     * @return the search description
     */
    public String getSearchDescription(String idelement) {
        String searchDesc = "";
        String nmCustField = "search description";
        try {

            if (getUserDomain().equals("dalkia-cz"))
                nmCustField = "Adresa zařízení";
            String query = "SELECT VAL_CUSTOM_FIELD FROM T_VAL_CUSTOM_FIELDS where ID_ELEMENT_CONCERNE = '"
                    + idelement
                    + "' AND "
                    + " ID_CUSTOM_FIELD IN (select ID_CUSTOM_FIELD FROM TREF_CUSTOM_FIELDS where NM_TABLE='T_SITES_CLIENTS' AND NM_CUSTOMS_FIELD ='"
                    + nmCustField + "' AND DT_SUPPR is null) ";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                searchDesc = cursor.getString(1);

            }
            cursor.close();
            stmt.close();
            connDao.commit();
            if (searchDesc != null)
                return searchDesc;
            else
                return "";
        } catch (Exception exc) {
            Logger.printException(exc);
            if (searchDesc != null)
                return searchDesc;
            else
                return "";
        }
    }

    /**
     * Duplication.
     *
     * @param idInterv the id interv
     * @param dateDeb  the date deb
     * @param dateFin  the date fin
     * @return true, if successful
     */
    public synchronized boolean duplication(String idInterv, String dateDeb, String dateFin,
                                            String dMeeting, ArrayList<Photo_Pda> photo_Pdas,
                                            String idJobCreated) {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
        String s1 = sdf1.format(System.currentTimeMillis());

        int u = getUser().getId();
        String uniqueId = idJobCreated;
        String idUser = String.valueOf(u);
        int idCustomer = getIdCustomer();

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        String query;
        try {

            query = "SELECT "
                    + "ID_TYPE_INTERVENTION ,"
                    + "ID_CLIENT ,"
                    +
                    // "ID_USER ,"+
                    "DESCR_INTERVENTION ,"
                    + "PRIORITE_INTERVENTION ,"
                    +
                    // "DT_DEB_PREV ,"+
                    // "DT_FIN_PREV ,"+
                    // "DT_DEB_REAL ,"+
                    // "DT_FIN_REAL ,"+
                    "ADR_INTERV_RUE ,"
                    + "ADR_INTERV_CP ,"
                    + "ADR_INTERV_VILLE ,"
                    + "ADR_INTERV_PAYS ,"
                    + "GPS_POSX_INTERV ,"
                    + "GPS_POSY_INTERV ,"
                    + "SIGN_CLIENT ,"
                    + "SIGN_USER ,"
                    + "TXT_COMMENTAIRE_INTERV ,"
                    + "CD_STATUT_INTERV ,"
                    + "ID_USER_VALIDATION ,"
                    + "DT_VALIDATION ,"
                    +
                    // "DT_MODIF ,"+
                    // "DT_SUPPR ,"+
                    "NOM_CLIENT_INTERV ," + "ID_MODELE_RAPPORT ,"
                    + "REF_CUSTOMER ," + "ID_SITE ," + "ID_EQUIPEMENT ,"
                    + "NOM_CONTACT ," + "PRENOM_CONTACT ," + "TEL_CONTACT ,"
                    + "NOM_SITE_INTERV ,"
                    + "NOM_EQUIPEMENT_INTERV ,"
                    + "ADR_INTERV_GLOBALE ,"
                    + "ADR_INTERV_COMPLEMENT ,"
                    + "NO_INT_CUST ,"
                    +
                    // "ID_USER_LAST_MODIF ,"+
                    "NM_CLIENT_SIGN ," + "NM_TECH_SIGN ," + "NM_FACTURE_SIGN ,"
                    + "MOBILE_CONTACT ,"
                    + "DT_MEETING ,"
                    + "ID_INTERVENTION_MERE ,"
                    + "ADR_INTERV_PROVINCE, "
                    + "EMAIL_CONTACT  "
                    + " FROM T_INTERVENTIONS WHERE ID_INTERVENTION ='"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    PreparedStatement ps;
//                         // extra in duplicate
//                          + "NO_INT_CUST ,"
//                          + "NM_CLIENT_SIGN ,"
//                          + "NM_TECH_SIGN ,"
//                          + "NM_FACTURE_SIGN ,"
//                          + "ID_INTERVENTION_MERE ,"

//                           //missing in duplicate
//                            + "EMAIL_CONTACT, "


                    String queryInsert = "INSERT INTO T_INTERVENTIONS ("
                            + "ID_INTERVENTION,"
                            + "ID_CUSTOMER,"
                            + "ID_TYPE_INTERVENTION ,"
                            + "ID_CLIENT ,"
                            + "ID_USER ,"
                            + "DESCR_INTERVENTION ,"
                            + "PRIORITE_INTERVENTION ,"
                            + "DT_DEB_PREV ,"
                            + "DT_FIN_PREV ,"
                            + "DT_DEB_REAL ,"
                            + "DT_FIN_REAL ,"
                            + "ADR_INTERV_RUE ,"
                            + "ADR_INTERV_CP ,"
                            + "ADR_INTERV_VILLE ,"
                            + "ADR_INTERV_PAYS ,"
                            + "GPS_POSX_INTERV ,"
                            + "GPS_POSY_INTERV ,"
                            + "SIGN_CLIENT ,"
                            + "SIGN_USER ,"
                            + "TXT_COMMENTAIRE_INTERV ,"
                            + "CD_STATUT_INTERV ,"
                            + "ID_USER_VALIDATION ,"
                            + "DT_VALIDATION ,"
                            + "DT_MODIF ,"
                            + "DT_SUPPR ,"
                            + "NOM_CLIENT_INTERV ,"
                            + "ID_MODELE_RAPPORT ,"
                            + "REF_CUSTOMER ,"
                            + "ID_SITE ,"
                            + "ID_EQUIPEMENT ,"
                            + "NOM_CONTACT ,"
                            + "PRENOM_CONTACT ,"
                            + "TEL_CONTACT ,"
                            + "NOM_SITE_INTERV ,"
                            + "NOM_EQUIPEMENT_INTERV ,"
                            + "ADR_INTERV_GLOBALE ,"
                            + "ADR_INTERV_COMPLEMENT ,"
                            + "NO_INT_CUST ,"
                            + "ID_USER_LAST_MODIF ,"
                            + "NM_CLIENT_SIGN ,"
                            + "NM_TECH_SIGN ,"
                            + "NM_FACTURE_SIGN ,"
                            + "MOBILE_CONTACT ,"
                            + "DT_MEETING ,"
                            + "ID_INTERVENTION_MERE ,"
                            + "ADR_INTERV_PROVINCE,EMAIL_CONTACT ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?" +
                            ",?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?, ?,?,?,?,?,?)";

                    Logger.log("TAG", "DULICATON QUERY IS ===>" + queryInsert);
                    ps = getConnectionObj()
                            .prepareStatement(queryInsert);

                    ps.set(1, uniqueId);
                    ps.set(2, idCustomer);

                    ps.set(3, cursor.getString(1));
                    int idClient = cursor.getInt(2);
                    if (idClient == 0)
                        ps.setNull(4);
                    else
                        ps.set(4, idClient);

                    Logger.log("TAG", "USER ID VALUE IS ===>" + idUser);
                    ps.set(5, idUser);
                    ps.set(6, cursor.getString(3));
                    ps.set(7, cursor.getString(4));
                    ps.set(8, dateDeb);
                    ps.set(9, dateFin);
                    ps.setNull(10);
                    ps.setNull(11);

                    ps.set(12, cursor.getString(5));
                    ps.set(13, cursor.getString(6));
                    ps.set(14, cursor.getString(7));
                    ps.set(15, cursor.getString(8));
                    ps.set(16, cursor.getString(9));
                    ps.set(17, cursor.getString(10));
                    ps.set(18, cursor.getString(11));
                    ps.set(19, cursor.getString(12));
                    ps.set(20, cursor.getString(13));
                    if (dateDeb == null && dateFin == null) {
                        ps.set(21, 0);
                    } else {
                        //new changes set cdStatus to 2
                        ps.set(21, 2);
                    }
                    ps.set(22, cursor.getString(15));
                    String dtValidation = cursor.getString(16);
                    if (TextUtils.isEmpty(dtValidation))
                        ps.setNull(23); // DT_VALIDATION
                    else
                        ps.set(23, dtValidation);

                    ps.set(24, s + ":00.000"); //
                    ps.setNull(25); //

                    ps.set(26, cursor.getString(17));
                    ps.set(27, cursor.getString(18));
                    ps.set(28, cursor.getString(19));
                    ps.set(29, cursor.getString(20));
                    ps.set(30, cursor.getString(21));
                    ps.set(31, cursor.getString(22));
                    ps.set(32, cursor.getString(23));
                    ps.set(33, cursor.getString(24));
                    ps.set(34, cursor.getString(25));
                    ps.set(35, cursor.getString(26));
                    ps.set(36, cursor.getString(27));
                    ps.set(37, cursor.getString(28));

                    ps.set(38, cursor.getString(29)); //

                    ps.set(39, u);// user
                    ps.set(40, cursor.getString(30));
                    ps.set(41, cursor.getString(31));
                    ps.set(42, cursor.getString(32));
                    ps.set(43, cursor.getString(33));

                    // String dtMeeting = cursor.getString(33);
                    if (TextUtils.isEmpty(dMeeting))
                        ps.setNull(44); // DT_MEETING
                    else
                        ps.set(44, dMeeting);

                    ps.set(45, cursor.getString(34));

                    if (cursor.getString(36) != null)
                        ps.set(46, cursor.getString(36));

                    if (cursor.getString(37) != null)
                        ps.set(47, cursor.getString(37));

                    ps.execute();
                    ps.close();
                    //connection.commit();
                    connDao.commit();
                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            for (Photo_Pda photo_Pda : photo_Pdas) {
                PreparedStatement psPhoto = null;
                try {
                    psPhoto = getConnectionObj()
                            .prepareStatement("INSERT INTO T_PHOTOS_PDA(ID_PHOTO_PDA,ID_INTERVENTION,PHOTO_PDA,COMMENTAIRE_PHOTO_PDA,EXTENSION) VALUES(?,?,?,?,?)");

                    psPhoto.set(1, getUniqueId());
                    psPhoto.set(2, uniqueId);
                    psPhoto.set(4, toBinary(photo_Pda.getCommentaire()));
                    psPhoto.set(5, toBinary(photo_Pda.getExtention()));

                    OutputStream os = psPhoto.getBlobOutputStream(3);

                    String filePath = photo_Pda.getFilePath();
                    if (filePath != null) {
                        try {
                            writeImgWithEXIF(filePath, os);
//                            writeImgWithEXIFOOM(filePath, os);
                        } catch (OutOfMemoryError ofMemoryError) {
                            writeImgWithEXIFOOM(filePath, os);
                        } catch (Exception e) {
                            Logger.log(TAG, "Error ocurred while saving image");
                        }
                    } else {
                        os.write(photo_Pda.getPhoto());
                    }

//                    Bitmap bitmap = BitmapFactory.decodeByteArray(
//                            photo_Pda.getPhoto(), 0,
//                            photo_Pda.getPhoto().length);
//
//                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);

                    // for (int readNum; (readNum = fis.read(data)) != -1;)
                    // {
                    // os.write(data, 0, readNum);
                    // }

                    os.close();
                    psPhoto.execute();
//                    psPhoto.close();

                    //connection.commit();
//                    connDao.commit();

                } catch (ULjException e) {
                    Logger.printException(e);
                } catch (Exception e) {
                    Logger.printException(e);
                } finally {
                    if (psPhoto != null) {
                        try {
                            psPhoto.close();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        connDao.commit();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

            }
            //connection.release();
            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }

    /**
     * Gets the id interv status.
     *
     * @param idInterv the id interv
     * @param idUser   the id user
     * @return the id interv status
     */
    public synchronized String getIdIntervStatus(String idInterv, int idUser) {

        String sql = "SELECT ID_INTERVENTION FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV = 3 AND ID_INTERVENTION <> '"
                + idInterv + "' AND DT_SUPPR IS NULL AND ID_USER = " + idUser;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String result = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                result = encodeString(cursor.getBytes(1));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
//            return null;
        } catch (Exception e) {
            result = null;
//            return null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Gets the id intervention exit.
     *
     * @param interventionId the intervention id
     * @param userId         the user id
     * @return the id intervention exit
     */
    public boolean getIdInterventionExit(String interventionId, int userId) {

        String sql = "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE CD_STATUT_INTERV = 3 AND ID_INTERVENTION = '"
                + interventionId + "' AND ID_USER = " + userId;

        try {
            PreparedStatement stmt = connDao.prepareStatement(sql);
            ResultSet cursor = stmt.executeQuery();

            if (cursor.next()) {
                cursor.close();
                stmt.close();
                connDao.commit();
                return true;
            } else {
                cursor.close();
                stmt.close();
                connDao.commit();
                return false;

            }
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            return false;
        }
    }

    /**
     * Checks if an line is already inserted of null value with DT_FIN and
     * DT_RETOUR, not null value with DT_DEPART and DT_DEBUT.
     *
     * @param interventionId the intervention id
     * @param userId         the user id
     * @return the id intervention exit
     */
    public synchronized boolean getValueForTempInterv(String interventionId, int userId) {

        String sql = "SELECT DT_DEPART,DT_DEBUT,DT_FIN,DT_RETOUR FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '"
                + interventionId + "' AND ID_USER = " + userId;

        String dateDepart = null;
        String dateDebut = null;
        String dateFin = null;
        String dateRetour = null;
        boolean result = false;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dateDepart = cursor.getString(1);
                dateDebut = cursor.getString(2);
                dateFin = cursor.getString(3);
                dateRetour = cursor.getString(4);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            if (!TextUtils.isEmpty(dateDepart) && !TextUtils.isEmpty(dateDebut)
                    && TextUtils.isEmpty(dateFin)
                    && TextUtils.isEmpty(dateRetour)) {
                result = true;
            } else {
                result = false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            result = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * Gets the all st.
     *
     * @param gpsX the gps x
     * @param gpsY the gps y
     * @return the all st
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<HashMap<String, String>> getAllSt(String gpsX, String gpsY) {

        ArrayList<HashMap<String, String>> nrObject = new ArrayList<HashMap<String, String>>();
        HashMap<String, String> map;
//        String sql = "Select TOP 10 ID,"
//                + " NOM, "
//                + "ObjectType,"
//                + "radians(Latitude) as lat1, "
//                + "radians(LatIssy) as lat2, "
//                + "radians(Longitude) as long1, "
//                + "radians(LongIssy) as long2, "
//                + "6366 * 2 * asin(sqrt(power((sin((lat1 - lat2) / 2)),2)+cos(lat1) * cos(lat2) *(power(sin(((long1-long2)/2)), 2))))AS distanceKm, "
//                + "Latitude, "
//                + "Longitude, "
//                + "AdrGlobale, "
//                + "AdrComplement "
//                + "from ( "
//                + "Select abs(LatIssy - Latitude) + abs(LongIssy - Longitude) AS EloignementApprox  from ( "
//                + "SELECT ID_CLIENT as ID, " + "NM_CLIENT as NOM, "
//                + "'Client' AS ObjectType, "
//                + "CAST(GPS_POSY_CLIENT AS DECIMAL) AS Latitude, "
//                + "CAST(GPS_POSX_CLIENT AS DECIMAL) as Longitude,  " + "CAST('"
//                + gpsX
//                + "' AS DECIMAL) AS LatIssy, "
//                + "CAST('"
//                + gpsY
//                + "' AS DECIMAL) AS LongIssy, "
//                + "ADR_CLIENT_GLOBALE as AdrGlobale, "
//                + "ADR_CLIENT_COMPLEMENT as AdrComplement "
//                + "FROM T_CLIENTS "
//                + "WHERE DT_SUPPR IS NULL  "
//                + "AND GPS_POSX_CLIENT IS NOT NULL AND GPS_POSY_CLIENT IS NOT NULL "
//                + "AND LTRIM(GPS_POSX_CLIENT) !='' AND LTRIM(GPS_POSY_CLIENT) != '' "
//                + "AND LOWER(GPS_POSX_CLIENT) != 'null' AND LOWER(GPS_POSY_CLIENT) !='null' "
//                + "UNION "
//                + "SELECT ID_SITE_CLIENT as ID, "
//                + "NM_SITE as NOM, 'Site' AS ObjectType, "
//                + "CAST(GPS_POSY_SITE AS DECIMAL) AS Latitude, "
//                + "CAST(GPS_POSX_SITE AS DECIMAL) as Longitude,  "
//                + "CAST('"
//                + gpsX
//                + "' AS DECIMAL) AS LatIssy, "
//                + "CAST('"
//                + gpsY
//                + "' AS DECIMAL) AS LongIssy, "
//                + "ADR_SITE_GLOBALE as AdrGlobale, "
//                + "ADR_SITE_COMPLEMENT as AdrComplement "
//                + "FROM T_SITES_CLIENTS "
//                + "WHERE DT_SUPPR IS NULL  "
//                + "AND GPS_POSX_SITE IS NOT NULL AND GPS_POSY_SITE IS NOT NULL "
//                + "AND LTRIM(GPS_POSX_SITE) !='' AND LTRIM(GPS_POSY_SITE) != '' "
//                + "AND LOWER(GPS_POSX_SITE) !='null' AND LOWER(GPS_POSY_SITE) != 'null' "
//                + ") as gpsreference (ID,NOM,ObjectType,Latitude,Longitude,LatIssy,LongIssy,AdrGlobale,AdrComplement) "
//                + ") as top20 (EloignementApprox) " + "Order by distanceKm";

        //new changes with REF_CUSTOMER

        String sql = "Select TOP 10 ID,"
                + " NOM, "
                + "ObjectType,"
                + "radians(Latitude) as lat1, "
                + "radians(LatIssy) as lat2, "
                + "radians(Longitude) as long1, "
                + "radians(LongIssy) as long2, "
                + "6366 * 2 * asin(sqrt(power((sin((lat1 - lat2) / 2)),2)+cos(lat1) * cos(lat2) *(power(sin(((long1-long2)/2)), 2))))AS distanceKm, "
                + "Latitude, "
                + "Longitude, "
                + "AdrGlobale, "
                + "AdrComplement, "
                + "RefCustomer "
                + "from ( "
                + "Select abs(LatIssy - Latitude) + abs(LongIssy - Longitude) AS EloignementApprox  from ( "
                + "SELECT ID_CLIENT as ID, " + "NM_CLIENT as NOM, "
                + "'Client' AS ObjectType, "
                + "CAST(GPS_POSY_CLIENT AS DECIMAL) AS Latitude, "
                + "CAST(GPS_POSX_CLIENT AS DECIMAL) as Longitude,  " + "CAST('"
                + gpsX
                + "' AS DECIMAL) AS LatIssy, "
                + "CAST('"
                + gpsY
                + "' AS DECIMAL) AS LongIssy, "
                + "ADR_CLIENT_GLOBALE as AdrGlobale, "
                + "ADR_CLIENT_COMPLEMENT as AdrComplement, "
                + "REF_CUSTOMER as RefCustomer "
                + "FROM T_CLIENTS "
                + "WHERE DT_SUPPR IS NULL  "
                + "AND GPS_POSX_CLIENT IS NOT NULL AND GPS_POSY_CLIENT IS NOT NULL "
                + "AND LTRIM(GPS_POSX_CLIENT) !='' AND LTRIM(GPS_POSY_CLIENT) != '' "
                + "AND LOWER(GPS_POSX_CLIENT) != 'null' AND LOWER(GPS_POSY_CLIENT) !='null' "
                + "UNION "
                + "SELECT ID_SITE_CLIENT as ID, "
                + "NM_SITE as NOM, 'Site' AS ObjectType, "
                + "CAST(GPS_POSY_SITE AS DECIMAL) AS Latitude, "
                + "CAST(GPS_POSX_SITE AS DECIMAL) as Longitude,  "
                + "CAST('"
                + gpsX
                + "' AS DECIMAL) AS LatIssy, "
                + "CAST('"
                + gpsY
                + "' AS DECIMAL) AS LongIssy, "
                + "ADR_SITE_GLOBALE as AdrGlobale, "
                + "ADR_SITE_COMPLEMENT as AdrComplement, "
                + "REF_CUSTOMER as RefCustomer "
                + "FROM T_SITES_CLIENTS "
                + "WHERE DT_SUPPR IS NULL  "
                + "AND GPS_POSX_SITE IS NOT NULL AND GPS_POSY_SITE IS NOT NULL "
                + "AND LTRIM(GPS_POSX_SITE) !='' AND LTRIM(GPS_POSY_SITE) != '' "
                + "AND LOWER(GPS_POSX_SITE) !='null' AND LOWER(GPS_POSY_SITE) != 'null' "
                + ") as gpsreference (ID,NOM,ObjectType,Latitude,Longitude,LatIssy,LongIssy,AdrGlobale,AdrComplement,RefCustomer) "
                + ") as top20 (EloignementApprox) " + "Order by distanceKm";

        Logger.output(TAG, sql);
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                map = new HashMap<String, String>();
                map.put("id", cursor.getString(1));
                map.put("nom", encodeString(cursor.getBytes(2)));
                map.put("ObjectType", encodeString(cursor.getBytes(3)));
                map.put("distanceKm", cursor.getString(8));
                map.put("Latitude", cursor.getString(9));
                map.put("Longitude", cursor.getString(10));
                map.put("AdrGlobale", cursor.getString(11));
                map.put("AdrComplement", cursor.getString(12));
                map.put("RefCustomer",encodeString(cursor.getBytes(13)));

                Log.e("RefCustomer","RefCustomer is>>>>>"+encodeString(cursor.getBytes(13)));

                if (map.get("ObjectType").equals("Site")) {

                    Client ct = getClientsBySite(cursor.getInt(1));
                    if(String.valueOf(ct.getRef_customer()).length()>0){
                        map.put("nmClient", String.valueOf(ct.getNmClient())+" ("+String.valueOf(ct.getRef_customer())+")");
                    }else {
                        map.put("nmClient", String.valueOf(ct.getNmClient()));
                    }
                    map.put("IdClient", String.valueOf(ct.getIdClient()));

                    if (ct.getIdClient() != 0)
                        nrObject.add(map);

                } else {

                    int clientId = cursor.getInt(1);
                    map.put("nmClient", encodeString(cursor.getBytes(2))+" ("+encodeString(cursor.getBytes(13))+")");
                    map.put("IdClient", String.valueOf(clientId));
                    nrObject.add(map);
                }

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


//        cursor.close();
//        stmt.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        return nrObject;
    }

    /**
     * Gets the clients by site.
     *
     * @param idSite the id site
     * @return the clients by site
     */
    public synchronized Client getClientsBySite(int idSite) {
        Client listClt = new Client();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT,REF_CUSTOMER "
                            + "FROM T_CLIENTS WHERE T_CLIENTS.ID_CLIENT IN( SELECT ID_CLIENT FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT ="
                            + idSite + ")");
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                listClt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)));

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
//            return listClt;
        } catch (Exception e) {
            Logger.printException(e);
            listClt = new Client();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listClt;
    }

    /*
     * public Client getClientsBySites(int idSite) { Client listClt = new
     * Client(); try { ResultSet cursor = connDao .prepareStatement(
     * "SELECT ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT "
     * + "FROM T_CLIENTS WHERE T_CLIENTS.ID_CLIENT =" + idSite ).executeQuery();
     * while (cursor.next()) { listClt = new Client(cursor.getInt(1),
     * encodeString(cursor.getBytes(2)), encodeString(cursor.getBytes(3)),
     * encodeString(cursor.getBytes(4)), encodeString(cursor.getBytes(5)),
     * encodeString(cursor.getBytes(6)), encodeString(cursor.getBytes(7)),
     * encodeString(cursor.getBytes(8)));
     *
     * } cursor.close(); connDao.commit(); return listClt; } catch (Exception e)
     * { Logger.printException(e); return listClt; } }
     */

    /**
     * Gets the job start time.
     *
     * @param idIntervention the id intervention
     * @return the job start time
     */
    public synchronized String getJobStartTime(String idIntervention) {
        String jobStartStopTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_DEBUT FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                try {

                    jobStartStopTime = getDateWithRequiredPresettedPattern(
                            resultSet.getString(1), currentDateFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
            }
//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobStartStopTime;
    }

    /**
     * Gets the job suspended time.
     *
     * @param idIntervention the id intervention
     * @return the job suspended time
     */
    public synchronized String getJobSuspendedTime(String idIntervention) {
        String jobSuspendedTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT MAX(DT_FIN) FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    jobSuspendedTime = getDateWithRequiredPresettedPattern(
                            resultSet.getString(1), currentDateFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
            }
//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobSuspendedTime;
    }

    /**
     * Gets the job resumed time in job details.
     *
     * @param idIntervention the id intervention
     * @return the job resumed time in job details
     */
    public synchronized String getJobResumedTimeInJobDetails(String idIntervention) {
        String jobSuspendedTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_DEBUT FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                try {

                    jobSuspendedTime = resultSet.getString(1);

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }
//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobSuspendedTime;
    }

    /**
     * Gets the date with requiredpattern for calander.
     *
     * @param date                the date
     * @param datePattern         the date pattern
     * @param requiredDatePattern the required date pattern
     * @return the date with requiredpattern for calander
     * @throws ParseException the parse exception
     */
    private synchronized String getDateWithRequiredpatternForCalander(String date,
                                                                      String datePattern, String requiredDatePattern)
            throws ParseException {
        String requiredDate = null;

        SimpleDateFormat formatter = new SimpleDateFormat(datePattern, Locale.US);
        Date requestDate = formatter.parse(date);
        // System.out.println("ActualDate" + requestDate.toLocaleString());

        SimpleDateFormat requiredFormatter = new SimpleDateFormat(
                requiredDatePattern, Locale.US);
        requiredDate = requiredFormatter.format(requestDate);

        // System.out.println("requiredDate" + requiredDate);

        return requiredDate;
    }

    /**
     * Gets the date with required pattern.
     *
     * @param date        the date
     * @param datePattern the date pattern
     * @return requiredDate
     * @throws ParseException the parse exception
     */

    public String getDateWithRequiredPresettedPattern(String date,
                                                      String datePattern) throws ParseException {
        String requiredDate = "";
        if (!TextUtils.isEmpty(date)) {
            SimpleDateFormat formatter = new SimpleDateFormat(datePattern, Locale.US);
            Date requestDate = formatter.parse(date);
            // System.out.println("ActualDate" + requestDate.toLocaleString());

            DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
            requiredDate = dateFormat.format(requestDate);
            Format format = android.text.format.DateFormat
                    .getTimeFormat(context);
            requiredDate = requiredDate + "/" + format.format(requestDate);
            // System.out.println("requiredDate" + requiredDate);
        }
        return requiredDate;
    }

    /**
     * Gets the date with required pattern.
     *
     * @param date the date
     * @return requiredDate
     * @throws ParseException the parse exception
     */

    public String getDateWithRequiredPresettedPattern(Date date)
            throws ParseException {
        String requiredDate = "";

        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG, Locale.US);
        requiredDate = dateFormat.format(date);
        Format format = android.text.format.DateFormat.getTimeFormat(context);
        requiredDate = requiredDate + "/" + format.format(date);
        // System.out.println("requiredDate" + requiredDate);

        return requiredDate;
    }

    /**
     * Gets the header date with required pattern.
     *
     * @param date                the date
     * @param datePattern         the date pattern
     * @param requiredDatePattern the required date pattern
     * @return the header date with required pattern
     * @throws ParseException the parse exception
     */

    private String getHeaderDateWithRequiredPattern(String date,
                                                    String datePattern, String requiredDatePattern)
            throws ParseException {
        String requiredDate = null;

        SimpleDateFormat formatter = new SimpleDateFormat(datePattern, Locale.US);
        Date requestDate = formatter.parse(date);
        // System.out.println("ActualDate" + requestDate.toLocaleString());

        SimpleDateFormat requiredFormatter = new SimpleDateFormat(
                requiredDatePattern, Locale.US);
        requiredDate = requiredFormatter.format(requestDate);
        //

        return requiredDate;
    }

    /**
     * Gets the date with required pattern.
     *
     * @param date        the date
     * @param datePattern the date pattern
     * @return requiredDate
     * @throws ParseException the parse exception
     */

    private String getReportDateWithDevicePreset(String date, String datePattern)
            throws ParseException {
        String requiredDate = null;

        SimpleDateFormat formatter = new SimpleDateFormat(datePattern, Locale.US);
        Date requestDate = formatter.parse(date);
        // System.out.println("ActualDate" + requestDate.toLocaleString());

        // SimpleDateFormat requiredFormatter = new SimpleDateFormat(
        // requiredDatePattern);
        // requiredDate = requiredFormatter.format(requestDate);
        Format format = android.text.format.DateFormat.getDateFormat(context);
        requiredDate = format.format(requestDate);
        System.out.println("requiredDate" + requiredDate);

        return requiredDate;
    }

    /**
     * Gets the report time with device preset.
     *
     * @param date        the date
     * @param datePattern the date pattern
     * @return the report time with device preset
     * @throws ParseException the parse exception
     */
    private String getReportTimeWithDevicePreset(String date, String datePattern)
            throws ParseException {
        String requiredDate = null;

        SimpleDateFormat formatter = new SimpleDateFormat(datePattern, Locale.US);
        Date requestDate = formatter.parse(date);
        // System.out.println("ActualDate" + requestDate.toLocaleString());

        // SimpleDateFormat requiredFormatter = new SimpleDateFormat(
        // requiredDatePattern);
        // requiredDate = requiredFormatter.format(requestDate);
        Format format = android.text.format.DateFormat.getTimeFormat(context);
        requiredDate = format.format(requestDate);
        // System.out.println("requiredDate" + requiredDate);

        return requiredDate;
    }

    /**
     * Gets the dedline exceeded jobs count.
     *
     * @param userId the user id
     * @return the dedline exceeded jobs count
     */
    public synchronized int getDedlineExceededJobsCount(int userId) {

//        String query = "SELECT COUNT(ID_INTERVENTION) "
////                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
//                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
//                + "WHERE "
//                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
////                + "AND "
////                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
//                + "AND (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
//                + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "";

        int idCustomer = getIdCustomer();
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION WHERE " +
//                "T_INTERVENTIONS.ID_CUSTOMER =" + idCustomer
//                + " AND " +
                "T_INTERVENTIONS.DT_SUPPR IS NULL AND (" +
                "(T_INTERVENTIONS.CD_STATUT_INTERV in (4) AND " +
                "T_INTERVENTIONS.DT_DEB_REAL < CURRENT TIMESTAMP) OR " +
                "(T_INTERVENTIONS.CD_STATUT_INTERV in(1,2) AND " +
                "T_INTERVENTIONS.DT_FIN_PREV < CURRENT TIMESTAMP)) AND " +
                "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();

            count = count + resultSet.getInt(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        query = "SELECT COUNT(ID_INTERVENTION) "
//                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND "
                + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4 ";
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();

            count = count + resultSet.getInt(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT COUNT(ID_INTERVENTION) "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND " + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND date(DT_DEB_REAL) < CURRENT DATE";


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            ResultSet resultSet1 = null;
            try {
                while (cursor.next()) {
                    preparedStatement = getConnectionObj().prepareStatement(query);
                    resultSet1 = preparedStatement.executeQuery();
                    resultSet1.first();

                    count = count + resultSet1.getInt(1);

//                     resultSet1.close();
//                     preparedStatement.close();
                    //connection.commit();
//                     connDao.commit();
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (resultSet1 != null) {
                    try {
                        resultSet1.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (preparedStatement != null) {
                    try {
                        preparedStatement.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }

    /**
     * Gets the dedline exceeded jobs count.
     *
     * @return the dedline exceeded jobs count
     */
    public synchronized int getLateJobCount(int userId) {

        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION WHERE " +
                "T_INTERVENTIONS.DT_SUPPR IS NULL AND (" +
                "(T_INTERVENTIONS.CD_STATUT_INTERV in (4) AND " +
                "T_INTERVENTIONS.DT_DEB_REAL < CURRENT TIMESTAMP) OR " +
                "(T_INTERVENTIONS.CD_STATUT_INTERV in(1,2) AND " +
                "T_INTERVENTIONS.DT_FIN_PREV < CURRENT TIMESTAMP)) AND " +
                "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION";


        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            preparedStatement = connDao.prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

            resultSet.close();
            preparedStatement.close();
//            connDao.commit();

        } catch (Exception e) {
            Logger.printException(e);
            count = 0;
        }
        return count;
    }

    /**
     * Gets the dedline exceeded jobs count.
     *
     * @return the dedline exceeded jobs count
     */
    public synchronized String getReportsCount() {
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                + "AND CD_STATUT_INTERV ='5'";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            preparedStatement = connDao.prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

            resultSet.close();
            preparedStatement.close();
//            connDao.commit();
        } catch (Exception e) {
            Logger.printException(e);
            count = 0;
        }

        return count + "";
    }

    /**
     * Gets the dedline exceeded jobs count.
     *
     * @return the dedline exceeded jobs count
     */
    public synchronized String getReportsCountNew(String finalDate) {
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND (DATEFORMAT(DT_FIN_REAL,'yyyy-mm-dd') >='"
                + finalDate + "')";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

            resultSet.close();

            preparedStatement.close();

//            connDao.commit();

        } catch (Exception e) {

            Logger.printException(e);
            count = 0;
        }

        return count + "";
    }

    /**
     * Gets the to come job count.
     *
     * @return the to come job count
     */
    public synchronized String getToComeJobCount() {
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        String count = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();
            count = resultSet.getString(1);

            resultSet.close();
            preparedStatement.close();
//            connDao.commit();

        } catch (Exception e) {
            Logger.printException(e);
        }

        return count;
    }


    /**
     * Gets the to  job pool count.
     *
     * @return the to  job pool count
     */
    public synchronized String getToJobPoolCount() {
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                + "AND T_INTERVENTIONS.FL_POOL=1 AND CD_STATUT_INTERV = 0";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        String count = "0";
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();
            count = resultSet.getString(1);

            resultSet.close();
            preparedStatement.close();

//            connDao.commit();

        } catch (Exception e) {
            Logger.printException(e);
            count = "0";
        }

        return count;
    }

    /**
     * Suspended time diffrence.
     *
     * @param jobId the job id
     * @return the long
     */
    public synchronized long suspendedTimeDiffrence(String jobId) {
        long jobSuspendedTime = 0;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int countValue = getTempsCount(jobId);
        try {

//            query =  "SELECT DT_FIN,DT_DEBUT  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
//                    + jobId + "' ORDER BY DT_DEBUT DESC EXCEPT " +
//                    "SELECT TOP 1 DT_FIN,DT_DEBUT FROM T_TEMPS_INTERV ";

            query = "SELECT DT_FIN,DT_DEBUT  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
                    + jobId + "' ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    if (!TextUtils.isEmpty(resultSet.getString(1))) {
                        jobSuspendedTime = jobSuspendedTime
                                + getJobSuspendTime(resultSet.getString(1),
                                resultSet.getString(2));
                    }

                } catch (Exception e) {
                    Logger.log("TAG", "" + e);
                }
            }
//            resultSet.close();

//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return jobSuspendedTime;

    }

    /**
     * Gets the job suspend time.
     *
     * @param dtFin    the dt fin
     * @param dt_debut the dt_debut
     * @return the job suspend time
     */
    public synchronized long getJobSuspendTime(String dtFin, String dt_debut) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss", Locale.US);
        long timeinterval = 0;
        try {
            long dtFinMiliseconds = dateFormat.parse(dtFin).getTime();
            long dtDebutMiliSeconds = dateFormat.parse(dt_debut).getTime();

            timeinterval = dtFinMiliseconds - dtDebutMiliSeconds;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }

        return timeinterval;

    }

    /**
     * Clean list item.
     *
     * @param map the map
     * @return the vector
     */
    public synchronized Vector<Item> cleanListItem(HashMap<Integer, Item> map) {
        Vector<Item> vect = new Vector<Item>();

        int drp = 0;

        Iterator<Item> iter = map.values().iterator();
        while (iter.hasNext()) {
            Item item1 = new Item(), item2, item3;
            item1 = iter.next();

            if (item1.getCond() == 0)
                vect.add(item1);
            else {
                item2 = new Item(item1.getCond(), item1.getVal_cond(),
                        item1.getValeurNet());
                item2.setIdTypeItem(item1.getIdTypeItem());
                while (item2.getCond() != 0) {

                    item3 = map.get(item2.getCond());

                    if (item2.getVal_cond().equals(item3.getValeurNet())
                            && item3.getIdTypeItem() != 5) {
                        item2 = new Item(item3.getCond(), item3.getVal_cond(),
                                item3.getValeurNet());
                        drp = 1;
                    } else if (item3.getIdTypeItem() == 5) {

                        String op = item2.getVal_cond().substring(0, 1);
                        String valCond = item2.getVal_cond().substring(1);

                        if (item3.getValeurNet().equals("")) {
                            drp = 0;
                            item2.setCond(0);
                        } else if (op.equals("=")
                                && Float.parseFloat(valCond) == Float
                                .parseFloat(item3.getValeurNet())) {

                            item2 = new Item(item3.getCond(),
                                    item3.getVal_cond(), item3.getValeurNet());
                            drp = 1;

                        } else if (op.equals("<")
                                && Float.parseFloat(valCond) > Float
                                .parseFloat(item3.getValeurNet())) {
                            item2 = new Item(item3.getCond(),
                                    item3.getVal_cond(), item3.getValeurNet());
                            drp = 1;
                        } else if (op.equals(">")
                                && Float.parseFloat(valCond) < Float
                                .parseFloat(item3.getValeurNet())) {
                            item2 = new Item(item3.getCond(),
                                    item3.getVal_cond(), item3.getValeurNet());
                            drp = 1;
                        } else {
                            drp = 0;
                            item2.setCond(0);
                        }

                    } else {
                        drp = 0;
                        item2.setCond(0);
                    }
                }
                if (drp == 1) {
                    vect.add(item1);
                    drp = 0;
                }
            }

        }
        Collections.sort(vect);
        return vect;
    }

    /**
     * Gets the all categories of job.
     *
     * @param idModel        the id model
     * @param idIntervention the id intervention
     * @return the all categories of job
     */
    public synchronized ArrayList<ReportsItems> getAllCategoriesOfJob(int idModel,
                                                                      String idIntervention, int iteration, String dtCreated) {

        ArrayList<ReportsItems> tmp = new ArrayList<ReportsItems>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT ID_MODELE_FAMILLE,NM_MODELE_FAMILLE FROM TREF_MODELE_FAMILLE WHERE ID_MODELE_RAPPORT="
                    + idModel + " ORDER BY TRIE_CONDITION_FAMILLE ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                ReportsCategoryItem fm = new ReportsCategoryItem(
                        cursor.getString(2), cursor.getInt(1));

                HashMap<Integer, Item> items = this.getAllItem(idIntervention,
                        cursor.getInt(1), iteration);

                tmp.add(fm);

                Vector<Item> vectorItem = cleanListItem(items);
                tmp.addAll(vectorItem);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return tmp;

    }

    /**
     * Gets the all intervention now.
     *
     * @param id_intervention the id_intervention
     * @return the all intervention now
     */
    public synchronized ReportsStartAndEndTime getStartAndEndDateForJob(
            String id_intervention) {
        ReportsStartAndEndTime reportsStartAndEndTime = null;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            // query="SELECT * FROM T_INTERVENTIONS WHERE (dateformat(dt_deb_prev,'yy-mm-dd')='"+currentDate+"')";

            // System.out.println(query);
            query = "SELECT DT_DEB_REAL,DT_FIN_REAL" + " FROM T_INTERVENTIONS"
                    + " WHERE " + "ID_INTERVENTION='" + id_intervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                String startDate = null;
                String endDate = null;
                String endTime = null;
                String startTime = null;
                try {
                    startDate = getReportDateWithDevicePreset(
                            cursor.getString(1), currentDateFormat);
                    endDate = getReportDateWithDevicePreset(
                            cursor.getString(2), currentDateFormat);
                    endTime = getReportTimeWithDevicePreset(
                            cursor.getString(2), currentDateFormat);
                    startTime = getReportTimeWithDevicePreset(
                            cursor.getString(1), currentDateFormat);

                    reportsStartAndEndTime = new ReportsStartAndEndTime(
                            startDate, endDate, startTime, endTime);
                } catch (Exception e) {
                    Logger.printException(e);
                }

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return reportsStartAndEndTime;
    }

    /**
     * Gets the all dates.
     *
     * @return the all dates
     */
    public synchronized ArrayList<Date> getAllDates() {

        ArrayList<Date> dates = new ArrayList<Date>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String maxDate = null;
            String minDate = null;
            String maxQuery = "SELECT "
                    + "MAX(DT_DEB_PREV),MIN(DT_DEB_PREV)"
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION ";
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT ";
            //Connection connection = getConnectionObj();
            if (getConnectionObj() == null) {
                return dates;
            }
            stmt = getConnectionObj().prepareStatement(maxQuery);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                maxDate = cursor.getString(1);
                minDate = cursor.getString(2);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            if (!TextUtils.isEmpty(maxDate) && !TextUtils.isEmpty(minDate)) {

                dates = getDates(minDate, maxDate);

            } else {
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                        currentDateFormat, Locale.US);

                dates = getDates(simpleDateFormat.format(new Date()),
                        simpleDateFormat.format(new Date()));
            }

        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return dates;

    }

    /**
     * Gets the dates.
     *
     * @param dateString1 the date string1
     * @param dateString2 the date string2
     * @return the dates
     */
    private synchronized ArrayList<Date> getDates(String dateString1, String dateString2) {
        ArrayList<Date> dates = new ArrayList<Date>();
        DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd", Locale.US);

        Date minimumDate = null;
        Date maxDate = null;
        Interval interval = null;
        try {
            minimumDate = df1.parse(dateString1);
            maxDate = df1.parse(dateString2);
            interval = new Interval(minimumDate.getTime(), maxDate.getTime());

            Logger.log("standard days>>>>>>", interval.toDuration()
                    .getStandardDays() + "");
        } catch (ParseException e) {
            Logger.printException(e);
        }

        Calendar cal1 = Calendar.getInstance();
        Date currentDate = new Date(System.currentTimeMillis());

        if (interval != null) {

            if ((interval.toDuration().getStandardDays()) > context
                    .getResources().getInteger(R.integer.maxDaysWeekRibbon)) {

                maxDate = currentDate;
                minimumDate = currentDate;

            }
        }

        try {
            int i = maxDate.compareTo(df1.parse(df1.format(currentDate)));
            if (i < 0) {
                maxDate = df1.parse(df1.format(currentDate));
            }

        } catch (ParseException e) {
            Logger.printException(e);
        }

        try {
            int i = minimumDate.compareTo(df1.parse(df1.format(currentDate)));
            if (i > 0) {
                minimumDate = df1.parse(df1.format(currentDate));
            }

        } catch (ParseException e) {
            Logger.printException(e);
        }

        cal1.setTime(minimumDate);

        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(maxDate);

        while (!cal1.after(cal2)) {
            dates.add(cal1.getTime());
            cal1.add(Calendar.DATE, 1);
        }

        for (int i = 0; i < 10; i++) {
            Date min = dates.get(0);
            cal1.setTime(min);
            cal1.add(Calendar.DATE, -1);
            dates.add(0, cal1.getTime());

        }

        for (int i = 0; i < 10; i++) {

            Date max = dates.get(dates.size() - 1);
            cal1.setTime(max);
            cal1.add(Calendar.DATE, 1);
            dates.add(cal1.getTime());

        }

        return dates;
    }

    // public String getTSessionNoSyncId(){
    //
    // String query = "SELECT ID"
    // + " FROM T_INTERVENTIONS"
    // + " WHERE "
    // + "ID_INTERVENTION='"+id_intervention+"'";
    //
    // PreparedStatement stmt = connDao.prepareStatement(query);
    //
    // ResultSet cursor = stmt.executeQuery();
    //
    // while (cursor.next()) {
    //
    // String startDate = null;
    // String endDate = null;
    // String endTime=null;
    // String startTime=null;
    // try {
    // startDate = getDateWithRequiredPattern(cursor.getString(1),
    // currentDateFormat, requiredDateFormatReportsDetail);
    // endDate = getDateWithRequiredPattern(cursor.getString(2),
    // currentDateFormat, requiredDateFormatReportsDetail);
    // endTime=getDateWithRequiredPattern(cursor.getString(2),
    // currentDateFormat, requiredTimeFormatReportsDetail);
    // startTime=getDateWithRequiredPattern(cursor.getString(1),
    // currentDateFormat, requiredTimeFormatReportsDetail);
    //
    // reportsStartAndEndTime = new ReportsStartAndEndTime(
    // startDate, endDate,startTime,endTime);
    // } catch (Exception e) {
    // e.printStackTrace();
    // }
    //
    // }
    // cursor.close();
    // stmt.close();
    // } catch (Exception exc) {
    // exc.printStackTrace();
    // }

    // }

    public synchronized String dateConversions(String date) {

        String outputText = null;

        if (TextUtils.isEmpty(date)) {
            return null;
        }
        try {

            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);

            Date d = sdf.parse(date);

            SimpleDateFormat outputFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
            outputText = outputFormat.format(d);
        } catch (ParseException e) {

            outputText = null;
            Logger.printException(e);
        } catch (NullPointerException e) {

            outputText = null;
            Logger.printException(e);
        } catch (IllegalArgumentException e) {

            outputText = null;
            Logger.printException(e);
        }
        return outputText;

    }

    public synchronized int getSuspendedJobCount(String date, int userId) {

        int SUSPENDEDJOBCOUNT = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getSuspendedJobId = "SELECT ID_INTERVENTION FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
//                    "TREF_MODELE_RAPPORT " +
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + date + "'))";
            //Connection connection = getConnectionObj();
            try {
                stmt = getConnectionObj().prepareStatement(getSuspendedJobId);
                cursor = stmt.executeQuery();

                int suspendedJobCount = 0;
                while (cursor.next()) {

                    boolean jobSuspendedStatusonCurrentDate = checkJobSuspendedStatus(
                            date, encodeString(cursor.getBytes(1)));
                    if (jobSuspendedStatusonCurrentDate) {
                        suspendedJobCount++;
                    }

                }
                SUSPENDEDJOBCOUNT = suspendedJobCount;
            } catch (Exception exc) {
                Logger.printException(exc);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();

            String getSuspendedJobCount = "SELECT  "
                    + "count(*)"
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='" + date
                    + "'";

            stmt = getConnectionObj().prepareStatement(getSuspendedJobCount);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                SUSPENDEDJOBCOUNT = SUSPENDEDJOBCOUNT
                        + Integer.parseInt(cursor.getString(1));

            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return SUSPENDEDJOBCOUNT;

    }

    public synchronized int getStartedJobCount(String date, int userId, String currentDate) {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);

        int startedJobCount = 0;

        if (currentDate.equals(date)) {
            PreparedStatement stmt = null;
            ResultSet cursor = null;
            try {

                String getStartedJobCount = "SELECT count(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION"
//                        ",TREF_MODELE_RAPPORT " +
                        + " WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT " +
                        + "AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND '"
                        + date
                        + "'=CURRENT DATE AND DT_FIN IS NULL)"
                        + "AND "
                        + "T_INTERVENTIONS.CD_STATUT_INTERV = 3";

                // In the above query "AND " +
                // "T_INTERVENTIONS.CD_STATUT_INTERV = 3" this condition is
                // added for calculate started job count only
                //Connection connection = getConnectionObj();
                stmt = getConnectionObj()
                        .prepareStatement(getStartedJobCount);

                cursor = stmt.executeQuery();
                try {
                    while (cursor.next()) {

                        startedJobCount = Integer.parseInt(cursor.getString(1));

                    }
                } catch (Exception exc) {
                    Logger.printException(exc);
                } finally {
                    if (cursor != null) {
                        try {
                            cursor.close();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    if (stmt != null) {
                        try {
                            stmt.close();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        connDao.commit();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();

                String getStartedAuxillaryJob = "SELECT "
                        + "count(*)"
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                        + "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED;

                stmt = getConnectionObj().prepareStatement(getStartedAuxillaryJob);

                cursor = stmt.executeQuery();

                while (cursor.next()) {
                    startedJobCount = startedJobCount
                            + Integer.parseInt(cursor.getString(1));

                }

//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
            } catch (Exception exc) {
                Logger.printException(exc);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }
        return startedJobCount;

    }

    public synchronized ArrayList<CalendarAllJobBeans> getCountsOfVariousJobForMonth(
            ArrayList<String> mnthList) {

        ArrayList<CalendarAllJobBeans> calendarAllJobBeansList = new ArrayList<CalendarAllJobBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        for (int i = 0; i < mnthList.size(); i++) {

            try {
                String getJobsOfSelectedMonth = "SELECT * FROM T_INTERVENTIONS WHERE "
                        + "(DATEFORMAT(DT_DEB_PREV,'mm') ='"
                        + mnthList.get(i)
                        + "')";
                //Connection connection = getConnectionObj();
                stmt = getConnectionObj()
                        .prepareStatement(getJobsOfSelectedMonth);

                cursor = stmt.executeQuery();

                CalendarAllJobBeans calendarAllJobBeans = null;

                while (cursor.next()) {

                    calendarAllJobBeans = new CalendarAllJobBeans();

                    calendarAllJobBeans.setDT_DEB_PREV(dateConversions(cursor
                            .getString(8)));
                    calendarAllJobBeans.setDT_FIN_PREV(dateConversions(cursor
                            .getString(9)));
                    calendarAllJobBeans.setDT_DEB_REAL(dateConversions(cursor
                            .getString(10)));
                    calendarAllJobBeans.setDT_FIN_REAL(dateConversions(cursor
                            .getString(11)));

                    calendarAllJobBeans.setCD_STATUT_INTERV(cursor.getInt(21));

                    calendarAllJobBeansList.add(calendarAllJobBeans);

                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
            } catch (Exception exc) {
                Logger.printException(exc);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }
        return calendarAllJobBeansList;

    }

    /**
     * Gets the counts of various jobs.
     *
     * @param date   the date
     * @param userId the user id
     * @return the counts of various jobs
     */
    public synchronized JobsCount getCountsOfVariousJobs(String date, int userId) {
        JobsCount jobsCount = new JobsCount();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        // String currentDate = sdf.format(date);
        try {

            String getScheduledJobCount = "SELECT count(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION"
//                    +",TREF_MODELE_RAPPORT"
                    + " WHERE "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND" +
                    + "(DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                    + date
                    + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='"
                    + date
                    + "')  AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))";

            /*
             * +
             * "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
             * + "AND " +
             * "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND (DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') ='"
             * + date + "') AND ((CD_STATUT_INTERV=" +
             * KEYS.CurrentJobs.JOB_NOT_STARTED1 + ") OR (CD_STATUT_INTERV=" +
             * KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))";
             */

            PreparedStatement stmt = connDao
                    .prepareStatement(getScheduledJobCount);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {

                jobsCount
                        .setScheduledJob(Integer.parseInt(cursor.getString(1)));

            }

            cursor.close();
            stmt.close();
            connDao.commit();

            String getStartedJobCount = "SELECT count(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION" +
//                    ",TREF_MODELE_RAPPORT" +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND '"
                    + date + "'=CURRENT DATE AND DT_FIN IS NULL)";

            stmt = connDao.prepareStatement(getStartedJobCount);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                jobsCount.setStartedJob(Integer.parseInt(cursor.getString(1)));
                Log.w("Started Job : ", " " + cursor.getInt(1) + " Date: "
                        + date);

            }
            cursor.close();
            stmt.close();
            connDao.commit();
            String getCompletedJob = "SELECT count(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION"
//                    +",TREF_MODELE_RAPPORT"
                    + " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "(DATEFORMAT(DT_FIN_REAL,'yyyy-mm-dd') ='"
                    + date
                    + "') AND (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__COMPLETE + ")";

            stmt = connDao.prepareStatement(getCompletedJob);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                jobsCount
                        .setCompletedJob(Integer.parseInt(cursor.getString(1)));

            }
            cursor.close();
            stmt.close();
            connDao.commit();
            String getSuspendedJobId = "SELECT ID_INTERVENTION FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION"
//                    ",TREF_MODELE_RAPPORT"
                    + " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + date + "'))";

            stmt = connDao.prepareStatement(getSuspendedJobId);

            cursor = stmt.executeQuery();
            int suspendedJobCount = 0;
            while (cursor.next()) {

                boolean jobSuspendedStatusonCurrentDate = checkJobSuspendedStatus(
                        date, encodeString(cursor.getBytes(1)));
                if (jobSuspendedStatusonCurrentDate) {
                    suspendedJobCount++;
                }

            }
            jobsCount.setSuspendedJob(suspendedJobCount);
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        if (sdf.format(new Date()).equals(date)) {
            try {
                String getStartedAuxillaryJob = "SELECT "
                        + "count(*)"
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                        + "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED;

                PreparedStatement stmt = connDao
                        .prepareStatement(getStartedAuxillaryJob);

                ResultSet cursor = stmt.executeQuery();

                while (cursor.next()) {
                    jobsCount.setStartedJob(jobsCount.getStartedJob()
                            + Integer.parseInt(cursor.getString(1)));

//                    Log.e("Started Job : ", " " + cursor.getInt(1) + " Date: "
//                            + date);

                }
                cursor.close();
                stmt.close();
                connDao.commit();
            } catch (Exception exc) {
                Logger.printException(exc);
            }
        }

        try {
            String getSuspendedJobCount = "SELECT  "
                    + "count(*)"
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='" + date
                    + "'";

            PreparedStatement stmt = connDao
                    .prepareStatement(getSuspendedJobCount);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {
                jobsCount.setSuspendedJob(jobsCount.getSuspendedJob()
                        + Integer.parseInt(cursor.getString(1)));

            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        // Logger.log(
        // "Date And Various Job Count Fetched ",
        // date + "" + jobsCount.getStartedJob() + " "
        // + jobsCount.getScheduledJob() + ""
        // + jobsCount.getCompletedJob() + ""
        // + jobsCount.getSuspendedJob());
        return jobsCount;
    }

    /**
     * Check job suspended status.
     *
     * @param date           the date
     * @param idIntervention the id intervention
     * @return true, if successful
     */
    private synchronized boolean checkJobSuspendedStatus(String date, String idIntervention) {

        boolean jobSuspendedStatusonCurrentDate = false;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getMaxDateSuspendedJob = "SELECT MAX(DT_FIN) FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getMaxDateSuspendedJob);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                String maxSuspendTimeJob = "";
                if (!TextUtils.isEmpty(cursor.getString(1)))
                    try {
                        maxSuspendTimeJob = getDateWithRequiredpatternForCalander(
                                cursor.getString(1), currentDateFormat,
                                requiredSuspendedJobCountCheckFormat);

                        Logger.log("Suspended Job Calander ", date + " "
                                + maxSuspendTimeJob);
                    } catch (ParseException e) {
                        Logger.printException(e);
                        jobSuspendedStatusonCurrentDate = false;
                    }
                if (maxSuspendTimeJob.equals(date)) {
                    jobSuspendedStatusonCurrentDate = true;
                }

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exception) {
            Logger.printException(exception);
            jobSuspendedStatusonCurrentDate = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return jobSuspendedStatusonCurrentDate;
    }

    /**
     * Gets the all intervention before.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention before
     */
    // public Vector<DeadlineJobBean> getAllInterventionBefore() {
    // Vector<DeadlineJobBean> tmp = new Vector<DeadlineJobBean>();
    // String query;
    //
    // try {
    // query = "SELECT "
    // + "ID_INTERVENTION,"
    // + "DESCR_INTERVENTION,"
    // + "PRIORITE_INTERVENTION,"
    // + "DT_DEB_PREV,"
    // + "DT_FIN_PREV,"
    // + "ADR_INTERV_RUE,"
    // + "ADR_INTERV_CP,"
    // + "ADR_INTERV_VILLE,"
    // + "ADR_INTERV_PAYS,"
    // + "CD_STATUT_INTERV,"
    // + "NOM_CLIENT_INTERV,"
    // + "NOM_CONTACT,"
    // + "TEL_CONTACT,"
    // + "NOM_SITE_INTERV, "
    // + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
    // + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
    // + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
    // + "T_INTERVENTIONS.ID_USER,"
    // + "GPS_POSX_INTERV,"
    // + "GPS_POSY_INTERV,"
    // + "ADR_INTERV_GLOBALE,"
    // + "ADR_INTERV_COMPLEMENT,"
    // + "NO_INT_CUST, "
    // + "NM_CLIENT_SIGN ,"
    // + "NM_TECH_SIGN ,"
    // + "NM_FACTURE_SIGN, "
    // + "NOM_EQUIPEMENT_INTERV, "
    // + "ID_CLIENT, "
    // + "ID_SITE, "
    // + "ID_EQUIPEMENT,"
    // + "MOBILE_CONTACT, "
    // + "DT_MEETING, "
    // + "REF_CUSTOMER, "
    // + "ID_INTERVENTION_MERE, "
    // + "DT_DEB_REAL ,"
    // + "DT_FIN_REAL "
    // + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
    // + "WHERE "
    // +
    // "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
    // + "AND "
    // +
    // "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
    // + "AND (date(dt_deb_prev)=)  "
    // +
    // "AND (date(dt_deb_prev) < CURRENT DATE AND( date(DT_DEB_REAL) <> CURRENT DATE or DT_DEB_REAL is null) ) ORDER BY DT_DEB_PREV";
    //
    // PreparedStatement stmt = connDao.prepareStatement(query);
    // String dt_deb_prev = null;
    // ResultSet cursor = stmt.executeQuery();
    // while (cursor.next()) {
    //
    // if (dt_deb_prev == null) {
    // try {
    // dt_deb_prev = getDateWithRequiredPattern(
    // cursor.getString(4), currentDateFormat,
    // dedlineHeaderFormat);
    //
    // Logger.log("Date DEbut if ", dt_deb_prev + "");
    // } catch (ParseException e) {
    // e.printStackTrace();
    // }
    // DeadlineJobBean deadlineJobBean = new DeadlineJobBean(true,
    // dt_deb_prev);
    // tmp.add(deadlineJobBean);
    //
    // } else {
    // String tempDate = "";
    // try {
    // tempDate = getDateWithRequiredPattern(
    // cursor.getString(4), currentDateFormat,
    // dedlineHeaderFormat);
    // } catch (ParseException e) {
    // e.printStackTrace();
    // }
    //
    // if (!dt_deb_prev.equals(tempDate)) {
    // dt_deb_prev = tempDate;
    // DeadlineJobBean deadlineJobBean = new DeadlineJobBean(
    // true, dt_deb_prev);
    // Logger.log("Date DEbut else", dt_deb_prev + "");
    // tmp.add(deadlineJobBean);
    // }
    //
    // }
    //
    // DeadlineJobBean deadlineJobBean = new DeadlineJobBean(
    // encodeString(cursor.getBytes(1)),
    // encodeString(cursor.getBytes(2)), cursor.getInt(3),
    // cursor.getString(4), cursor.getString(5),
    // encodeString(cursor.getBytes(6)),
    // encodeString(cursor.getBytes(7)),
    // encodeString(cursor.getBytes(8)),
    // encodeString(cursor.getBytes(9)), cursor.getInt(10),
    // encodeString(cursor.getBytes(11)),
    // encodeString(cursor.getBytes(12)),
    // encodeString(cursor.getBytes(13)),
    // encodeString(cursor.getBytes(14)),
    // encodeString(cursor.getBytes(15)), cursor.getInt(16),
    // encodeString(cursor.getBytes(17)), cursor.getInt(18),
    // cursor.getString(20), cursor.getString(19),
    // cursor.getString(21), cursor.getString(22),
    // cursor.getInt(23), cursor.getString(24),
    // cursor.getString(25), cursor.getString(26),
    // encodeString(cursor.getBytes(27)), cursor.getInt(28),
    // cursor.getInt(29), cursor.getInt(30),
    // encodeString(cursor.getBytes(31)),
    // cursor.getString(32), cursor.getString(33),
    // cursor.getString(34), false);
    //
    // deadlineJobBean.setDt_deb_real(cursor.getString(35));
    // deadlineJobBean.setDt_fin_real(cursor.getString(36));
    // tmp.add(deadlineJobBean);
    //
    // }
    // cursor.close();
    // stmt.close();
    // } catch (Exception exc) {
    //
    // }
    //
    // return tmp;
    // }
    public synchronized Vector<CommonJobBean> getAllJobsOfParticularDate(String date,
                                                                         int userId) {

        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (DATEFORMAT(DT_FIN_REAL,'yyyy-mm-dd') ='"
                    + date + "') AND (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__COMPLETE + ")";
            String dt_deb_prev = null;
            try {
                stmt = getConnectionObj().prepareStatement(query);

                cursor = stmt.executeQuery();

                while (cursor.next()) {

                    try {
                        // for completed job
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);
//                    Log.e("1st query execute : ", "@@@@@@@@@ ");
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

//                CommonJobBean allJobBean = new CommonJobBean(
//                        encodeString(cursor.getBytes(1)),
//                        encodeString(cursor.getBytes(2)), cursor.getInt(3),
//                        cursor.getString(4), cursor.getString(5),
//                        encodeString(cursor.getBytes(6)),
//                        encodeString(cursor.getBytes(7)),
//                        encodeString(cursor.getBytes(8)),
//                        encodeString(cursor.getBytes(9)), cursor.getInt(10),
//                        encodeString(cursor.getBytes(11)),
//                        encodeString(cursor.getBytes(12)),
//                        encodeString(cursor.getBytes(13)),
//                        encodeString(cursor.getBytes(14)),
//                        encodeString(cursor.getBytes(15)), cursor.getInt(16),
//                        encodeString(cursor.getBytes(17)), cursor.getInt(18),
//                        cursor.getString(20), cursor.getString(19),
//                        cursor.getString(21), cursor.getString(22),
//                        cursor.getInt(23), cursor.getString(24),
//                        cursor.getString(25), cursor.getString(26),
//                        encodeString(cursor.getBytes(27)), cursor.getInt(28),
//                        cursor.getInt(29), cursor.getInt(30),
//                        encodeString(cursor.getBytes(31)),
//                        cursor.getString(32), cursor.getString(33),
//                        cursor.getString(34), dt_deb_prev, cursor.getString(37));

                    CommonJobBean allJobBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            dt_deb_prev,
                            cursor.getString(36));

                    allJobBean.setDt_deb_real(cursor.getString(34));
                    allJobBean.setDt_fin_real(cursor.getString(35));

//                allJobBean.setDt_deb_real(cursor.getString(35));
//                allJobBean.setDt_fin_real(cursor.getString(36));
                    tmp.add(allJobBean);

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <= '"
                    + date + "')"
                    + " AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + date
                    + "')" + " AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    try {
                        // schedules jobs
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);
//                    Log.e("2nd query execute : ", "@@@@@@@@@ ");

                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean allJobBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            dt_deb_prev,
                            cursor.getString(36));

                    allJobBean.setDt_deb_real(cursor.getString(34));
                    allJobBean.setDt_fin_real(cursor.getString(35));
                    tmp.add(allJobBean);

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT  AND "
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                    + date + "')=CURRENT DATE AND DT_FIN IS NULL)" + "AND "
                    + "T_INTERVENTIONS.CD_STATUT_INTERV = 3"
                    + " ORDER BY DT_DEB_PREV";

            // In the above query "AND " +
            // "T_INTERVENTIONS.CD_STATUT_INTERV = 3" this condition is added
            // for calculate started job count only
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    try {
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);
//                    Log.e("3rd query execute : ", "@@@@@@@@@ ");

                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean allJobBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            dt_deb_prev,
                            cursor.getString(36));

                    allJobBean.setDt_deb_real(cursor.getString(34));
                    allJobBean.setDt_fin_real(cursor.getString(35));
                    tmp.add(allJobBean);

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            String getSuspendedJobId = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + date + "'))" + " ORDER BY DT_DEB_PREV";

            try {
                stmt = getConnectionObj().prepareStatement(getSuspendedJobId);

                cursor = stmt.executeQuery();

                while (cursor.next()) {

                    boolean jobSuspendedStatusonCurrentDate = checkJobSuspendedStatus(
                            date, encodeString(cursor.getBytes(1)));
                    if (jobSuspendedStatusonCurrentDate) {
                        try {
                            // suspended jobs
                            dt_deb_prev = getHeaderDateWithRequiredPattern(
                                    cursor.getString(4), currentDateFormat,
                                    dedlineHeaderFormat);

//                        Logger.log("Date DEbut if ", dt_deb_prev + "");
//                        Log.e("4th query execute : ", "@@@@@@@@@ ");

                        } catch (ParseException e) {
                            Logger.printException(e);
                        }

                        CommonJobBean allJobBean = new CommonJobBean(
                                encodeString(cursor.getBytes(1)),
                                encodeString(cursor.getBytes(2)),
                                cursor.getInt(3),
                                cursor.getString(4),
                                cursor.getString(5),
                                encodeString(cursor.getBytes(6)),
                                encodeString(cursor.getBytes(7)),
                                encodeString(cursor.getBytes(8)),
                                encodeString(cursor.getBytes(9)),
                                cursor.getInt(10),
                                encodeString(cursor.getBytes(11)),
                                encodeString(cursor.getBytes(12)),
                                encodeString(cursor.getBytes(13)),
                                encodeString(cursor.getBytes(14)),
                                encodeString(cursor.getBytes(15)),
                                cursor.getInt(16),
                                cursor.getInt(17),
                                cursor.getString(19),
                                cursor.getString(18),
                                cursor.getString(20),
                                cursor.getString(21),
                                cursor.getInt(22),
                                cursor.getString(23),
                                cursor.getString(24),
                                cursor.getString(25),
                                encodeString(cursor.getBytes(26)),
                                cursor.getInt(27),
                                cursor.getInt(28),
                                cursor.getInt(29),
                                encodeString(cursor.getBytes(30)),
                                cursor.getString(31),
                                cursor.getString(32),
                                cursor.getString(33),
                                dt_deb_prev,
                                cursor.getString(36));

                        allJobBean.setDt_deb_real(cursor.getString(34));
                        allJobBean.setDt_fin_real(cursor.getString(35));


                        tmp.add(allJobBean);
                    }

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
        } catch (ULjException exc) {
            Logger.printException(exc);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (sdf.format(new Date()).equals(date)) {
            try {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                        + "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED;

                stmt = getConnectionObj().prepareStatement(query);

                cursor = stmt.executeQuery();
                String headerDate = null;
                while (cursor.next()) {
                    try {
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

//                        Log.e("5th query execute : ", "@@@@@@@@@   " + date);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean currentJobsBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            headerDate,
                            cursor.getString(36));

                    currentJobsBean.setDt_deb_real(cursor.getString(34));
                    currentJobsBean.setDt_fin_real(cursor.getString(35));

                    tmp.add(currentJobsBean);
                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
            } catch (ULjException exc) {
                Logger.printException(exc);
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='" + date
                    + "'";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
//                    Log.e("6th query execute : ", "@@@@@@@@@   ");
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                tmp.add(currentJobsBean);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (ULjException exc) {
            Logger.printException(exc);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Collections.sort(tmp, new Comparator<CommonJobBean>(

        ) {

            @Override
            public int compare(CommonJobBean lhs, CommonJobBean rhs) {
                return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
            }
        });

        // end*********
        return tmp;

    }


    /**
     * Gets the conge.
     *
     * @return the conge
     */
    public synchronized Vector<Conge> getConge() {
        Vector<Conge> Conges = new Vector<Conge>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            //new changes for showing the travel activities along with other activities
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL "
                    + "AND TREF_TYPE_CONGE.FL_CLOCK = 0 "
                    + "ORDER BY DT_DEBUT DESC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String dt_deb_prev = null;
            while (cursor.next()) {
                if (dt_deb_prev == null) {
                    try {
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(3), currentDateFormat,
                                dedlineHeaderFormat);

                        Logger.log("Date DEbut if ", dt_deb_prev + "");
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    // Conge conge = new Conge(true,
                    // dt_deb_prev);
                    // Conges.add(conge);

                } else {
                    String tempDate = "";
                    try {
                        if (cursor.getString(4) != null)
                            tempDate = getHeaderDateWithRequiredPattern(
                                    cursor.getString(4), currentDateFormat,
                                    dedlineHeaderFormat);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    if (!dt_deb_prev.equals(tempDate)) {
                        // dt_deb_prev = tempDate;
                        // Conge conge = new Conge(true,
                        // dt_deb_prev);
                        // Logger.log("Date DEbut else", dt_deb_prev + "");
                        // Conges.add(conge);
                    }
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), "", String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                Conges.add(Conge);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {

            Log.i("--", "" + exc.toString());

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return Conges;
    }

    /**
     * Gets the conge.
     *
     * @return the conge
     */
    public Vector<Conge> getCongeIncludingDriving() {
        Vector<Conge> Conges = new Vector<Conge>();
        String query;

        try {
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL "
                    + "AND TREF_TYPE_CONGE.FL_CLOCK = 0 "
//                  +  "AND TREF_TYPE_CONGE.FL_DRIVING = 0 "
                    + "ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            ResultSet cursor = stmt.executeQuery();
            String dt_deb_prev = null;
            while (cursor.next()) {
                if (dt_deb_prev == null) {
                    try {
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(3), currentDateFormat,
                                dedlineHeaderFormat);

                        Logger.log("Date DEbut if ", dt_deb_prev + "");
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    // Conge conge = new Conge(true,
                    // dt_deb_prev);
                    // Conges.add(conge);

                } else {
                    String tempDate = "";
                    try {
                        if (cursor.getString(4) != null)
                            tempDate = getHeaderDateWithRequiredPattern(
                                    cursor.getString(4), currentDateFormat,
                                    dedlineHeaderFormat);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    if (!dt_deb_prev.equals(tempDate)) {
                        // dt_deb_prev = tempDate;
                        // Conge conge = new Conge(true,
                        // dt_deb_prev);
                        // Logger.log("Date DEbut else", dt_deb_prev + "");
                        // Conges.add(conge);
                    }
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), "", String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                Conges.add(Conge);
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception exc) {

            Log.i("--", "" + exc.toString());

        }

        return Conges;
    }

    /**
     * Gets the unavability counts.
     *
     * @return the unavability counts
     */
    public synchronized int getUnavabilityCounts() {
        int countUnavability = 0;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT COUNT(ID_REMOTE) "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE " +
                    "T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND " +
                    "TREF_TYPE_CONGE.FL_CLOCK = 0 AND " +
                    "T_CONGE.DT_SUPPR IS NULL";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                countUnavability = cursor.getInt(1);

            }
            cursor.close();
            stmt.close();

//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        return countUnavability;
    }

    /**
     * Gets the job duration.
     *
     * @param jobId the job id
     * @return the job duration
     */
    public synchronized Date getJobDuration(String jobId) {

        Date date = null;

        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT " + "T_INTERVENTIONS.ID_TYPE_INTERVENTION"
                    + " FROM T_INTERVENTIONS " + "WHERE ID_INTERVENTION='"
                    + jobId + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            int id_type_interverntion = 0;
            while (cursor.next()) {

                id_type_interverntion = cursor.getInt(1);

            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            query = "SELECT HR_DUREE_INTERVENTION FROM TREF_TYPE_INTERVENTION WHERE ID_TYPE_INTERVENTION="
                    + id_type_interverntion;
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            String hourDuration = null;
            while (cursor.next()) {

                hourDuration = cursor.getString(1);

            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            if (TextUtils.isEmpty(hourDuration)) {
                hourDuration = "02:00";
            }

            try {
                date = jobDurationFormat.parse(hourDuration);

            } catch (ParseException e) {

                Logger.printException(e);

            }

        } catch (Exception exc) {

            Log.i("--", "" + exc.toString());

            String hourDuration = "02:00";
            try {
                date = jobDurationFormat.parse(hourDuration);
            } catch (ParseException e) {
                Logger.printException(e);
            }

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return date;

    }

    /**
     * Gets the item.
     *
     * @param idInterv the id interv
     * @param idItem   the id item
     * @return the item
     */
    @SuppressLint("UseSparseArrays")
//    public Item getItem(String idInterv, int idItem) {
//
//        Item item = new Item();
//        String query;
//        try {
//            query = "SELECT TREF_MODELE_ITEM.ID_MODELE_ITEM,"
//                    + "ID_MODELE_FAMILLE,"
//                    + "ID_TYPE_ITEM,"
//                    + "NM_MODELE_ITEM,"
//                    + "OBLIGATOIRE,"
//                    + "CASE WHEN CONDITIONNE_PAR ='-1' THEN 0 else CONDITIONNE_PAR END,"
//                    + "VALEUR_CONDITION,"
//                    + "CASE WHEN val IS NULL OR val='' THEN 0 ELSE 1 END AS IS_SAISI,"
//                    + "val, "
//                    + "comItem, "
//                    + "TRIE_CONDITION_ITEM, "
//                    + "VALEUR_DEFAUT, "
//                    + "IMAGE, "
//                    + "flReserve "
//                    + "FROM "
//                    + "TREF_MODELE_ITEM LEFT OUTER JOIN "
//                    + "(SELECT ID_MODELE_ITEM,VALEUR_ITEM,COMMENTAIRE_ITEM,FL_RESERVE FROM T_SAISIE_RAPPORT WHERE ID_INTERVENTION='"
//                    + idInterv
//                    + "') AS newTab(idItem,val,comItem,flReserve) ON ( TREF_MODELE_ITEM.ID_MODELE_ITEM=newTab.idItem ) "
//                    + "WHERE ID_MODELE_ITEM=" + idItem
//                    + " ORDER BY NM_MODELE_ITEM ASC";
//            //Connection connection = getConnectionObj();
//            PreparedStatement stmt = getConnectionObj().prepareStatement(query);
//
//            ResultSet cursor = stmt.executeQuery();
//            while (cursor.next()) {
//
//                item = new Item(cursor.getInt(1), cursor.getInt(2),
//                        cursor.getInt(3), encodeString(cursor.getBytes(4)),
//                        cursor.getInt(5), cursor.getInt(6),
//                        encodeString(cursor.getBytes(7)), cursor.getInt(8),
//                        encodeString(cursor.getBytes(9)),
//                        encodeString(cursor.getBytes(10)), cursor.getInt(11),
//                        encodeString(cursor.getBytes(12)), cursor.getBytes(13),
//                        cursor.getInt(14));
//            }
//            cursor.close();
//            stmt.close();
//            //connection.commit();
//            //connection.release();
//        } catch (Exception e) {
//            Logger.printException(e);
//        }
//        return item;
//    }

    // Version 3.3

    /**
     * Update value.
     *
     * @param val       the val
     * @param com       the com
     * @param idItem    the id item
     * @param idInterv  the id interv
     * @param conf      the conf
     * @param flReserve the fl reserve
     */
//    public void updateValue(String val, String com, int idItem,
//                            String idInterv, int conf, int flReserve) {
//
//        String sql = "SELECT COUNT(*) FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM ="
//                + idItem + " AND ID_INTERVENTION = '" + idInterv + "'";
//        ResultSet cursor;
//        //Connection connection = getConnectionObj();
//        try {
//            cursor = getConnectionObj().prepareStatement(sql).executeQuery();
//            cursor.next();
//            int res = cursor.getInt(1);
//
//            if (res != 0 && val != null) {
//
//                if (conf == 1 && Integer.parseInt(val) == 0)
//                    executeDDL("DELETE FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM="
//                            + idItem
//                            + " AND ID_INTERVENTION='"
//                            + idInterv
//                            + "'");
//                else {
//                    PreparedStatement ps;
//                    try {
//                        ps = connection
//                                .prepareStatement("UPDATE T_SAISIE_RAPPORT SET VALEUR_ITEM = ?,COMMENTAIRE_ITEM = ? ,DT_SUPPR=NULL ,FL_RESERVE = ? WHERE ID_MODELE_ITEM = ? AND ID_INTERVENTION = ? ");
//
//                        ps.set(1, toBinary(cutString(val, 512)));
//
//                        if (com != null)
//                            ps.set(2, toBinary(cutString(com, 3072)));
//                        else
//                            ps.setNull(2);
//
//                        ps.set(3, flReserve);
//                        ps.set(4, idItem);
//                        ps.set(5, toBinary(idInterv));
//
//                        ps.execute();
//                        ps.close();
//                        //connection.commit();
//                    } catch (Exception e) {
//                        Logger.printException(e);
//                    }
//                }
//
//            } else {
//                // if (conf != 1 || Integer.parseInt(val) != 0) {
//                PreparedStatement ps;
//                try {
//                    ps = connection
//                            .prepareStatement("INSERT INTO T_SAISIE_RAPPORT VALUES(?,?,?,?,CURRENT TIMESTAMP,NULL,?)");
//
//                    ps.set(1, toBinary(idInterv));
//                    ps.set(2, idItem);
//                    if (val != null)
//                        ps.set(3, toBinary(cutString(val, 512)));
//                    else
//                        ps.setNull(3);
//                    if (com != null)
//                        ps.set(4, toBinary(cutString(com, 3072)));
//                    else
//                        ps.setNull(4);
//                    ps.set(5, flReserve);
//                    ps.execute();
//                    ps.close();
//                    //connection.commit();

//                } catch (Exception e) {
//                    Logger.printException(e);
//                }
//                // }
//            }
//            cursor.close();
//            //connection.release();
//        } catch (Exception e) {
//            Logger.printException(e);
//        }
//    }

    // Version 4.2 Rapport v2

    /**
     * Updates / inserts value to T_SAISIE_RAPPORT
     *
     * @param val
     * @param com
     * @param idItem
     * @param idInterv
     * @param conf
     * @param flReserve
     * @param itemName
     * @param iteration
     */
    public synchronized void updateValue(String val, String com, int idItem,
                                         String idInterv, int conf, int flReserve, String itemName, int
                                                 iteration) {

        String sql = "SELECT COUNT(*) FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM ="
                + idItem + " AND ID_INTERVENTION = '" + idInterv + "'" + " AND ITERATION=" + iteration;
        ResultSet cursor = null;
        //Connection connection = getConnectionObj();
        try {
            cursor = getConnectionObj().prepareStatement(sql).executeQuery();
            cursor.next();
            int res = cursor.getInt(1);

            if (res != 0 && val != null) {

                if (conf == 1 && Integer.parseInt(val) == 0)
                    executeDDL("DELETE FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM="
                            + idItem
                            + " AND ID_INTERVENTION='"
                            + idInterv
                            + "'"
                            + " AND ITERATION =" + iteration);
                else {
                    PreparedStatement ps = null;
                    try {
                        ps = getConnectionObj()
                                .prepareStatement("UPDATE T_SAISIE_RAPPORT SET VALEUR_ITEM = ?," +
                                        "COMMENTAIRE_ITEM = ? ,DT_SUPPR=NULL ," +
                                        "FL_RESERVE = ? WHERE ID_MODELE_ITEM =" +
                                        " ? AND ID_INTERVENTION = ? AND " +
                                        "ITERATION = ? AND NM_MODELE_ITEM = ? ");

                        ps.set(1, toBinary(cutString(val, 512)));

                        if (com != null)
                            ps.set(2, toBinary(cutString(com, 3072)));
                        else
                            ps.setNull(2);

                        ps.set(3, flReserve);
                        ps.set(4, idItem);
                        ps.set(5, toBinary(idInterv));
                        ps.set(6, iteration);
                        ps.set(7, itemName);

                        Logger.log(TAG, "NM_MODELE_ITEM value is --->" + itemName);
                        ps.execute();
//                        ps.close();
                        //connection.commit();
//                        connDao.commit();
                    } catch (Exception e) {
                        Logger.printException(e);
                    } finally {

                        if (ps != null) {
                            try {
                                ps.close();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        try {
                            connDao.commit();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }

            } else {
                // if (conf != 1 || Integer.parseInt(val) != 0) {
                PreparedStatement ps = null;
                try {
                    ps = getConnectionObj()
                            .prepareStatement("INSERT INTO T_SAISIE_RAPPORT VALUES(?,?,?,?,CURRENT TIMESTAMP,NULL,?,?,?)");

                    ps.set(1, toBinary(idInterv));
                    ps.set(2, idItem);
                    if (val != null)
                        ps.set(3, toBinary(cutString(val, 512)));
                    else
                        ps.setNull(3);
                    if (com != null)
                        ps.set(4, toBinary(cutString(com, 3072)));
                    else
                        ps.setNull(4);
                    ps.set(5, flReserve);
                    ps.set(6, itemName);
                    Logger.log(TAG, "NM_MODELE_ITEM value is --->" + itemName);
                    ps.set(7, iteration);
                    ps.execute();
//                    ps.close();
                    //connection.commit();
//                    connDao.commit();
                } catch (Exception e) {
                    Logger.printException(e);
                } finally {

                    if (ps != null) {
                        try {
                            ps.close();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        connDao.commit();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                // }
            }
//            cursor.close();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }
    }

    /**
     * Gets the piece by categorie.
     *
     * @param idCat the id cathi
     * @param i     the i
     * @return the piece by categorie
     */
    public synchronized ArrayList<HashMap<String, String>> getPieceByCategorie(String idCat,
                                                                               int i) {
        ArrayList<HashMap<String, String>> listPiece = new ArrayList<HashMap<String, String>>();
        try {

            String query = "SELECT "
                    + " ID_PIECE, NM_PIECE ,PRIX_PIECE FROM TREF_PIECES WHERE ID_CATEGORIE_PIECE ='"
                    + idCat + "' AND DT_SUPPR is NULL ORDER BY NM_PIECE ";
            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {

                HashMap<String, String> map = new HashMap<String, String>();
                map.put("id", String.valueOf(cursor.getInt(1)));
                map.put("nom_piece", encodeString(cursor.getBytes(2)));
                map.put("prix", String.valueOf(cursor.getFloat(3)));
                listPiece.add(map);

            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
            Logger.printException(e);
        }
        return listPiece;
    }

    public synchronized ArrayList<Client_Site_Bean> getSitesWithCLient() {

        ArrayList<Client_Site_Bean> listSite = new ArrayList<Client_Site_Bean>();

        String query;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;

        try {
            query = "SELECT  ID_SITE_CLIENT,NM_SITE,ADR_SITE_RUE,ADR_SITE_VILLE,ADR_SITE_CP," +
                    "ADR_SITE_GLOBALE,ADR_SITE_COMPLEMENT,GPS_POSX_SITE,GPS_POSY_SITE,NM_CLIENT," +
                    "ADR_SITE_VILLE,T_SITES_CLIENTS.ID_CLIENT FROM T_SITES_CLIENTS " +
                    "LEFT OUTER JOIN T_CLIENTS ON T_SITES_CLIENTS.ID_CLIENT=T_CLIENTS.ID_CLIENT  " +
                    "WHERE T_SITES_CLIENTS.DT_SUPPR IS NULL ORDER BY NM_CLIENT";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
//                int siteCliendId = cursor.getInt(12);
//                if (getClientDetail(siteCliendId).size() != 0) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }
                Client_Site_Bean site = new Client_Site_Bean(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        cursor.getInt(12));
                listSite.add(site);
//                }

            }
//            cursor.close();
//            preparedStatement.close();

            Logger.log("Sites>>>>>>>", listSite.size() + "");
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listSite;

    }

    public synchronized Client getClientDetails(int clientId) {

        Client client = null;

        String query;

        query = "SELECT "
                + "ID_CLIENT," +
                "NM_CLIENT," +
                "ADR_CLIENT_RUE," +
                "ADR_CLIENT_VILLE," +
                "ADR_CLIENT_GLOBALE," +
                "ADR_CLIENT_COMPLEMENT," +
                "GPS_POSX_CLIENT," +
                "GPS_POSY_CLIENT," +
                "NOM_CONTACT_CLIENT," +
                "TEL_CONTACT_CLIENT," +
                "PUBLIC_LINK," +
                "EMAIL_CONTACT_CLIENT," +
                "MOBILE_CONTACT_CLIENT," +
                "PRENOM_CONTACT_CLIENT," +
                "ADR_CLIENT_PROVINCE," +
                "ADR_CLIENT_PAYS," +
                "ADR_CLIENT_CP,"+
                "REF_CUSTOMER "+
                "FROM T_CLIENTS "
                + " WHERE ID_CLIENT =" + clientId + "";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                client = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        encodeString(cursor.getBytes(16)),
                        encodeString(cursor.getBytes(17)),
                        encodeString(cursor.getBytes(18)));

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        return client;

    }

    /**
     * Gets the custom fields of client .
     *
     * @param idClient the id client
     * @return the custom fields
     */
    public synchronized Vector<CustomFieldsByVal> getCustomFieldsClients(int idClient) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        try {

            String query = "SELECT TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NM_CUSTOMS_FIELD,"
                    + " T_VAL_CUSTOM_FIELDS.ID_ELEMENT_CONCERNE, T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NUM_ORDER "
                    + " FROM TREF_CUSTOM_FIELDS LEFT JOIN T_VAL_CUSTOM_FIELDS "
                    + " ON T_VAL_CUSTOM_FIELDS.ID_CUSTOM_FIELD=TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD "
                    + " WHERE (TREF_CUSTOM_FIELDS.NM_TABLE='T_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idClient
                    + "')"
                    + " AND TREF_CUSTOM_FIELDS.DT_SUPPR IS NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD <> '' AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD IS NOT NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.DT_SUPPR IS NULL ORDER BY TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NUM_ORDER  ";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)), cursor.getInt(6));
                CustomFields.add(listCustomFields);
            }
            cursor.close();
            stmt.close();
            connDao.commit();
            return CustomFields;
        } catch (Exception exc) {
            Logger.printException(exc);
            return new Vector<CustomFieldsByVal>();
        }
    }

    public synchronized Site getSiteDetail(int siteId) {

        Site site = null;

        String query;

        query = "SELECT  ID_SITE_CLIENT," +
                "NM_SITE," +
                "ADR_SITE_RUE," +
                "ADR_SITE_VILLE," +
                "ADR_SITE_GLOBALE," +
                "ADR_SITE_COMPLEMENT," +
                "GPS_POSX_SITE," +
                "GPS_POSY_SITE," +
                "TEL_CONTACT_SITE," +
                "PRENOM_CONTACT_SITE," +
                "NM_CONTACT_SITE," +
                "EMAIL_CONTACT_SITE," +
                "PUBLIC_LINK," +
                "MOBILE_CONTACT_SITE," +
                "ADR_SITE_CP," +
                "ADR_SITE_PAYS," +
                "ADR_SITE_PROVINCE, " +
                "REF_CUSTOMER " +
                "FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT="
                + siteId + "";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);

            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                site = new Site(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        encodeString(cursor.getBytes(16)),
                        encodeString(cursor.getBytes(17)),
                        encodeString(cursor.getBytes(18)));
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        return site;

    }

    /**
     * Gets the custom fields of client .
     *
     * @param idSite the id site
     * @return the custom fields
     */
    public synchronized Vector<CustomFieldsByVal> getCustomFieldsSite(int idSite) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        try {

            String query = "SELECT TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NM_CUSTOMS_FIELD,"
                    + " T_VAL_CUSTOM_FIELDS.ID_ELEMENT_CONCERNE, T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NUM_ORDER "
                    + " FROM TREF_CUSTOM_FIELDS LEFT JOIN T_VAL_CUSTOM_FIELDS "
                    + " ON T_VAL_CUSTOM_FIELDS.ID_CUSTOM_FIELD=TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD "
                    + " WHERE (TREF_CUSTOM_FIELDS.NM_TABLE='T_SITES_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idSite
                    + "')"
                    + " AND TREF_CUSTOM_FIELDS.DT_SUPPR IS NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD <> '' AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD IS NOT NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.DT_SUPPR IS NULL ORDER BY TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NUM_ORDER  ";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)), cursor.getInt(6));
                CustomFields.add(listCustomFields);
            }
            cursor.close();
            stmt.close();
            connDao.commit();
            return CustomFields;
        } catch (Exception exc) {
            Logger.printException(exc);
            return new Vector<CustomFieldsByVal>();
        }
    }

    /**
     * Gets the equipments for a particular site.
     *
     * @param idClient the id client
     * @param idSite   the id site
     * @return the equipements for site
     * @throws Exception the u lj exception
     */
    public Equipement getEquipementsDetail(int idClient, int idSite,
                                           int idEquipment) throws Exception {
        Equipement equipement = null;

        String sql;

        sql = "SELECT ID_EQUIPEMENT_CLIENT,NM_EQUIPEMENT FROM T_EQUIPEMENTS_CLIENTS WHERE ID_CLIENT="
                + idClient;
        if (idSite != -1)
            sql += " AND ID_SITE_CLIENT=" + idSite
                    + " AND ID_EQUIPEMENT_CLIENT=" + idEquipment;
        else
            sql = sql + " AND ID_EQUIPEMENT_CLIENT=" + idEquipment;

        PreparedStatement stmt = connDao.prepareStatement(sql);
        ResultSet cursor = stmt.executeQuery();
        while (cursor.next()) {
            equipement = new Equipement(cursor.getInt(1),
                    encodeString(cursor.getBytes(2)));

        }
        cursor.close();
        stmt.close();
        connDao.commit();
        return equipement;

    }

    /**
     * Gets the custom fields of client .
     *
     * @return the custom fields
     */
    public Vector<CustomFieldsByVal> getCustomFieldEquipment(int idEquipment) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        try {

            String query = "SELECT TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NM_CUSTOMS_FIELD,"
                    + " T_VAL_CUSTOM_FIELDS.ID_ELEMENT_CONCERNE, T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD, TREF_CUSTOM_FIELDS.NUM_ORDER "
                    + " FROM TREF_CUSTOM_FIELDS LEFT JOIN T_VAL_CUSTOM_FIELDS "
                    + " ON T_VAL_CUSTOM_FIELDS.ID_CUSTOM_FIELD=TREF_CUSTOM_FIELDS.ID_CUSTOM_FIELD "
                    + " WHERE (TREF_CUSTOM_FIELDS.NM_TABLE='T_EQUIPEMENTS_CLIENTS' AND ID_ELEMENT_CONCERNE='"
                    + idEquipment
                    + "')"
                    + " AND TREF_CUSTOM_FIELDS.DT_SUPPR IS NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD <> '' AND T_VAL_CUSTOM_FIELDS.VAL_CUSTOM_FIELD IS NOT NULL "
                    + " AND T_VAL_CUSTOM_FIELDS.DT_SUPPR IS NULL ORDER BY TREF_CUSTOM_FIELDS.NM_TABLE, TREF_CUSTOM_FIELDS.NUM_ORDER  ";

            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)), cursor.getInt(6));
                CustomFields.add(listCustomFields);
            }
            cursor.close();
            stmt.close();
            connDao.commit();
            return CustomFields;
        } catch (Exception exc) {
            Logger.printException(exc);
            return new Vector<CustomFieldsByVal>();
        }
    }

    public synchronized String getCountResevation(String idInterv, int idItem, int iteration) {
        String count = "0";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement("SELECT count(*) FROM T_SAISIE_RAPPORT "
                            + "WHERE DT_SUPPR IS NULL AND "
                            + "FL_RESERVE = 2 AND "
                            + "ID_INTERVENTION='"
                            + idInterv
                            + "' AND ITERATION =" + iteration + " AND "
                            + "ID_MODELE_ITEM IN (SELECT ID_MODELE_ITEM FROM TREF_MODELE_ITEM WHERE ID_MODELE_FAMILLE ="
                            + idItem + " AND DT_SUPPR IS NULL)");
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                int id = cursor.getInt(1);
                if (id != 0)
                    count = String.valueOf(id);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            e.printStackTrace();
            count = "0";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return count;
    }

    /**
     * Gets the attachment list for client.
     *
     * @param clientId
     * @return
     */
    public synchronized List<AttachmentsBeans> getClientAttachmentList(int clientId) {
        Vector<AttachmentsBeans> attachmentsBeansList = new Vector<AttachmentsBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT ID_CUSTOMER,ID_ATTACHMENT,TOKEN_ATTACHMENT,NM_ATTACHMENT,SIZE_ATTACHMENT,URL_ATTACHMENT,DT_MODIF,DT_SUPPR,ID_INTERVENTION,ID_CLIENT,ID_SITE_CLIENT,ID_EQUIPEMENT_CLIENT FROM T_ATTACHMENTS WHERE ID_CLIENT="
                    + clientId;
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                AttachmentsBeans attachmentsBeans = new AttachmentsBeans(
                        cursor.getInt(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6),
                        cursor.getString(7), cursor.getString(8),
                        cursor.getString(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12));

                attachmentsBeansList.add(attachmentsBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception exc) {
            Logger.printException(exc);
            attachmentsBeansList = new Vector<AttachmentsBeans>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return attachmentsBeansList;
    }

    /**
     * Gets the attachment list for site.
     *
     * @param siteId
     * @return
     */
    public synchronized List<AttachmentsBeans> getSiteAttachmentList(int siteId) {
        Vector<AttachmentsBeans> attachmentsBeansList = new Vector<AttachmentsBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT ID_CUSTOMER,ID_ATTACHMENT,TOKEN_ATTACHMENT,NM_ATTACHMENT,SIZE_ATTACHMENT,URL_ATTACHMENT,DT_MODIF,DT_SUPPR,ID_INTERVENTION,ID_CLIENT,ID_SITE_CLIENT,ID_EQUIPEMENT_CLIENT FROM T_ATTACHMENTS WHERE ID_SITE_CLIENT="
                    + siteId;
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                AttachmentsBeans attachmentsBeans = new AttachmentsBeans(
                        cursor.getInt(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6),
                        cursor.getString(7), cursor.getString(8),
                        cursor.getString(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12));

                attachmentsBeansList.add(attachmentsBeans);
            }
//            cursor.close();
//            stmt.close();
//            connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception exc) {
            Logger.printException(exc);
            attachmentsBeansList = new Vector<AttachmentsBeans>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return attachmentsBeansList;
    }

    /**
     * Gets attachment list for equipment.
     *
     * @param equipmentId
     * @return
     */
    public synchronized List<AttachmentsBeans> getEquipmentAttachmentList(int equipmentId) {
        Vector<AttachmentsBeans> attachmentsBeansList = new Vector<AttachmentsBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT ID_CUSTOMER,ID_ATTACHMENT,TOKEN_ATTACHMENT,NM_ATTACHMENT,SIZE_ATTACHMENT,URL_ATTACHMENT,DT_MODIF,DT_SUPPR,ID_INTERVENTION,ID_CLIENT,ID_SITE_CLIENT,ID_EQUIPEMENT_CLIENT FROM T_ATTACHMENTS WHERE ID_EQUIPEMENT_CLIENT="
                    + equipmentId;
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                AttachmentsBeans attachmentsBeans = new AttachmentsBeans(
                        cursor.getInt(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6),
                        cursor.getString(7), cursor.getString(8),
                        cursor.getString(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12));

                attachmentsBeansList.add(attachmentsBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception exc) {
            Logger.printException(exc);
            attachmentsBeansList = new Vector<AttachmentsBeans>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return attachmentsBeansList;
    }

    public synchronized List<AttachmentsBeans> getAttachmentList() {
        Vector<AttachmentsBeans> attachmentsBeansList = new Vector<AttachmentsBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            // String query = "SELECT * FROM T_ATTACHMENTS";
            String query = null;

            query = "SELECT * FROM T_ATTACHMENTS WHERE ID_INTERVENTION IS NULL AND ID_CLIENT IS NULL AND ID_SITE_CLIENT IS NULL AND ID_EQUIPEMENT_CLIENT IS NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                AttachmentsBeans attachmentsBeans = new AttachmentsBeans(
                        cursor.getInt(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6),
                        cursor.getString(7), cursor.getString(8),
                        cursor.getString(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12));

                attachmentsBeansList.add(attachmentsBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception exc) {
            Logger.printException(exc);
            attachmentsBeansList = new Vector<AttachmentsBeans>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return attachmentsBeansList;
    }

    public synchronized List<AttachmentsBeans> getJobAttachmentList(String id_interv) {
        Vector<AttachmentsBeans> attachmentsBeansList = new Vector<AttachmentsBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            // String query = "SELECT * FROM T_ATTACHMENTS";
            String query = null;

            query = "SELECT * FROM T_ATTACHMENTS WHERE ID_INTERVENTION='"
                    + id_interv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                AttachmentsBeans attachmentsBeans = new AttachmentsBeans(
                        cursor.getInt(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6),
                        cursor.getString(7), cursor.getString(8),
                        cursor.getString(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getInt(12));

                attachmentsBeansList.add(attachmentsBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception exc) {
            Logger.printException(exc);
            attachmentsBeansList = new Vector<AttachmentsBeans>();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return attachmentsBeansList;
    }

    /**
     * Gets the all st.
     *
     * @param gpsX the gps x
     * @param gpsY the gps y
     * @return the all st
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<HashMap<String, String>> getAllSites(String gpsX,
                                                                       String gpsY) {

        ArrayList<HashMap<String, String>> nrObject = new ArrayList<HashMap<String, String>>();
        HashMap<String, String> map;
        String sql = null;

        sql = "Select TOP 10 ID,"
                + "NOM, "
                + "radians(Latitude) as lat1, "
                + "radians(LatIssy) as lat2, "
                + "radians(Longitude) as long1, "
                + "radians(LongIssy) as long2, "
                + "6366 * 2 * asin(sqrt(power((sin((lat1 - lat2) / 2)),2)+cos(lat1) * cos(lat2) *(power(sin(((long1-long2)/2)), 2))))AS distanceKm, "
                + "Latitude, "
                + "Longitude, "
                + "AdrGlobale, "
                + "AdrComplement, "
                + "RefCustomer "
                + "from ( "
                + "Select abs(LatIssy - Latitude) + abs(LongIssy - Longitude) AS EloignementApprox  from ( "
                + "SELECT ID_SITE_CLIENT as ID,  "
                + "NM_SITE as NOM, "
                + "CAST(GPS_POSY_SITE AS DECIMAL) AS Latitude, "
                + "CAST(GPS_POSX_SITE AS DECIMAL) as Longitude,  "
                + "CAST('"
                + gpsX
                + "' AS DECIMAL) AS LatIssy, "
                + "CAST('"
                + gpsY
                + "' AS DECIMAL) AS LongIssy, "
                + "ADR_SITE_GLOBALE as AdrGlobale, "
                + "ADR_SITE_COMPLEMENT as AdrComplement, "
                + "REF_CUSTOMER as RefCustomer "
                + "FROM T_SITES_CLIENTS "
                + "WHERE DT_SUPPR IS NULL "
                + "AND GPS_POSX_SITE IS NOT NULL AND GPS_POSY_SITE IS NOT NULL "
                + "AND LTRIM(GPS_POSX_SITE) !='' AND LTRIM(GPS_POSY_SITE) != '' "
                + "AND LOWER(GPS_POSX_SITE) != 'null' AND LOWER(GPS_POSY_SITE) !='null'"
                + ")as gpsreference (ID,NOM,Latitude,Longitude,LatIssy,LongIssy,AdrGlobale,AdrComplement,RefCustomer) "
                + ")as top20 (EloignementApprox)  " + "Order by distanceKm";
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(sql);

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                map = new HashMap<String, String>();
                map.put("id", cursor.getString(1));
                map.put("nom", encodeString(cursor.getBytes(2)));
                // map.put("ObjectType", encodeString(cursor.getBytes(3)));
                map.put("distanceKm", cursor.getString(7));
                map.put("Latitude", cursor.getString(8));
                map.put("Longitude", cursor.getString(9));
                map.put("AdrGlobale", cursor.getString(10));
                map.put("AdrComplement", cursor.getString(11));
                map.put("RefCustomer", encodeString(cursor.getBytes(12)));

                // if (map.get("ObjectType").equals("Site")) {
                Client ct = getClientsBySite(cursor.getInt(1));
                map.put("nmClient", String.valueOf(ct.getNmClient()));
                map.put("IdClient", String.valueOf(ct.getIdClient()));
                if (ct.getIdClient() != 0)
                    nrObject.add(map);
                // }

                // nrObject.add(map);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


//        cursor.close();
//        stmt.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        return nrObject;
    }

    public int getSiteByClientId(int siteId) throws Exception {

        int clientId = 0;

        String query;

        query = "SELECT  ID_CLIENT FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT="
                + siteId;

        PreparedStatement preparedStatement = connDao.prepareStatement(query);
        ResultSet cursor = preparedStatement.executeQuery();
        while (cursor.next()) {
            clientId = cursor.getInt(1);

        }
        cursor.close();
        preparedStatement.close();
        connDao.commit();
        return clientId;

    }

    public synchronized String getCPPAYS(String idInterv) {
        String sql = "SELECT ADR_INTERV_PAYS,ADR_INTERV_VILLE FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        String status = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                status = cursor.getString(1) + "=====" + cursor.getString(2);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return status;
    }

    public synchronized int getStatus(String idInterv) {
        String sql = "SELECT CD_STATUT_INTERV FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        int status = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                status = cursor.getInt(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return status;
    }

    public synchronized String getJobNumber(String idInterv) {
        String sql = "SELECT NO_INT_CUST,REF_CUSTOMER FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        String jobNumber = null;
        String refCustomer = "";
        int noIntCust = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                noIntCust = cursor.getInt(1);
                refCustomer = cursor.getString(2);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
            jobNumber = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (refCustomer != null && !TextUtils.isEmpty(refCustomer))
            jobNumber = "#" + refCustomer;
        else if (noIntCust != 0)
            jobNumber = "#" + noIntCust;

        return jobNumber;
    }

    public synchronized Client getCLientDetails(int clientId) {
        Client listClt = null;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT "
                    + "ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT FROM T_CLIENTS "
                    + " WHERE ID_CLIENT = " + clientId;
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                listClt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        encodeString(cursor.getBytes(4)),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)));

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            // Logger.log("CLients>>>>", listClt.size() + "");

        } catch (Exception e) {

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listClt;

    }

    // To get the unavailabilities from server
    public synchronized ArrayList<UnavailabilityBeans> getUnavailabilities() {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 0 " +
                    "AND FL_CLOCK = 0 AND FL_PAYABLE = 0 ORDER BY NOM_TYPE_CONGE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    // To get the unavailabilities from server
    public synchronized ArrayList<UnavailabilityBeans> getUnavailabilitiesWhenTimeTrackerDisabled() {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 0 " +
                    "AND FL_CLOCK = 0 ORDER BY NOM_TYPE_CONGE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    // To get the activities from DB
    public synchronized ArrayList<UnavailabilityBeans> getActivities() {

        ArrayList<UnavailabilityBeans> activitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_UNAVAILABLE = 0 AND FL_DRIVING = 0 AND FL_CLOCK = 0 ORDER BY NOM_TYPE_CONGE ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                activitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return activitiesTypeList;

    }


    /**
     * used to update the end date for unavailability when it is started without
     * end time
     *
     * @param id
     * @param endDate
     */
    public synchronized boolean updateUnavailabilityEndDate(String id, String endDate) {

        boolean result = false;
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();

            Logger.log(TAG, "UPDATE END TIME ACTIVITY END=====>" + endDate);

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_CONGE SET DT_FIN = ? WHERE ID_REMOTE = ?");
            ps.set(1, endDate);
            ps.set(2, id);

            ps.execute();

            getActivityDates(id);
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    private void getActivityDates(String id) {


        long jobSuspendedTime = 0;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_FIN,DT_DEBUT  FROM T_CONGE  WHERE ID_REMOTE='"
                    + id + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    Logger.log(TAG, "UPDATE END TIME ACTIVITY FROM DB START TIME=====>" + resultSet.getString(2));
                    Logger.log(TAG, "UPDATE END TIME ACTIVITY FROM DB END TIME=====>" + resultSet.getString(1));

                    if (!TextUtils.isEmpty(resultSet.getString(1))) {
                        jobSuspendedTime = jobSuspendedTime
                                + getJobSuspendTime(resultSet.getString(1),
                                resultSet.getString(2));

                    }

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * To update the values of an unavailability which was already created
     *
     * @param id
     * @param typeID
     * @param fromDate
     * @param notes
     * @param endDate
     * @return
     */
    public synchronized boolean updateUnavailability(String id, int typeID, String fromDate,
                                                     String notes, String endDate) {
        boolean updated = false;
        PreparedStatement ps = null;
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_CONGE SET ID_TYPE_CONGE = ?,DT_DEBUT = ?,DT_FIN = ?,NOTES = ? WHERE ID_REMOTE = ?");
            ps.set(1, typeID);
            ps.set(2, fromDate);
            ps.set(3, endDate);
            ps.set(4, notes);
            ps.set(5, id);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            updated = true;

        } catch (Exception e) {
            Logger.printException(e);
            updated = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return updated;
    }

    /**
     * to update the end date of the unavailability
     *
     * @param id
     * @param endDate
     * @return
     */
    public boolean updateEndDateForUnavailability(String id, String endDate) {
        try {

            PreparedStatement ps;
            ps = connDao
                    .prepareStatement("UPDATE T_CONGE SET DT_FIN = ? WHERE ID_REMOTE = ?");
            ps.set(1, endDate);
            ps.set(2, id);

            ps.execute();
            ps.close();
            connDao.commit();

            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }

    /**
     * To get the id of the currently running job
     *
     * @return
     */
    public synchronized String getStartedJobId() {
        String sql = "SELECT ID_INTERVENTION FROM T_INTERVENTIONS WHERE CD_STATUT_INTERV = 3";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String result = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                result = encodeString(cursor.getBytes(1));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            result = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * get the items for a single invoice/quotation
     *
     * @return
     */
    public synchronized ArrayList<Invoice_Quotation_Items_Beans> getInvoiceQuotationItemValues(
            String id) {

        ArrayList<Invoice_Quotation_Items_Beans> invoiceQuotationList = new ArrayList<Invoice_Quotation_Items_Beans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            //new changes
            String getInvoiceQuotation = "SELECT * FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '"
                    + id + "'" + " AND DT_SUPPR IS NULL ORDER BY ORDRE";

//            String getInvoiceQuotation = "SELECT * FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '"
//                    + id + "'" + " ORDER BY ORDRE";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(getInvoiceQuotation);

            cursor = stmt.executeQuery();

            Invoice_Quotation_Items_Beans invoiceQuotationBeans = null;

            while (cursor.next()) {
                invoiceQuotationBeans = new Invoice_Quotation_Items_Beans();
                invoiceQuotationBeans.setItem(cursor.getString(1));
                invoiceQuotationBeans.setDescription(cursor.getString(2));
                invoiceQuotationBeans.setUnitPrice(cursor.getDouble(3));
                invoiceQuotationBeans.setQuantity(cursor.getDouble(4));
                invoiceQuotationBeans.setTax(cursor.getDouble(5));
                invoiceQuotationBeans.setOrder(cursor.getInt(6));
                invoiceQuotationBeans.setDiscount(cursor.getDouble(8));
                invoiceQuotationBeans.setTotal(cursor.getDouble(9));
                invoiceQuotationBeans.setTaxValue(cursor.getDouble(10));
                invoiceQuotationBeans.setTotalWIthTax(cursor.getDouble(11));
                invoiceQuotationBeans.setId(cursor.getString(12));
                invoiceQuotationBeans.setDescriptionItem(cursor.getString(16));
                invoiceQuotationBeans.setTaxName(getTaxNameById(cursor.getInt(14)));
                invoiceQuotationBeans.setPercent(cursor.getBoolean(18));
                invoiceQuotationBeans.setIdTaxRate("" + cursor.getInt(14));

                invoiceQuotationList.add(invoiceQuotationBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return invoiceQuotationList;
    }

    public String getFactureId(String idInterv) {
        String sql = "SELECT ID_REMOTE FROM T_FACTURES WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        try {
            PreparedStatement stmt = connDao.prepareStatement(sql);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {

                return encodeString(cursor.getBytes(1));
            }
            cursor.close();
            stmt.close();
            connDao.commit();
            return null;
        } catch (Exception e) {
            return null;
        }
    }


    /**
     * to check if the activity is in progress or not
     *
     * @param id
     */
    public synchronized String getUnavailabilityEndDate(String id) {
        String sql = "SELECT DT_FIN FROM T_CONGE WHERE ID_REMOTE = '"
                + id + "'";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String result = null;
        try {
            stmt = connDao.prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                result = cursor.getString(1);
            }
//            cursor.close();
//            stmt.close();
//            connDao.commit();

        } catch (Exception e) {
            result = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * get the value for description in invoice/quotation add items
     *
     * @return
     */
    public synchronized ArrayList<InvoicingCatalogCategoryBeans> getCatalogCategory() {
        ArrayList<InvoicingCatalogCategoryBeans> categoryList = new ArrayList<InvoicingCatalogCategoryBeans>();

        try {
            String getCatalogCategory = "SELECT * FROM TREF_CATEGORIE_PIECE WHERE DT_SUPPR IS NULL";
            PreparedStatement stmt = connDao.prepareStatement(getCatalogCategory);
            ResultSet cursor = stmt.executeQuery();
            InvoicingCatalogCategoryBeans invoicingCategoryBeans = null;
            while (cursor.next()) {
                invoicingCategoryBeans = new InvoicingCatalogCategoryBeans();
                invoicingCategoryBeans.setIdCategory(cursor.getInt(1));
                invoicingCategoryBeans.setNameCategory(cursor.getString(3));
                categoryList.add(invoicingCategoryBeans);
            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return categoryList;
    }

    /**
     * Query to add a new invoice or quotation from mobile
     *
     * @param idInterv     = job id
     * @param flag         = 0 if quotaion; 1 if invoice
     * @param createdDate  = date of creation
     * @param idClient     = client id
     * @param total        = total without tax
     * @param tax          = tax amount
     * @param totalWithTax = total value with tax amount
     * @return
     */
    public synchronized boolean addInvoiceOrQuotation(String idInterv, int flag,
                                                      String createdDate, int idClient, int idSite, double total,
                                                      double tax, double totalWithTax, String uniqueId,boolean isInvoiceStrict) {

//        //old code
//        String uniqueId = getUniqueId();

        int customerId = getIdCustomer();
        PreparedStatement ps = null;
        boolean result = false;
        try {

            //v52 Update
            if (true) {
                double globalTax = updateGlobalTaxValues(total, uniqueId);
                if (globalTax > 0) {
                    double invoiceTaxTotal = getTotalTaxInvoice(uniqueId);
                    tax = invoiceTaxTotal + globalTax;
                    total = total + tax;
                }
            }
// v55 updated
            ps = getConnectionObj().prepareStatement("INSERT INTO T_FACTURES(" + "ID_REMOTE,"
                    + "ID_CUSTOMER," + "ID_INTERVENTION," + "FL_FACTURE,"
                    + "DT_CREATE," + "ID_CLIENT," + "ID_SITE," + "TOTAL_HT,"
                    + "VAL_TVA," +"TOTAL_TTC,"
                    +"FL_INV_STRICT," + "NO_INT_FACTURE_DEVIS )" + "VALUES(?,?,?,?,?,?,?,?,?,?,?,0)");

            ps.set(1, uniqueId);
            ps.set(2, customerId);
            ps.set(3, idInterv);
            ps.set(4, flag);
            ps.set(5, createdDate);
            ps.set(8, total);
            ps.set(9, tax);
            ps.set(10, totalWithTax);
            ps.set(11, isInvoiceStrict);

            if (idClient == -1) {
                ps.setNull(6);
                Log.e("idClientNULL", "idClientNULL: " + idClient);
            } else if (idClient == 0) {
                ps.setNull(6);
                Log.e("idClientNULL", "idClientNULL: " + idClient);
            } else {
                ps.set(6, idClient);
                Log.e("idClient", "idClient: " + idClient);
            }
            if (idSite == -1) {
                ps.setNull(7);
                Log.e("idSiteNULL", "idSiteNULL: " + idSite);
            } else if (idSite == 0) {
                ps.setNull(7);
                Log.e("idSiteNULL", "idSiteNULL: " + idSite);
            } else {
                ps.set(7, idSite);
                Log.e("idSite", "idSite: " + idSite);
            }
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

//            viewId(uniqueId);

            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    private void viewId(String uniqueId) {


        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT ID_CLIENT,ID_SITE FROM T_FACTURES WHERE ID_REMOTE = '" + uniqueId
                    + "' ";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {

                Logger.log(TAG, "UNIQUE_ID VALUE DAO ID_SITE====>" + cursor.getInt(2));
                Logger.log(TAG, "UNIQUE_ID VALUE DAO ID_CLIENT====>" + cursor.getInt(1));
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * To add a new item in invoice or quotation.
     *
     * @param itemName
     * @param description
     * @param unitPrice
     * @param quantity
     * @param taxRate
     * @param discount
     * @param total
     * @param tax
     * @param totalWithTax
     * @param invoiceQuotationId
     * @return
     */
    public synchronized boolean addInvoiceOrQuotationItem(String itemName,
                                                          String description, double unitPrice, double quantity, double taxRate,
                                                          int order, double discount, double total, double tax,
                                                          double totalWithTax, String invoiceQuotationId,
                                                          String descripItem, boolean isPercentage) {

        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;

        //formatting the decimal
        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        try {

            //v51
//            ps = getConnectionObj().prepareStatement("INSERT INTO T_LIGNES_FACTURE("
//                    + "ID_REMOTE," + "REF_LIGNE," + "DESCR_LIGNE,"
//                    + "PRIX_UNITAIRE," + "QUANTITE," + "VAL_TAXRATE,"
//                    + "ORDRE, " + "DISCOUNT," + "TOTAL_HT," + "VAL_TVA,"
//                    + "TOTAL_TTC," + "ID_REMOTE_FACTURE," + "DESCRIPTION," + "DISCOUNTPERCENT )" + "VALUES('"
//                    + uniqueId
//                    + "','"
//                    + itemName
//                    + "','"
//                    + description
//                    + "',"
//                    + unitPrice
//                    + ","
//                    + quantity
//                    + ","
//                    + taxRate
//                    + ","
//                    + order
//                    + ","
//                    + discount
//                    + ","
//                    + total
//                    + ","
//                    + tax
//                    + ","
//                    + totalWithTax + ",'" + invoiceQuotationId + "','" + descripItem + "'," + isPercentage + "')");


            ps = getConnectionObj().prepareStatement("INSERT INTO T_LIGNES_FACTURE " +
                    "(ID_REMOTE,REF_LIGNE,DESCR_LIGNE,PRIX_UNITAIRE,QUANTITE,VAL_TAXRATE,ORDRE,DISCOUNT,TOTAL_HT,VAL_TVA,TOTAL_TTC,ID_REMOTE_FACTURE,DESCRIPTION,DISCOUNTPERCENT )"
                    + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?)");


            ps.set(1, uniqueId);
            ps.set(2, itemName);
            ps.set(3, description);
            ps.set(4, unitPrice);
            ps.set(5, quantity);
            ps.set(6, taxRate);
            ps.set(7, order);
            ps.set(8, String.format(Locale.US, formatDecimal, discount));
            ps.set(9, String.format(Locale.US, formatDecimal, total));
            ps.set(10, String.format(Locale.US, formatDecimal, tax));
            ps.set(11, String.format(Locale.US, formatDecimal, totalWithTax));
            ps.set(12, invoiceQuotationId);
            ps.set(13, descripItem);
            ps.set(14, isPercentage);


            ps.execute();


            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Get the values for a single invoice or quotation
     *
     * @return object for Invoice_Quotation_Beans
     */
    public synchronized Invoice_Quotation_Beans getInvoiceQuotationDetails(String idInterv) {
        Invoice_Quotation_Beans listInvoiceQuotation = new Invoice_Quotation_Beans();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT * FROM T_FACTURES WHERE ID_INTERVENTION = '"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                listInvoiceQuotation.setId(cursor.getString(12));
                listInvoiceQuotation.setCustomerId(cursor.getInt(1));
                listInvoiceQuotation.setJobId(cursor.getString(2));
                listInvoiceQuotation.setNumberOfIQ(cursor.getInt(3));
                listInvoiceQuotation.setFlag(cursor.getInt(4));
                listInvoiceQuotation.setDateOfCreation(cursor.getString(5));
                listInvoiceQuotation.setClientId(cursor.getInt(7));
                listInvoiceQuotation.setSiteId(cursor.getInt(8));
                listInvoiceQuotation.setTotalWithoutTax(cursor.getFloat(9));
                listInvoiceQuotation.setTax(cursor.getFloat(10));
                listInvoiceQuotation.setTotalWithTax(cursor.getFloat(11));

                Logger.log(TAG, "UNIQUE_ID VALUE DAO====>" + cursor.getString(12));
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listInvoiceQuotation;

    }


    /**
     * Get the values for a single invoice or quotation
     *
     * @return object for Invoice_Quotation_Beans
     */
    public synchronized Invoice_Quotation_Beans getInvoiceQuotationDetailsNew(String idInterv,
                                                                              String invoiceQuotationId) {
        Invoice_Quotation_Beans listInvoiceQuotation = new Invoice_Quotation_Beans();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

//            query = "SELECT * FROM T_FACTURES WHERE ID_INTERVENTION = '"
//                    + idInterv + "' ";

            query = "SELECT * FROM T_FACTURES WHERE ID_INTERVENTION = '"
                    + idInterv + "' AND ID_REMOTE = '" + invoiceQuotationId
                    + "' ";

            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                listInvoiceQuotation.setId(cursor.getString(12));
                listInvoiceQuotation.setCustomerId(cursor.getInt(1));
                listInvoiceQuotation.setJobId(cursor.getString(2));
                listInvoiceQuotation.setNumberOfIQ(cursor.getInt(3));
                listInvoiceQuotation.setFlag(cursor.getInt(4));
                listInvoiceQuotation.setDateOfCreation(cursor.getString(5));
                listInvoiceQuotation.setClientId(cursor.getInt(7));
                listInvoiceQuotation.setSiteId(cursor.getInt(8));
                listInvoiceQuotation.setTotalWithoutTax(cursor.getFloat(9));
                listInvoiceQuotation.setTax(cursor.getFloat(10));
                listInvoiceQuotation.setTotalWithTax(cursor.getFloat(11));

                Logger.log(TAG, "UNIQUE_ID VALUE DAO====>" + cursor.getString(12));
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listInvoiceQuotation;

    }

    /**
     * method to fetch the subcategories for description in invoicing
     *
     * @param idCategory - id of the category
     * @return
     */
    public synchronized ArrayList<InvoicingCatalogSubCategoryBeans> getSubcategoryByID(
            String idCategory) {
        ArrayList<InvoicingCatalogSubCategoryBeans> subcategoryList = new ArrayList<InvoicingCatalogSubCategoryBeans>();

        try {
            String query;
            query = "SELECT * FROM TREF_PIECES WHERE ID_CATEGORIE_PIECE ='"
                    + idCategory + "' AND DT_SUPPR IS NULL";
            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                InvoicingCatalogSubCategoryBeans subCatBeans = new InvoicingCatalogSubCategoryBeans();
                subCatBeans.setId(String.valueOf(cursor.getInt(1)));
                subCatBeans.setNameSubcategory(cursor.getString(3));
                subCatBeans.setItemName(cursor.getString(4));
                subCatBeans.setPriceSubcategory(String.valueOf(cursor
                        .getFloat(5)));
                subCatBeans.setIdTaxRate(String.valueOf(cursor.getInt(8)));
                subcategoryList.add(subCatBeans);

            }
            cursor.close();
            stmt.close();
            connDao.commit();
        } catch (Exception e) {
        }
        return subcategoryList;
    }

    public synchronized ArrayList<TaxRates> getTaxRates() {
        ArrayList<TaxRates> taxList = new ArrayList<TaxRates>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_TAXRATES WHERE DT_SUPPR IS NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                TaxRates taxRates = new TaxRates();
                taxRates.setIdTaxRate(String.valueOf(cursor.getInt(1)));
                taxRates.setValTaxRate(String.valueOf(cursor.getFloat(4)));
                taxRates.setValTaxName(cursor.getString(3));
                taxList.add(taxRates);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return taxList;
    }

    /**
     * To get the tax of the corresponding item in invoice/quotation
     *
     * @param idTax
     * @return
     */
    public synchronized String getTaxById(int idTax) {
        String taxRate = null;

        String query = "SELECT  VAL_TAXRATE FROM T_TAXRATES WHERE ID_TAXRATE="
                + idTax;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                taxRate = String.valueOf(cursor.getFloat(1));
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return taxRate;
    }

    private double updateGlobalTaxValues(double subTotal, String invoiceQuotationId) {

        double invoiceTaxTotal = getTotalTaxInvoice(invoiceQuotationId);
        double invoiceSubTotal = subTotal;

        ArrayList<GlobalTaxInvoiceList> globalTaxInvoiceLists = new ArrayList<>();
        globalTaxInvoiceLists = getGlobalTaxInvoice(invoiceQuotationId);

        double globalTaxAmount = 0;
        if (globalTaxInvoiceLists != null && globalTaxInvoiceLists.size() > 0) {
            for (int i = 0; i < globalTaxInvoiceLists.size(); i++) {
                double taxSubtotal = invoiceSubTotal;
                double totalTax = invoiceSubTotal + invoiceTaxTotal;
                double taxValue = (invoiceSubTotal * globalTaxInvoiceLists.get(i).getTax()) / 100;
                if (globalTaxInvoiceLists.get(i).isHasCompound()) {
                    taxSubtotal = taxSubtotal + invoiceTaxTotal;
                }
                taxValue = (taxSubtotal * globalTaxInvoiceLists.get(i).getTax()) / 100;

                globalTaxAmount = globalTaxAmount + taxValue;

                updateGlobalTaxInvoice(globalTaxInvoiceLists.get(i).isHasCompound(),
                        globalTaxInvoiceLists.get(i).getIdRemote(), taxValue);

            }
        }


        return globalTaxAmount;
    }

    /**
     * To update the previous values of invoice or quotation
     *
     * @param id
     * @param subTotal
     * @param taxValue
     * @param total
     * @param updateGlbTaxValue
     * @return
     */
    public synchronized boolean updateInvoiceOrQuotation(String id, double subTotal,
                                                         double taxValue, double total, boolean updateGlbTaxValue) {

        boolean result = false;
        PreparedStatement ps = null;

        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        try {

            if (updateGlbTaxValue) {
                double globalTax = updateGlobalTaxValues(subTotal, id);

                if (globalTax > 0) {
                    double invoiceTaxTotal = getTotalTaxInvoice(id);
                    taxValue = invoiceTaxTotal + globalTax;
                    total = subTotal + taxValue;
                }
            }
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURES SET TOTAL_HT = ?,VAL_TVA = ?,TOTAL_TTC = ? " +
                            "WHERE ID_REMOTE = ?");
            ps.set(1, String.format(Locale.US, formatDecimal, subTotal));
            ps.set(2, String.format(Locale.US, formatDecimal, taxValue));
            ps.set(3, String.format(Locale.US, formatDecimal, total));
            ps.set(4, id);
            ps.execute();


//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public synchronized boolean updateInvoiceOrQutationItem(double total, double tax,
                                                            double totalWithTax, String itemName, String description,
                                                            double unitPrice, double qty, double taxRate, double discount,
                                                            String id, String descItem, boolean isPercentage) {

        boolean result = false;
        PreparedStatement ps = null;
        //formatting the decimal
        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_LIGNES_FACTURE SET TOTAL_HT = ?,VAL_TVA = ?,TOTAL_TTC = ?,REF_LIGNE = ?,DESCR_LIGNE = ?,PRIX_UNITAIRE = ?,QUANTITE = ?,VAL_TAXRATE = ?,DISCOUNT = ?,DESCRIPTION = ?,DISCOUNTPERCENT = ? WHERE ID_REMOTE = ?");
            ps.set(1, String.format(Locale.US, formatDecimal, total));
            ps.set(2, String.format(Locale.US, formatDecimal, tax));
            ps.set(3, String.format(Locale.US, formatDecimal, totalWithTax));
            ps.set(4, itemName);
            ps.set(5, description);
            ps.set(6, String.format(Locale.US, formatDecimal, unitPrice));
            ps.set(7, qty);
            ps.set(8, taxRate);
            ps.set(9, String.format(Locale.US, formatDecimal, discount));
            ps.set(10, descItem);
            ps.set(11, isPercentage);
            ps.set(12, id);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * to delete an invoice or quotation item
     *
     * @param id
     */
    public synchronized void deleteInvoiceOrQuotationItem(String id) {

        executeDDL("DELETE FROM T_LIGNES_FACTURE WHERE ID_REMOTE = '" + id
                + "'");

    }

    /* to delete a whole invoice or quotation item
     *
     * @param id
     */
    public synchronized void deleteInvoiceOrQuotation(String id) {

        executeDDL("DELETE FROM T_FACTURES WHERE ID_REMOTE = '" + id
                + "'");
    }

    /**
     * method to fetch the parts & service, reference & price for inventory list
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getInventoryList() {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
//            query = "SELECT * FROM TREF_PIECES WHERE FL_TRACK_STOCK=1 AND DT_SUPPR is NULL";

            query = "SELECT TREF_PIECES.ID_PIECE, " +
                    "TREF_PIECES.NM_PIECE, " +
                    "TREF_PIECES.CD_PRODUIT, " +
                    "TREF_PIECES.PRIX_PIECE, " +
                    "TREF_PIECES.FL_SERIALIZABLE, " +
                    "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE, " +
                    "T_STOCK_PIECES.QUANTITY,TREF_PIECES.DESCRIPTION " +
                    "FROM TREF_PIECES,TREF_CATEGORIE_PIECE " +
                    "LEFT OUTER JOIN T_STOCK_PIECES ON TREF_PIECES.ID_PIECE = T_STOCK_PIECES.ID_PIECE " +
                    "WHERE TREF_PIECES.DT_SUPPR is NULL " +
                    "AND TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE " +
                    "AND TREF_PIECES.FL_TRACK_STOCK=1";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
                subCatBeans.setPartsService(cursor.getString(2));
                subCatBeans.setReference(cursor.getString(3));
                subCatBeans.setCostOfItem((cursor.getDouble(4)));
                subCatBeans.setIsSerializable((cursor.getInt(5)));
                subCatBeans.setCategory(cursor.getString(6));
                subCatBeans.setNoOfPieces(String.valueOf(cursor.getInt(7)));
                subCatBeans.setDescription(cursor.getString(8));
                subcategoryList.add(subCatBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return subcategoryList;
    }

    /**
     * method to fetch the parts & service, reference & price for inventory list which has qty more than 1 (stock)
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getStockInventoryList() {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
//            query = "SELECT * FROM TREF_PIECES WHERE FL_TRACK_STOCK=1 AND DT_SUPPR is NULL";

            query = "SELECT TREF_PIECES.ID_PIECE, " +
                    "TREF_PIECES.NM_PIECE, " +
                    "TREF_PIECES.CD_PRODUIT, " +
                    "TREF_PIECES.PRIX_PIECE, " +
                    "TREF_PIECES.FL_SERIALIZABLE, " +
                    "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE, " +
                    "T_STOCK_PIECES.QUANTITY,TREF_PIECES.DESCRIPTION " +
                    "FROM TREF_PIECES,TREF_CATEGORIE_PIECE,T_STOCK_PIECES " +
                    "WHERE TREF_PIECES.DT_SUPPR is NULL " +
                    "AND TREF_PIECES.ID_PIECE = T_STOCK_PIECES.ID_PIECE " +
                    "AND TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE " +
                    "AND TREF_PIECES.FL_TRACK_STOCK=1 " +
                    "AND T_STOCK_PIECES.QUANTITY > 0";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
                subCatBeans.setPartsService(cursor.getString(2));
                subCatBeans.setReference(cursor.getString(3));
                subCatBeans.setCostOfItem(cursor.getDouble(4));
                subCatBeans.setIsSerializable((cursor.getInt(5)));
                subCatBeans.setCategory(cursor.getString(6));
                subCatBeans.setNoOfPieces(String.valueOf(cursor.getInt(7)));
                subCatBeans.setDescription(cursor.getString(8));
                subcategoryList.add(subCatBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return subcategoryList;
    }

    /**
     * method to fetch the parts & service, reference & price for inventory list which has pending request.
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getRequestInventoryList() {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
//            query = "SELECT * FROM TREF_PIECES WHERE FL_TRACK_STOCK=1 AND DT_SUPPR is NULL";

            query = "SELECT TREF_PIECES.ID_PIECE, " +
                    "TREF_PIECES.NM_PIECE, " +
                    "TREF_PIECES.CD_PRODUIT, " +
                    "TREF_PIECES.PRIX_PIECE, " +
                    "TREF_PIECES.FL_SERIALIZABLE, " +
                    "TREF_PIECES.ID_CATEGORIE_PIECE,TREF_PIECES.DESCRIPTION " +
                    "FROM TREF_PIECES " +
                    "WHERE TREF_PIECES.DT_SUPPR is NULL " +
                    "AND TREF_PIECES.ID_PIECE IN (SELECT T_PIECE_DEMANDE.ID_PIECE FROM T_PIECE_DEMANDE WHERE TREF_PIECES.ID_PIECE = T_PIECE_DEMANDE.ID_PIECE AND T_PIECE_DEMANDE.FL_TRANSFER = 0 AND T_PIECE_DEMANDE.DT_COMPLETED IS NULL) " +
                    "AND TREF_PIECES.FL_TRACK_STOCK=1 ";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
                subCatBeans.setPartsService(cursor.getString(2));
                subCatBeans.setReference(cursor.getString(3));
                subCatBeans.setCostOfItem(cursor.getDouble(4));
                subCatBeans.setIsSerializable((cursor.getInt(5)));
                String category = getInventoryCategory(cursor.getInt(6));
                subCatBeans.setCategory(category);
                int qty = getQtyOfPiece(cursor.getInt(1));
                subCatBeans.setNoOfPieces(String.valueOf(qty));
                subCatBeans.setDescription(cursor.getString(7));
                subcategoryList.add(subCatBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return subcategoryList;
    }

    /**
     * method to fetch the parts & service, reference & price for inventory list which has pending request.
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getStockRequestInventoryList() {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
//            query = "SELECT * FROM TREF_PIECES WHERE FL_TRACK_STOCK=1 AND DT_SUPPR is NULL";

            query = "SELECT TREF_PIECES.ID_PIECE, " +
                    "TREF_PIECES.NM_PIECE, " +
                    "TREF_PIECES.CD_PRODUIT, " +
                    "TREF_PIECES.PRIX_PIECE, " +
                    "TREF_PIECES.FL_SERIALIZABLE, " +
                    "TREF_PIECES.ID_CATEGORIE_PIECE,TREF_PIECES.DESCRIPTION " +
                    "FROM TREF_PIECES " +
                    "WHERE TREF_PIECES.DT_SUPPR is NULL " +
                    "AND (TREF_PIECES.ID_PIECE IN (SELECT T_STOCK_PIECES.ID_PIECE FROM T_STOCK_PIECES WHERE T_STOCK_PIECES.QUANTITY > 0) " +
                    "AND TREF_PIECES.ID_PIECE IN (SELECT T_PIECE_DEMANDE.ID_PIECE FROM T_PIECE_DEMANDE WHERE TREF_PIECES.ID_PIECE = T_PIECE_DEMANDE.ID_PIECE AND T_PIECE_DEMANDE.FL_TRANSFER = 0 AND T_PIECE_DEMANDE.DT_COMPLETED IS NULL)) " +
                    "AND TREF_PIECES.FL_TRACK_STOCK=1 ";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
                subCatBeans.setPartsService(cursor.getString(2));
                subCatBeans.setReference(cursor.getString(3));
                subCatBeans.setCostOfItem(cursor.getDouble(4));
                subCatBeans.setIsSerializable((cursor.getInt(5)));
                String category = getInventoryCategory(cursor.getInt(6));
                subCatBeans.setCategory(category);
                int qty = getQtyOfPiece(cursor.getInt(1));
                subCatBeans.setNoOfPieces(String.valueOf(qty));
                subCatBeans.setDescription(cursor.getString(7));
                subcategoryList.add(subCatBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return subcategoryList;
    }

    /**
     * gets qty of a piece from T_STOCK_PIECE table.
     *
     * @param idPiece
     * @return
     */
    public synchronized int getQtyOfPiece(int idPiece) {
        int qty = 0;
        String query = "SELECT QUANTITY FROM T_STOCK_PIECES WHERE ID_PIECE =" + idPiece;
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            Logger.output(TAG, "idPiece : " + idPiece);
            if (cursor.next()) {
                qty = cursor.getInt(1);
                Logger.output(TAG, "qty : " + qty);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return qty;
    }

    /**
     * get the value for category in Inventory list
     *
     * @return
     */
    public synchronized String getInventoryCategory(int idCategory) {

        String category = "";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getCatalogCategory = "SELECT NM_CATEGORIE_PIECE FROM TREF_CATEGORIE_PIECE " +
                    "WHERE ID_CATEGORIE_PIECE ='"
                    + idCategory + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(getCatalogCategory);
            cursor = stmt.executeQuery();

            if (cursor.next()) {
                category = cursor.getString(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return category;
    }

    /**
     * method to fetch the stock id & stock name for inventory list
     *
     * @return array list of stock model class
     */
    public synchronized ArrayList<InventoryStocksBeans> getInventoryStockList(
            String idUserStock) {
        ArrayList<InventoryStocksBeans> stockList = new ArrayList<InventoryStocksBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_STOCKS WHERE ID_STOCK != '" + idUserStock
                    + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryStocksBeans stockBeans = new InventoryStocksBeans();
                stockBeans.setIdStock(cursor.getString(1));
                stockBeans.setNameStock(cursor.getString(2));
                stockList.add(stockBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return stockList;
    }

    /**
     * To get the name of a stock.
     *
     * @param idStock
     * @return
     */
    public synchronized String getStockName(String idStock) {
        String nameStock = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_STOCKS WHERE ID_STOCK = '" + idStock + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                nameStock = cursor.getString(2);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return nameStock;
    }

    /**
     * method to fetch the serial numbers of particular depot ordered by serial
     * numbers.
     *
     * @return array list of stock model class
     */
    public synchronized ArrayList<InventorySerialNumbersBeans> getDepotSerialNumbers(
            String idUserStock, int idPiece) {
        ArrayList<InventorySerialNumbersBeans> serialNosList = new ArrayList<InventorySerialNumbersBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
                    + idUserStock + "' AND ID_PIECE=" + idPiece
                    + " AND STATUS ='ok' "
                    + "ORDER BY SERIAL ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventorySerialNumbersBeans serialBeans = new InventorySerialNumbersBeans();
//                serialBeans.setIdSerialNumber(cursor.getString(1));
//                serialBeans
//                        .setSerialNumber(String.valueOf(cursor.getString(4)));
//                serialBeans.setIdInterv(cursor.getString(5));
//                serialBeans.setDateUsed(cursor.getString(6));
//                serialNosList.add(serialBeans);

                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans.setIdStock(cursor.getString(2));
                serialBeans.setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialBeans.setIdPiece(cursor.getInt(3));
                serialNosList.add(serialBeans);

                Logger.log(TAG, "CHECKING SERIAL STATUS IS : " + String.valueOf(cursor.getString(4)) + " is "
                        + cursor.getString(8));

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return serialNosList;
    }

    /**
     * method to fetch the serial numbers of particular depot order by date
     * used.
     *
     * @return array list of stock model class
     */
    public synchronized ArrayList<InventorySerialNumbersBeans> getPartsSerialNumbers(
            String idUserStock, int idPiece) {
        ArrayList<InventorySerialNumbersBeans> serialNosList = new ArrayList<InventorySerialNumbersBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
                    + idUserStock + "' AND ID_PIECE=" + idPiece
                    + "ORDER BY DT_USED ASC";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventorySerialNumbersBeans serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans.setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialNosList.add(serialBeans);


                Logger.log(TAG, "SERIAL STATUS IS : " + String.valueOf(cursor.getString(4)) + " is "
                        + cursor.getString(7));
            }
//            cursor.close();
//            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        try {
//            //connection.commit();
//            connDao.commit();
//            //connection.release();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }

        return serialNosList;
    }

    public synchronized ArrayList<InventorySerialNumbersBeans> getPartsSerialNumbers(String idPiece) {
        ArrayList<InventorySerialNumbersBeans> serialNosList = new ArrayList<InventorySerialNumbersBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
//            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
//                    + idUserStock + "' AND ID_PIECE=" + idPiece
//                    + "ORDER BY DT_USED ASC";

            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_PIECE = '" + idPiece + "' " +
                    " AND STATUS ='ok' " +
                    "ORDER BY SERIAL ASC";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventorySerialNumbersBeans serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans.setIdStock(cursor.getString(2));
                serialBeans.setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialBeans.setIdPiece(cursor.getInt(3));
                serialNosList.add(serialBeans);

                Logger.log(TAG, "SERIAL STATUS IS : " + String.valueOf(cursor.getString(4)) + " is "
                        + cursor.getString(7));
            }
//            cursor.close();
//            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        try {
//            //connection.commit();
//            connDao.commit();
//            //connection.release();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }

        return serialNosList;
    }

    public int getQuantityOfPiece(String idUserStock, int idPiece) {
        PreparedStatement stmt;
        ResultSet cursor;
        try {
            String sql = "SELECT COUNT(*) FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
                    + idUserStock
                    + "' AND ID_PIECE="
                    + idPiece
                    + " AND ID_INTERVENTION IS NULL";
            stmt = connDao.prepareStatement(sql);
            cursor = stmt.executeQuery();
            cursor.next();
            int qty = cursor.getInt(1);
            cursor.close();
            stmt.close();
            connDao.commit();
            return qty;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }
    }

    /**
     * Add the value of the stock to T_PIECE_DEMANDE table
     *
     * @param idStockSource
     * @param idStockDestination
     * @param idPiece
     * @param idUser
     * @param qty
     * @param flTransfer
     * @param dateCreated
     * @return true - if successfully added
     */
    public synchronized boolean addInventoryTransfer(String idStockSource,
                                                     String idStockDestination, int idPiece, int idUser, int qty,
                                                     int flTransfer, int flUrgent, String dateCreated) {

        Logger.log("TAG", "CHECKING SERIAL ADD idStockSource =====>" + idStockSource);
        Logger.log("TAG", "CHECKING SERIAL ADD idStockDestination =====>" + idStockDestination);
        Logger.log("TAG", "CHECKING SERIAL ADD idPiece =====>" + idPiece);
        Logger.log("TAG", "CHECKING SERIAL ADD idUser =====>" + idUser);
        Logger.log("TAG", "CHECKING SERIAL ADD qty,flTransfer,flUrgent =====>" + qty + "==>" + flTransfer + "==>" + flUrgent);
        Logger.log("TAG", "CHECKING SERIAL ADD dateCreated =====>" + dateCreated);

        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_PIECE_DEMANDE("
                    + "ID_PIECE_DEMANDE," + "ID_STOCK_SOURCE,"
                    + "ID_STOCK_DESTINATION," + "ID_PIECE," + "ID_USER,"
                    + "QUANTITY," + "FL_TRANSFER," + "FL_URGENT," + "DT_CREATED )"
                    + "VALUES('" + uniqueId + "','" + idStockSource + "','"
                    + idStockDestination + "'," + idPiece + "," + idUser + ","
                    + qty + "," + flTransfer + "," + flUrgent + ",'" + dateCreated + "')");

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Update the stock id of the serial number after transfer/request. i.e.,
     * Restock
     *
     * @param idStock
     * @param serialNumber
     * @return
     */
    public synchronized boolean updateSerialNoId(String idStock, String serialNumber,
                                                 int idPiece, String idPieceSerial) {
        boolean result;
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            Logger.log("TAG", "CHECKING SERIAL ADD UPDATE ID_STOCK =====>" + idStock);
            Logger.log("TAG", "CHECKING SERIAL ADD UPDATE SERIAL =====>" + serialNumber);
            Logger.log("TAG", "CHECKING SERIAL ADD UPDATE SERIAL ID_PIECE =====>" + idPiece);
            Logger.log("TAG", "CHECKING SERIAL ADD UPDATE SERIAL ID_PIECE_SERIAL =====>" + idPieceSerial);


            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PIECE_SERIALS SET ID_STOCK = ? " +
                            "WHERE SERIAL = ? AND ID_PIECE = ? AND ID_PIECE_SERIAL = ?");
            ps.set(1, idStock);
            ps.set(2, serialNumber);
            ps.set(3, idPiece);
            ps.set(4, idPieceSerial);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * method to get the pending request list from t_piece_demande, which items
     * should have fl_tansfer = 0 and dt_completed = null.
     *
     * @return array list of stock model class
     */
    public synchronized ArrayList<PendingRequestBeans> getPendingRequestList(int idPiece) {
        ArrayList<PendingRequestBeans> pendingRequestList = new ArrayList<PendingRequestBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT ID_STOCK_SOURCE,ID_STOCK_DESTINATION,QUANTITY,ID_PIECE_DEMANDE,FL_URGENT FROM T_PIECE_DEMANDE WHERE FL_TRANSFER = 0 AND DT_COMPLETED IS NULL AND ID_PIECE = "
                    + idPiece;


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                PendingRequestBeans pendingRequest = new PendingRequestBeans();
                pendingRequest.setIdStock(cursor.getString(1));
                pendingRequest.setIdStockDest(cursor.getString(2));
                pendingRequest.setQty(cursor.getInt(3));
                pendingRequest.setIdPieceDemande(cursor.getString(4));
                pendingRequest.setFlUrgent(cursor.getInt(5));
                pendingRequestList.add(pendingRequest);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return pendingRequestList;
    }

    /**
     * Update the completed date of a request which is in pending request list.
     *
     * @return
     */
    public synchronized boolean updateCompletedDate(String idPieceDemande,
                                                    String dateCompleted) {

        PreparedStatement ps = null;
        boolean result;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PIECE_DEMANDE SET DT_COMPLETED = ? WHERE ID_PIECE_DEMANDE = ?");
            ps.set(1, dateCompleted);
            ps.set(2, idPieceDemande);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Gets the id_piece of an item.
     *
     * @param reference - Reference of an item.
     * @return idPiece
     */
    public ArrayList<String> getIdForReference(String reference) {
        ArrayList<String> arrIdPiece = new ArrayList<>();
        try {
            String query;
            query = "SELECT * FROM TREF_PIECES WHERE CD_PRODUIT = '"
                    + reference + "'";
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj().prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            while (cursor.next()) {
                arrIdPiece.add(String.valueOf(cursor.getInt(1)));
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return arrIdPiece;
    }

    public boolean checkSortiePiece(String idPiece) {
        try {
            String query;
            query = "SELECT ID_PIECE FROM T_SORTIE_PIECE WHERE ID_PIECE = "
                    + idPiece;
            PreparedStatement stmt = connDao.prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            cursor.close();
            stmt.close();
            connDao.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * fetch the parts & service, reference & price for invoice & parts and
     * service list
     *
     * @param idCategory
     *            - id of the category
     * @return
     */
    // public ArrayList<InventoryListBeans> getAllPartsAndService(
    // String idIntervention) {
    // ArrayList<InventoryListBeans> subcategoryList = new
    // ArrayList<InventoryListBeans>();
    //
    // try {
    // String query;
    // query = "SELECT * FROM TREF_PIECES";
    // PreparedStatement stmt = connDao.prepareStatement(query);
    // ResultSet cursor = stmt.executeQuery();
    // while (cursor.next()) {
    // InventoryListBeans subCatBeans = new InventoryListBeans();
    // subCatBeans.setId(String.valueOf(cursor.getInt(1)));
    // subCatBeans.setIdCategory(String.valueOf(cursor.getInt(2)));
    // subCatBeans.setNamePartsService(cursor.getString(3));
    // subCatBeans.setNamereference(cursor.getString(4));
    // subCatBeans.setPriceValue(String.valueOf(cursor.getFloat(5)));
    // subCatBeans.setIdTaxRate(String.valueOf(cursor.getInt(8)));
    // subCatBeans.setFlagSerializable(String.valueOf(cursor
    // .getInt(10)));
    //
    // String numberOfpices = getNumberOfPices(
    // String.valueOf(cursor.getInt(1)), idIntervention);
    //
    // subCatBeans.setNoOfPiece(numberOfpices);
    //
    // subcategoryList.add(subCatBeans);
    //
    // }
    // cursor.close();
    // stmt.close();
    // connDao.commit();
    // } catch (Exception e) {
    // e.printStackTrace();
    // }
    // return subcategoryList;
    // }

    /**
     * fetch the parts & service, reference & price for invoice & parts and
     * service list
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getAllPartsAndService(
            String idIntervention) {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<InventoryItemBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT TREF_PIECES.ID_PIECE,"
                    + "TREF_PIECES.NM_PIECE,"
                    + "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE,"
                    + "TREF_PIECES.CD_PRODUIT,"
                    + "TREF_PIECES.PRIX_PIECE,"
                    + "TREF_PIECES.FL_SERIALIZABLE,"
                    + "TREF_PIECES.ID_TAXRATE, "
                    + "T_STOCK_PIECES.QUANTITY, "
                    + "TREF_PIECES.FL_TRACK_STOCK,TREF_PIECES.DESCRIPTION "
                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                    + "LEFT OUTER JOIN T_STOCK_PIECES ON TREF_PIECES.ID_PIECE = T_STOCK_PIECES.ID_PIECE "
                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                    + "AND TREF_PIECES.ID_CATEGORIE_PIECE=TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
//                InventoryItemBeans subCatBeans = new InventoryItemBeans();
//                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
//                subCatBeans.setPartsService(cursor.getString(2));
//                subCatBeans.setCategory(cursor.getString(3));
//                subCatBeans.setReference(cursor.getString(4));
//                subCatBeans.setCostOfItem(cursor.getDouble(5));
//                subCatBeans.setIsSerializable(cursor.getInt(6));
//                subCatBeans.setIdTaxRate(cursor.getInt(7));
//                subCatBeans.setNoOfPieces(String.valueOf(cursor.getInt(8)));
//                subCatBeans.setIsTracked(cursor.getInt(9));
//                subcategoryList.add(subCatBeans);
                InventoryItemBeans subCatBeans = new InventoryItemBeans(String.valueOf(cursor.getInt(1)),
                        cursor.getString(4), cursor.getString(3), cursor.getString(2),
                        cursor.getInt(6), cursor.getDouble(5), String.valueOf(cursor.getInt(8)),
                        cursor.getInt(7), cursor.getInt(9), cursor.getString(10));

                Logger.log(TAG, "PARTS_ALL_LIST category name is======>" + cursor.getString(3));
                subcategoryList.add(subCatBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Logger.log("Parts>>>>>>>>>>>>>", subcategoryList.size() + "");

        return subcategoryList;
    }

    /**
     * fetch the parts & service, reference & price for invoice & parts and
     * service list
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> getStockPartsAndService(
            String idIntervention) {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<InventoryItemBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT TREF_PIECES.ID_PIECE,"
                    + "TREF_PIECES.NM_PIECE,"
                    + "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE,"
                    + "TREF_PIECES.CD_PRODUIT,"
                    + "TREF_PIECES.PRIX_PIECE,"
                    + "TREF_PIECES.FL_SERIALIZABLE,"
                    + "TREF_PIECES.ID_TAXRATE, "
                    + "T_STOCK_PIECES.QUANTITY, "
                    + "TREF_PIECES.FL_TRACK_STOCK,TREF_PIECES.DESCRIPTION "
                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE,T_STOCK_PIECES "
                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                    + "AND TREF_PIECES.ID_PIECE = T_STOCK_PIECES.ID_PIECE "
                    + "AND TREF_PIECES.ID_CATEGORIE_PIECE=TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                    + "AND T_STOCK_PIECES.QUANTITY > 0 " +
                    "AND TREF_PIECES.FL_TRACK_STOCK = 1";


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(cursor.getInt(1)));
                subCatBeans.setPartsService(cursor.getString(2));
                subCatBeans.setCategory(cursor.getString(3));
                subCatBeans.setReference(cursor.getString(4));
                subCatBeans.setCostOfItem(cursor.getDouble(5));
                subCatBeans.setIsSerializable(cursor.getInt(6));
                subCatBeans.setIdTaxRate(cursor.getInt(7));
                subCatBeans.setNoOfPieces(String.valueOf(cursor.getInt(8)));
                subCatBeans.setIsTracked(cursor.getInt(9));
                subCatBeans.setDescription(cursor.getString(10));
                subcategoryList.add(subCatBeans);

                Logger.log(TAG, "PARTS_ALL_LIST category name is======>" + cursor.getString(3));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Logger.log("Parts>>>>>>>>>>>>>", subcategoryList.size() + "");

        return subcategoryList;
    }

    /**
     * get the json value for custom field in intervention
     *
     * @param idInterv
     * @return
     */
    public synchronized Vector<CustomFieldsByVal> getCFForIntervention(String idInterv) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        int id;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            id = jsonObject
                                    .getInt(KEYS.CustomField.ID_CUSTOM_FIELD);
                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value) && !value.equalsIgnoreCase("null")) {
                                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                                        id, "", label, "", value, 0);
                                CustomFields.add(listCustomFields);
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            Collections.sort(CustomFields);

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;

    }

    /**
     * get the json value for custom field in client
     *
     * @return
     */
    public synchronized Vector<CustomFieldsByVal> getCFForClient(int idClient) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_CLIENTS WHERE ID_CLIENT = '"
                    + idClient + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        int id;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            id = jsonObject
                                    .getInt(KEYS.CustomField.ID_CUSTOM_FIELD);
                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value) && !value.equalsIgnoreCase("null")) {
                                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                                        id, "", label, "", value, 0);
                                CustomFields.add(listCustomFields);
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            Collections.sort(CustomFields);

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;

    }

    /**
     * get the json value for custom field in client
     *
     * @return
     */
    public synchronized Vector<CustomFieldsByVal> getCFForClientDetail(int idClient) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_CLIENTS WHERE  DT_SUPPR IS NULL AND ID_CLIENT = '"
                    + idClient + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        int id;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            id = jsonObject
                                    .getInt(KEYS.CustomField.ID_CUSTOM_FIELD);
                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value) && !value.equalsIgnoreCase("null")) {
                                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                                        id, "", label, "", value, 0);
                                CustomFields.add(listCustomFields);
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            Collections.sort(CustomFields);

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;

    }

    /**
     * get the json value for custom field in site
     *
     * @return
     */
    public synchronized Vector<CustomFieldsByVal> getCFForSite(int idSite) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT = '"
                    + idSite + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        int id;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            id = jsonObject
                                    .getInt(KEYS.CustomField.ID_CUSTOM_FIELD);
                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value) && !value.equalsIgnoreCase("null")) {
                                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                                        id, "", label, "", value, 0);
                                CustomFields.add(listCustomFields);
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            Collections.sort(CustomFields);

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;

    }

    /**
     * get the json value for custom field in equipment
     *
     * @return
     */
    public synchronized Vector<CustomFieldsByVal> getCFForEquip(int idEquip) {
        Vector<CustomFieldsByVal> CustomFields = new Vector<CustomFieldsByVal>();

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_EQUIPEMENTS_CLIENTS WHERE ID_EQUIPEMENT_CLIENT = '"
                    + idEquip + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        int id;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            id = jsonObject
                                    .getInt(KEYS.CustomField.ID_CUSTOM_FIELD);
                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value) && !value.equalsIgnoreCase("null")) {
                                CustomFieldsByVal listCustomFields = new CustomFieldsByVal(
                                        id, "", label, "", value, 0);
                                CustomFields.add(listCustomFields);
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            Collections.sort(CustomFields);

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return CustomFields;

    }

    /**
     * Gets the debut time of the job.
     *
     * @param idIntervention
     * @return
     */
    public String getDebutTime(String idIntervention) {
        String jobStartStopTime = null;
        String query;

        try {

            query = "SELECT DT_DEBUT FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            PreparedStatement preparedStatement = connDao.prepareStatement(query);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                jobStartStopTime = resultSet.getString(1);
            }
            resultSet.close();
            preparedStatement.close();
            connDao.commit();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return jobStartStopTime;
    }

    /**
     * Update the intervention id and date used of the serial number when added
     * to parts & services.
     *
     * @return
     */
    public synchronized boolean updatePieceSerial(String idInterv, String dateUsed,
                                                  String idPieceSerial) {
        boolean result;
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PIECE_SERIALS SET ID_INTERVENTION = ?," +
                            "DT_USED = ? WHERE ID_PIECE_SERIAL = ?");

            ps.set(1, idInterv);
            ps.set(2, dateUsed);
            ps.set(3, idPieceSerial);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * fetch the parts & service, reference & price for invoice & parts and
     * service list
     *
     * @return
     */
    public synchronized ArrayList<InventoryDialogSerialNumber> getSelectedPiece(
            String idPiece, String idIntervention, String idStock) {
        ArrayList<InventoryDialogSerialNumber> selectedPiece = new ArrayList<InventoryDialogSerialNumber>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT SERIAL FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
                    + idStock + "' AND ID_PIECE = " + idPiece
                    + " AND ID_INTERVENTION = '" + idIntervention
                    + "' AND DT_USED IS NOT NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            int i = 0;
            while (cursor.next()) {
                InventoryDialogSerialNumber serialNo = new InventoryDialogSerialNumber();
                serialNo.setName(cursor.getString(1));
                serialNo.setId(i + 1);
                serialNo.setSelected(true);
                selectedPiece.add(serialNo);
                i++;
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return selectedPiece;
    }

    /**
     * Check the serial number is already selected or not.
     *
     * @param idPiece
     * @param idIntervention
     * @param idStock
     * @param idPieceSerial
     * @return
     */
    public synchronized boolean checkSelectedPiece(String idPiece, String idIntervention,
                                                   String idStock, String idPieceSerial) {
//        String query = "SELECT SERIAL FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
//                + idStock + "' AND ID_PIECE = " + idPiece
//                + " AND ID_INTERVENTION = '" + idIntervention
//                + "' AND ID_PIECE_SERIAL = '" + idPieceSerial
//                + "' AND DT_USED IS NOT NULL";

        String query = "SELECT SERIAL FROM T_PIECE_SERIALS WHERE ID_PIECE = " + idPiece
                + " AND ID_INTERVENTION = '" + idIntervention
                + "' AND ID_PIECE_SERIAL = '" + idPieceSerial
                + "' AND DT_USED IS NOT NULL";
        boolean result;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                result = true;
            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                result = false;
            }
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Gets the count of all jobs.
     *
     * @return the all jobs count
     */
    public synchronized String getAllJobsCount() {
        String query = "SELECT COUNT(ID_INTERVENTION) "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                + "AND "
                + "DT_DEB_PREV IS NOT NULL";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

//            resultSet.close();

//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count + "";
    }


    /**
     * Gets the count of all jobs.
     *
     * @param userId
     * @return the all jobs count
     */
    public synchronized String getAllJobsCountNew(int userId) {
        String query = "SELECT COUNT(ID_INTERVENTION) " +
                "FROM T_INTERVENTIONS " +
                "LEFT JOIN T_SITES_CLIENTS ON T_INTERVENTIONS.ID_SITE=T_SITES_CLIENTS.ID_SITE_CLIENT " +
                "LEFT JOIN T_CLIENTS ON T_INTERVENTIONS.ID_CLIENT=T_CLIENTS.ID_CLIENT " +
                "LEFT JOIN T_EQUIPEMENTS_CLIENTS ON T_INTERVENTIONS.ID_EQUIPEMENT=T_EQUIPEMENTS_CLIENTS.ID_EQUIPEMENT_CLIENT " +
                "WHERE ((T_INTERVENTIONS.ID_INTERVENTION IN " +
                "(SELECT ID_INTERVENTION FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION HAVING " +
                "date(MAX(DT_FIN)) <= CURRENT DATE )" +
                "AND T_INTERVENTIONS.CD_STATUT_INTERV=4) " +
                "OR " +
                "(T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                "WHERE date(DT_DEB_REAL) < CURRENT DATE " +
                "AND T_INTERVENTIONS.CD_STATUT_INTERV=4 AND T_INTERVENTIONS.ID_USER!=" + userId + " )) " +
                "OR (T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                "WHERE T_INTERVENTIONS.CD_STATUT_INTERV<=3 OR T_INTERVENTIONS.CD_STATUT_INTERV>=5))) " +
                "AND T_INTERVENTIONS.DT_DEB_PREV IS NOT NULL";


        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count + "";
    }

    /**
     * Fetches all jobs.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionByDate() {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND "
                    + "DT_DEB_PREV IS NOT NULL"
                    + " ORDER BY DT_DEB_PREV";
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                Logger.output(TAG, "t_interv : " + cursor.getInt(16));
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);


                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Logger.output(TAG, cursor.getString(4));

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllIntervention() {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND "
                    + "DT_DEB_PREV IS NOT NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);

                Logger.output(TAG, "addr_interv_ville" + encodeString(cursor.getBytes(8)));
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNearBy(String gpsX,
                                                                    String gpsY) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' " + "AND "
                    + "DT_DEB_PREV IS NOT NULL " +
                    "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> getLatLongAllJobs(String jobNumber) {
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + "))";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }

    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> getLatLongUpcomingJobs(String jobNumber) {
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                ",TREF_MODELE_RAPPORT " +
                "WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + ")) "
                + "AND T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }

    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> getLatLongCompletedJobs(String jobNumber, String lastDate) {
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                ",TREF_MODELE_RAPPORT " +
                "WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + ")) "
                + "AND T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND (CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND dateformat(DT_FIN_REAL,'yyyy-mm-dd') >='"
                + lastDate + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }

    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> getLatLongCompletedJobsByDate(String jobNumber, String lastDate) {
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                ",TREF_MODELE_RAPPORT " +
                "WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + ")) "
                + "AND T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND CD_STATUT_INTERV ='5' AND dateformat(DT_FIN_REAL,'yyyy-mm-dd')='"
                + lastDate + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }


    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> checkLatLongCurrentJobs(Date date, int userId, String jobNumber) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                ",TREF_MODELE_RAPPORT " +
                "WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + ")) "
                + "AND T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT " +
                "AND(" +
                "("
                + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                currentDate + "')) AND ((CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB_NOT_STARTED1
                + ") OR (CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                + ")" +
                "OR " +
                "(" +
                "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                + dateOfToday
                + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                + userId +
                ")" +
                "OR " +
                "(" +
                "CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB__SUSPENDED
                + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                + currentDate + "'))" +
                ")" +
                "OR " +
                "(" +
                "T_INTERVENTIONS.ID_USER!=" + userId
                + " AND CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB__STARTED +
                ")" +
                "OR " +
                "(" +
                "T_INTERVENTIONS.ID_USER!=" + userId
                + " AND CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB__SUSPENDED
                + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                + currentDate + "'" +
                ")" +
                ")";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }

    /**
     * Check if the given job number is in REF_CUSTOMER, if not check with NO_INT_CUST. If the job number is present return the latitude and longitude.
     *
     * @return true, if successful
     * @author Previous Developer
     */
    public synchronized HashMap<String, String> getLatLongLateJobs(String jobNumber, int userId) {
        HashMap<String, String> hmLatLong = new HashMap<>();
        String sql_string = "SELECT GPS_POSX_INTERV,GPS_POSY_INTERV FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                ",TREF_MODELE_RAPPORT " +
                "WHERE ((REF_CUSTOMER='" + jobNumber + "') OR (NO_INT_CUST=" + jobNumber + ")) "
                + "AND T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND (" +
                "( (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                + KEYS.CurrentJobs.JOB_NOT_STARTED2
                + ") OR ("
                + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4" +
                ") OR (" +
                "T_INTERVENTIONS.ID_USER!=" + userId
                + " AND CD_STATUT_INTERV="
                + KEYS.CurrentJobs.JOB__SUSPENDED
                + " AND date(DT_DEB_REAL) < CURRENT DATE" +
                "))";


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                hmLatLong.put(KEYS.CurrentJobs.LON, cursor.getString(1));
                hmLatLong.put(KEYS.CurrentJobs.LAT, cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hmLatLong;
    }

    /**
     * get the json value for custom field in intervention
     *
     * @param idInterv
     * @return
     */
    public synchronized String getAllCFInterv(String idInterv) {
        String mCustomFields = null;

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value)) {
                                mCustomFields += " " + label + " " + value;
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return mCustomFields;

    }

    /**
     * get the json value for custom field in client
     *
     * @return
     */
    public synchronized String getAllCFClient(int idClient) {
        String mCustomFields = null;

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_CLIENTS WHERE ID_CLIENT = '"
                    + idClient + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value)) {
                                mCustomFields += " " + label + " " + value;
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return mCustomFields;

    }

    /**
     * get the json value for custom field in site
     *
     * @return
     */
    public synchronized String getAllCFSite(int idSite) {
        String mCustomFields = null;

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT = '"
                    + idSite + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value)) {
                                mCustomFields += " " + label + " " + value;
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return mCustomFields;

    }

    /**
     * get the json value for custom field in equipment
     *
     * @return
     */
    public synchronized String getAllCFEquip(int idEquip) {
        String mCustomFields = null;

        String jsonString = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT JSON_CF FROM T_EQUIPEMENTS_CLIENTS WHERE ID_EQUIPEMENT_CLIENT = '"
                    + idEquip + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                jsonString = cursor.getString(1);

                /*
                 * JSON parsing
                 */
                try {
                    if (!TextUtils.isEmpty(jsonString)) {
                        JSONArray jsonArray = new JSONArray(jsonString);
                        JSONObject jsonObject;
                        String label, value;
                        for (int i = 0; i < jsonArray.length(); i++) {
                            jsonObject = new JSONObject();

                            jsonObject = jsonArray.getJSONObject(i);

                            label = jsonObject
                                    .getString(KEYS.CustomField.LABEL_CUSTOM_FIELD);
                            value = jsonObject
                                    .getString(KEYS.CustomField.VALUE_CUSTOM_FIELD);

                            if (!TextUtils.isEmpty(value)) {
                                mCustomFields += " " + label + " " + value;
                            }
                        }
                    }
                } catch (JSONException e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();

            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return mCustomFields;

    }

    /**
     * Get all the families (both standard families and shared block) for a report.
     *
     * @param idModel  : id of the report model
     * @param idInterv : id of job
     * @return List of families
     */
    public synchronized Vector<Families> getAllFamiliesWithSB(int idModel, String idInterv) {
        Vector<Families> familyVector = new Vector<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor;
        PreparedStatement stmt;
        try {

            query = "SELECT a.ID_MODELE_FAMILLE,a.MIN,a.MAX,b.NM_MODELE_FAMILLE,b.ITERATION,b.POS,b.OBLIGATOIRE,c.FL_SHARED,b.ID_EQUIPEMENT_CLIENT" +
                    " FROM TREF_MODELE_BLOC a" +
                    " LEFT JOIN T_SAISIE_BLOC b ON" +
                    " a.ID_MODELE_FAMILLE = b.ID_MODELE_FAMILLE" +
                    " LEFT JOIN TREF_MODELE_FAMILLE c ON" +
                    " b.ID_MODELE_FAMILLE = c.ID_MODELE_FAMILLE" +
                    " WHERE a.ID_MODELE_RAPPORT = " + idModel +
                    " AND b.ID_INTERVENTION = '" + idInterv + "'" +
                    " ORDER BY b.POS ASC";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            int previousId = 0;
            int iterationCount = 1;
            while (cursor.next()) {
                Logger.output("WHOLE FAMILY -- >", "idModelReport " + idModel + " position " + cursor.getInt(6) + " minimum " + cursor.getInt(2) + " maximum " + cursor.getInt(3)
                        + "name " + encodeString(cursor.getBytes(4)) + " iteration " + cursor.getInt(5) + " flShared " + cursor.getInt(8) + " obligatoire : " + cursor.getInt(7) + " equipment id : " + cursor.getInt(9));

                Families family = new Families();
                family.setIdFamily(cursor.getInt(1));
                family.setMin(cursor.getInt(2));
                family.setMax(cursor.getInt(3));
                family.setNameFamily(encodeString(cursor.getBytes(4)));
                family.setIteration(cursor.getInt(5));
                family.setPosition(cursor.getInt(6));
                family.setObligatoire(cursor.getInt(7));
                family.setIsSharedBlock(cursor.getInt(8));
                family.setIdEquip(cursor.getInt(9));

                //check if there is repetive item of same idModelFamille, then add the count of occurence.
                int flShared = cursor.getInt(8);
                if (flShared == 1) {
                    int currentId = cursor.getInt(1);
                    if (previousId == currentId) {
                        iterationCount++;
                    } else {
                        iterationCount = 1;
                    }
                    previousId = currentId;
                }

                family.setIterationCount(iterationCount);

                familyVector.add(family);
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        }
        return familyVector;
    }

    public synchronized Vector<Families> getSBCategory(String idInterv) {
        Vector<Families> familyVector = new Vector<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;
        try {

            query = "SELECT b.ID_MODELE_FAMILLE,m.MIN,m.MAX,b.NM_MODELE_FAMILLE," +
                    "b.ITERATION,b.POS,b.OBLIGATOIRE," +
                    "f.FL_SHARED,b.ID_EQUIPEMENT_CLIENT" +
                    " FROM T_SAISIE_BLOC b " +
                    "LEFT JOIN TREF_MODELE_BLOC m" +
                    " ON b.ID_MODELE_RAPPORT=m.ID_MODELE_RAPPORT" +
                    " AND b.ID_MODELE_FAMILLE=m.ID_MODELE_FAMILLE " +
                    "LEFT JOIN TREF_MODELE_FAMILLE f" +
                    " ON b.ID_MODELE_FAMILLE=f.ID_MODELE_FAMILLE" +
                    " WHERE ID_INTERVENTION='" + idInterv + "'" + " " +
                    "ORDER BY b.POS, b.ITERATION";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            int previousId = 0;
            int iterationCount = 1;
            while (cursor.next()) {
                Logger.output("WHOLE FAMILY -- >", "idModelReport " + cursor.getInt(1) + " position " + cursor.getInt(6) + " minimum " + cursor.getInt(2) + " maximum " + cursor.getInt(3)
                        + "name " + encodeString(cursor.getBytes(4)) + " iteration " + cursor.getInt(5) + " flShared " + cursor.getInt(8) + " obligatoire : " + cursor.getInt(7) + " equipment id : " + cursor.getInt(9));

                Families family = new Families();
                family.setIdFamily(cursor.getInt(1));
                family.setMin(cursor.getInt(2));
                family.setMax(cursor.getInt(3));
                family.setNameFamily(encodeString(cursor.getBytes(4)));
                family.setIteration(cursor.getInt(5));
                family.setPosition(cursor.getInt(6));
                family.setObligatoire(cursor.getInt(7));
                family.setIsSharedBlock(cursor.getInt(8));
                family.setIdEquip(cursor.getInt(9));

                //check if there is repetive item of same idModelFamille, then add the count of occurence.
                int flShared = cursor.getInt(8);
                if (flShared == 1) {
                    int currentId = cursor.getInt(1);
                    if (previousId == currentId) {
                        iterationCount++;
                    } else {
                        iterationCount = 1;
                    }
                    previousId = currentId;
                }

                family.setIterationCount(iterationCount);

                familyVector.add(family);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return familyVector;
    }

    /**
     * Gets the highest iteration value for a shared block.
     *
     * @param idFamily : id of the family
     * @return iteration
     */
    public int getLastSBIteration(int idFamily, String idInterv) {
        int highestIteration = 0;
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {
            query = "SELECT MAX(ITERATION) FROM T_SAISIE_BLOC" +
                    " WHERE ID_MODELE_FAMILLE = " + idFamily +
                    " AND ID_INTERVENTION ='" + idInterv + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                highestIteration = cursor.getInt(1);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return highestIteration;
    }

    /**
     * Gets the last position of a report in job
     *
     * @param idReport : id of the report
     * @return iteration
     */
    public synchronized int getLastPosition(int idReport, String idInterv) {
        int lastPos = 0;
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {
            query = "SELECT MAX(POS) FROM T_SAISIE_BLOC" +
                    " WHERE ID_MODELE_RAPPORT = " + idReport +
                    " AND ID_INTERVENTION ='" + idInterv + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                lastPos = cursor.getInt(1);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return lastPos;
    }

    /**
     * Gets the count of a shared block.
     *
     * @return the shared block counts
     */
    public synchronized int getSharedBlockCount(int idFamily, String idInterv) {
        int count = 0;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT COUNT(*) FROM T_SAISIE_BLOC" +
                    " WHERE ID_MODELE_FAMILLE = " + idFamily +
                    " AND ID_INTERVENTION ='" + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = cursor.getInt(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }

    /**
     * Gets list of shared block which are not assigned to the job.
     *
     * @param idInterv : id of intervention
     * @return ArrayList<SharedBlocks>
     */
    public synchronized ArrayList<SharedBlocks> getSBList(String idInterv) {
        ArrayList<SharedBlocks> listSB = new ArrayList<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;
        try {
//            query = "SELECT DISTINCT ID_MODELE_FAMILLE,NM_MODELE_FAMILLE FROM TREF_MODELE_FAMILLE" +
//                    " WHERE TREF_MODELE_FAMILLE.FL_SHARED = 1" +
//                    " AND DT_SUPPR IS NULL AND FL_PUBLIE = 1 ORDER BY NM_MODELE_FAMILLE";

//            query = "SELECT DISTINCT f.ID_MODELE_FAMILLE,f.NM_MODELE_FAMILLE FROM TREF_MODELE_BLOC b, TREF_MODELE_FAMILLE f" +
//                    " WHERE f.FL_SHARED = 1" +
//                    " AND b.DT_SUPPR IS NULL AND f.FL_PUBLIE = 1 ORDER BY f.NM_MODELE_FAMILLE";

            query = "SELECT b.ID_MODELE_FAMILLE, b.NM_MODELE_FAMILLE FROM TREF_MODELE_FAMILLE b " +
                    "WHERE b.FL_SHARED = 1 " +
                    "AND b.FL_PUBLIE = 1 " +
                    "AND b.DT_SUPPR is NULL " +
                    "AND b.ID_MODELE_FAMILLE NOT IN (" +
                    "SELECT DISTINCT ID_MODELE_FAMILLE " +
                    "FROM T_SAISIE_BLOC WHERE DT_SUPPR IS NULL " +
                    "AND ID_INTERVENTION = '" + idInterv +
                    "') ORDER BY b.NM_MODELE_FAMILLE";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                SharedBlocks sharedBlock = new SharedBlocks();
                int idFamily = cursor.getInt(1);
                String nameFamily = encodeString(cursor.getBytes(2));
//                int idEquip = cursor.getInt(3);
//                int obligatoire = cursor.getInt(4);

                sharedBlock.setIdBlock(idFamily);
                sharedBlock.setBlockName(nameFamily);
//                sharedBlock.setIdEquip(idEquip);
//                sharedBlock.setObligatoire(obligatoire);
                listSB.add(sharedBlock);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listSB;
    }

    /**
     * Update value. - Version 4.2 (Rapport v2)
     *
     * @param idInterv  the id interv
     * @param idFamille the id famille
     * @return the all item
     */
//    @SuppressLint("UseSparseArrays")
//    public HashMap<Integer, Item> getAllItem(String idInterv, int idFamille, int iteration, String dateCreateIntervention) {
//
////        DATEFORMAT(DT_FIN,'yyyy-mm-dd')
//
//        HashMap<Integer, Item> map = new HashMap<Integer, Item>();
//        String query;
//        try {
//            query = "SELECT TREF_MODELE_ITEM.ID_MODELE_ITEM,"
//                    + "ID_MODELE_FAMILLE,"
//                    + "ID_TYPE_ITEM,"
//                    + "NM_MODELE_ITEM,"
//                    + "OBLIGATOIRE,"
//                    + "CASE WHEN CONDITIONNE_PAR ='-1' THEN 0 else CONDITIONNE_PAR END,"
//                    + "VALEUR_CONDITION,"
//                    + "CASE WHEN val IS NULL OR val='' THEN 0 ELSE 1 END AS IS_SAISI,"
//                    + "val, "
//                    + "comItem, "
//                    + "TRIE_CONDITION_ITEM, "
//                    + "VALEUR_DEFAUT, "
//                    + "IMAGE, "
//                    + "flReserve, "
//                    + "iteration "
//                    + "FROM "
//                    + "TREF_MODELE_ITEM LEFT OUTER JOIN "
//                    + "(SELECT ID_MODELE_ITEM,VALEUR_ITEM,COMMENTAIRE_ITEM,FL_RESERVE,ITERATION FROM T_SAISIE_RAPPORT WHERE ID_INTERVENTION='"
//                    + idInterv
//                    + "'" +
//                    " AND ITERATION =" + iteration + ") AS newTab(idItem,val,comItem,flReserve,iteration) ON ( TREF_MODELE_ITEM.ID_MODELE_ITEM=newTab.idItem ) "
//                    + "WHERE ID_MODELE_FAMILLE=" + idFamille
//                    + " AND ((DATEFORMAT(DT_CREATED,'yyyy-mm-dd HH:mm:ss:SSS')<'" + dateCreateIntervention + "')"
//                    + " AND (DT_SUPPR IS NULL OR (DATEFORMAT(DT_SUPPR ,'yyyy-mm-dd HH:mm:ss:SSS')>'" + dateCreateIntervention + "')))";
//
//            // + " ORDER BY NM_MODELE_ITEM ASC";
//            //Connection connection = getConnectionObj();
//            PreparedStatement stmt = getConnectionObj().prepareStatement(query);
//
//            ResultSet cursor = stmt.executeQuery();
//
//            ArrayList<Item> tempItemList = new ArrayList<Item>();
//            tempItemList.clear();
//
////            getItemFromTMI(idFamille, idInterv);
//
//            while (cursor.next()) {
//                byte[] img = null;
//
//                // New changes.
//                /**
//                 * if any exception occured while getting values from cursor.
//                 * Break the while loop. (Previously, No rows at cursor
//                 * exception occured.)
//                 */
//                try {
//                    if (cursor.getInt(3) == 8) {
//                        String comment = "PIC_" + cursor.getInt(1);
//                        img = getPhotoImage(comment, idInterv, iteration);
//                    }
//
//                    Item item = new Item(cursor.getInt(1), cursor.getInt(2),
//                            cursor.getInt(3), encodeString(cursor.getBytes(4)),
//                            cursor.getInt(5), cursor.getInt(6),
//                            encodeString(cursor.getBytes(7)), cursor.getInt(8),
//                            encodeString(cursor.getBytes(9)),
//                            encodeString(cursor.getBytes(10)),
//                            cursor.getInt(11),
//                            encodeString(cursor.getBytes(12)),
//                            cursor.getBytes(13), cursor.getInt(14), img, iteration);
//
//                    Logger.output("item name  ", item.getNomItem() + " iteration : " + cursor.getInt(15) + " family iteration : " + iteration);
//                    map.put(cursor.getInt(1), item);
//
//                    tempItemList.add(item);
//                } catch (Exception e) {
//                    Logger.printException(e);
//                    break; // break the while loop,
//                }
//
//            }
//
//            Collections.sort(tempItemList, new Comparator<Item>() {
//
//                @Override
//                public int compare(Item one, Item another) {
//                    return one.getNomItem().compareTo(another.getNomItem());
//                }
//            });
//
//            for (int i = 0; i < tempItemList.size(); i++) {
//                map.put(tempItemList.get(i).getIdItem(), tempItemList.get(i));
//            }
//
//            tempItemList = null;
//            cursor.close();
//            stmt.close();
//            //connection.commit();
//            //connection.release();
//        } catch (Exception e) {
//            Logger.printException(e);
//        }
//        return map;
//    }

    /**
     * Update value. - Version 4.2 (Rapport v2)
     *
     * @param idInterv  the id interv
     * @param idFamille the id famille
     * @return the all item
     */
    @SuppressLint("UseSparseArrays")
    public synchronized HashMap<Integer, Item> getAllItem(String idInterv, int idFamille, int iteration) {

//        DATEFORMAT(DT_FIN,'yyyy-mm-dd')

        HashMap<Integer, Item> map = new HashMap<Integer, Item>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT distinct i.ID_MODELE_ITEM,"
                    + "i.ID_MODELE_FAMILLE,"
                    + "i.ID_TYPE_ITEM,"
                    + "i.NM_MODELE_ITEM,"
                    + "i.OBLIGATOIRE,"
                    + "CASE WHEN i.CONDITIONNE_PAR ='-1' " +
                    "THEN 0 else i.CONDITIONNE_PAR END,"
                    + "i.VALEUR_CONDITION,"
                    + "CASE WHEN newTab.val IS NULL OR " +
                    "val='' THEN 0 ELSE 1 END AS IS_SAISI,"
                    + "newTab.val, "
                    + "newTab.comItem, "
                    + "i.TRIE_CONDITION_ITEM, "
                    + "i.VALEUR_DEFAUT, "
                    + "i.IMAGE, "
                    + "newTab.flReserve, "
                    + "newTab.iteration, "
                    + "b.DT_CREATED, "
                    + "i.DT_CREATED "
                    + "FROM "
                    + "T_SAISIE_BLOC b JOIN "
                    + "TREF_MODELE_ITEM i "
                    + "ON b.ID_MODELE_FAMILLE=i.ID_MODELE_FAMILLE "
                    + "LEFT OUTER JOIN "
                    + "(SELECT r.ID_MODELE_ITEM,r.VALEUR_ITEM," +
                    "r.COMMENTAIRE_ITEM,r.FL_RESERVE,r.ITERATION " +
                    "FROM T_SAISIE_RAPPORT r WHERE r.ID_INTERVENTION='"
                    + idInterv
                    + "'" +
                    " AND r.ITERATION =" + iteration + ") AS " +
                    "newTab(idItem,val,comItem,flReserve,iteration)" +
                    " ON ( i.ID_MODELE_ITEM=newTab.idItem ) "
                    + "WHERE i.ID_MODELE_FAMILLE=" + idFamille
                    + "AND b.ID_INTERVENTION ='" + idInterv
                    + "' AND ((b.DT_CREATED > i.DT_CREATED " +
                    "AND (i.DT_SUPPR is NULL OR i.DT_SUPPR > b.DT_CREATED ))) "
                    + "ORDER BY i.TRIE_CONDITION_ITEM";

            // + " ORDER BY NM_MODELE_ITEM ASC";

            Logger.output(TAG, "item query --> " + query);

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            ArrayList<Item> tempItemList = new ArrayList<Item>();
            tempItemList.clear();

//            getItemFromTMI(idFamille, idInterv);

            while (cursor.next()) {
                byte[] img = null;

                // New changes.
                /**
                 * if any exception occured while getting values from cursor.
                 * Break the while loop. (Previously, No rows at cursor
                 * exception occured.)
                 */
                try {
                    if (cursor.getInt(3) == 8) {
                        String comment = "PIC_" + cursor.getInt(1);
                        img = getPhotoImage(comment, idInterv, iteration);
                    }

                    Item item = new Item(cursor.getInt(1), cursor.getInt(2),
                            cursor.getInt(3), encodeString(cursor.getBytes(4)),
                            cursor.getInt(5), cursor.getInt(6),
                            encodeString(cursor.getBytes(7)), cursor.getInt(8),
                            encodeString(cursor.getBytes(9)),
                            encodeString(cursor.getBytes(10)),
                            cursor.getInt(11),
                            encodeString(cursor.getBytes(12)),
                            cursor.getBytes(13), cursor.getInt(14), img, iteration);

//                    Logger.output("item name  ", item.getNomItem() + " iteration : " + cursor.getInt(15) + " family iteration : " + iteration + "bloc dt create " + cursor.getString(16)
//                            + "item dt create " + cursor.getString(17));
                    map.put(cursor.getInt(1), item);

                    tempItemList.add(item);
                } catch (Exception e) {
                    Logger.printException(e);
                    break; // break the while loop,
                }

            }

            Collections.sort(tempItemList, new Comparator<Item>() {

                @Override
                public int compare(Item one, Item another) {
                    return one.getNomItem().compareTo(another.getNomItem());
                }
            });

            for (int i = 0; i < tempItemList.size(); i++) {
                map.put(tempItemList.get(i).getIdItem(), tempItemList.get(i));
            }

            tempItemList = null;
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return map;
    }

    /**
     * Update value. - Version 4.2 (Rapport v2)
     *
     * @param idInterv  the id interv
     * @param idFamille the id famille
     * @return the all item
     */
    @SuppressLint("UseSparseArrays")
    public synchronized HashMap<Integer, Item> getItemsForPreview(String idInterv, int idFamille, int iteration) {

//        DATEFORMAT(DT_FIN,'yyyy-mm-dd')

        HashMap<Integer, Item> map = new HashMap<Integer, Item>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT distinct i.ID_MODELE_ITEM,"
                    + "i.ID_MODELE_FAMILLE,"
                    + "i.ID_TYPE_ITEM,"
                    + "i.NM_MODELE_ITEM,"
                    + "i.OBLIGATOIRE,"
                    + "CASE WHEN i.CONDITIONNE_PAR ='-1' THEN 0 else i.CONDITIONNE_PAR END,"
                    + "i.VALEUR_CONDITION,"
                    + "CASE WHEN newTab.val IS NULL OR val='' THEN 0 ELSE 1 END AS IS_SAISI,"
                    + "newTab.val, "
                    + "newTab.comItem, "
                    + "i.TRIE_CONDITION_ITEM, "
                    + "i.VALEUR_DEFAUT, "
                    + "i.IMAGE, "
                    + "newTab.flReserve, "
                    + "newTab.iteration, "
                    + "b.DT_CREATED, "
                    + "i.DT_CREATED, "
                    + "i.FL_PRIVATE "
                    + "FROM "
                    + "T_SAISIE_BLOC b JOIN "
                    + "TREF_MODELE_ITEM i "
                    + "ON b.ID_MODELE_FAMILLE=i.ID_MODELE_FAMILLE "
                    + "LEFT OUTER JOIN "
                    + "(SELECT r.ID_MODELE_ITEM,r.VALEUR_ITEM,r.COMMENTAIRE_ITEM,r.FL_RESERVE,r.ITERATION FROM T_SAISIE_RAPPORT r WHERE r.ID_INTERVENTION='"
                    + idInterv
                    + "'" +
                    " AND r.ITERATION =" + iteration + ") AS newTab(idItem,val,comItem,flReserve,iteration) ON ( i.ID_MODELE_ITEM=newTab.idItem ) "
                    + "WHERE i.ID_MODELE_FAMILLE=" + idFamille
                    + "AND b.ID_INTERVENTION ='" + idInterv
                    + "' AND ((b.DT_CREATED > i.DT_CREATED AND (i.DT_SUPPR is NULL OR i.DT_SUPPR > b.DT_CREATED ))) "
                    + "ORDER BY i.TRIE_CONDITION_ITEM";

            // + " ORDER BY NM_MODELE_ITEM ASC";

            Logger.output(TAG, "item query --> " + query);

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            ArrayList<Item> tempItemList = new ArrayList<Item>();
            tempItemList.clear();

//            getItemFromTMI(idFamille, idInterv);

            while (cursor.next()) {
                byte[] img = null;

                // New changes.
                /**
                 * if any exception occured while getting values from cursor.
                 * Break the while loop. (Previously, No rows at cursor
                 * exception occured.)
                 */
                try {
                    if (cursor.getInt(3) == 8) {
                        String comment = "PIC_" + cursor.getInt(1);
                        img = getPhotoImage(comment, idInterv, iteration);
                    }

                    Item item = new Item(cursor.getInt(1), cursor.getInt(2),
                            cursor.getInt(3), encodeString(cursor.getBytes(4)),
                            cursor.getInt(5), cursor.getInt(6),
                            encodeString(cursor.getBytes(7)), cursor.getInt(8),
                            encodeString(cursor.getBytes(9)),
                            encodeString(cursor.getBytes(10)),
                            cursor.getInt(11),
                            encodeString(cursor.getBytes(12)),
                            cursor.getBytes(13), cursor.getInt(14), img, iteration, cursor.getInt(18));

//                    Logger.output("item name  ", item.getNomItem() + " iteration : " + cursor.getInt(15) + " family iteration : " + iteration + "bloc dt create " + cursor.getString(16)
//                            + "item dt create " + cursor.getString(17));
                    map.put(cursor.getInt(1), item);

                    tempItemList.add(item);
                } catch (Exception e) {
                    Logger.printException(e);
                    break; // break the while loop,
                }

            }

            Collections.sort(tempItemList, new Comparator<Item>() {

                @Override
                public int compare(Item one, Item another) {
                    return one.getNomItem().compareTo(another.getNomItem());
                }
            });

            for (int i = 0; i < tempItemList.size(); i++) {
                map.put(tempItemList.get(i).getIdItem(), tempItemList.get(i));
            }

            tempItemList = null;
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return map;
    }

    public void getItems(int idFamily) throws Exception {
        Logger.output(TAG, "id family : " + idFamily);
        String query = "SELECT ID_MODELE_ITEM,NM_MODELE_ITEM,DT_CREATED FROM TREF_MODELE_ITEM WHERE ID_MODELE_FAMILLE=" + idFamily;
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = getConnectionObj().prepareStatement(query);

        ResultSet cursor = stmt.executeQuery();

        while (cursor.next()) {
            Logger.output(TAG, "name : " + cursor.getString(1) + "date : " + cursor.getString(3));
        }
        cursor.close();
        stmt.close();
        //connection.commit();
        connDao.commit();
        //connection.release();
    }

    public void getItemsaisie(int idFamily, String idInterv) throws Exception {
        Logger.output(TAG, "id family : " + idFamily + "idInterv : " + idInterv);
        String query = "SELECT NM_MODELE_FAMILLE,DT_CREATED FROM T_SAISIE_BLOC WHERE ID_MODELE_FAMILLE=" + idFamily + " AND ID_INTERVENTION ='" + idInterv + "'";
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = getConnectionObj().prepareStatement(query);

        ResultSet cursor = stmt.executeQuery();

        while (cursor.next()) {
            Logger.output(TAG, "name : " + cursor.getString(1) + "date : " + cursor.getString(2));
        }
        cursor.close();
        stmt.close();
        //connection.commit();
        connDao.commit();
        //connection.release();
    }

//    private void getItemFromTMI(int idFamily, String idInterv) {
//        String query = "SELECT ID_MODELE_ITEM FROM TREF_MODELE_ITEM WHERE DT_SUPPR IS NULL AND ID_MODELE_FAMILLE = " + idFamily;
//        //Connection connection = getConnectionObj();
//        PreparedStatement stmt = null;
//        try {
//            stmt = getConnectionObj().prepareStatement(query);
//            ResultSet cursor = stmt.executeQuery();
//            while (cursor.next()) {
//                getItemFromTSR(idInterv, cursor.getInt(1));
////                Logger.output("TREF_MODELE_ITEM", "idModelItem " + cursor.getInt(1));
//            }
//            cursor.close();
//            stmt.close();
//            //connection.commit();
//            //connection.release();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//    }
//
//    private void getItemFromTSR(String idInterv, int idItem) {
//        String query = "SELECT ID_MODELE_ITEM FROM T_SAISIE_RAPPORT WHERE ID_MODELE_ITEM = " + idItem +
//                " AND ID_INTERVENTION = '" + idInterv + "'";
////        String query = "SELECT ID_MODELE_ITEM FROM T_SAISIE_RAPPORT WHERE ID_INTERVENTION = '" + idInterv+"'";
//        //Connection connection = getConnectionObj();
//        PreparedStatement stmt = null;
//        try {
//            stmt = getConnectionObj().prepareStatement(query);
//            ResultSet cursor = stmt.executeQuery();
//            while (cursor.next()) {
////                Logger.output("T_SAISIE_RAPPORT", "idModel " + cursor.getInt(1));
//            }
//            cursor.close();
//            stmt.close();
//            //connection.commit();
//            //connection.release();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }
//
//    }

    /**
     * Gets the item. Version 4.2 (Rapport v2)
     *
     * @param idInterv the id interv
     * @param idItem   the id item
     * @return the item
     */
    @SuppressLint("UseSparseArrays")
    public synchronized Item getItem(String idInterv, int idItem, int iteration) {

        Item item = new Item();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT TREF_MODELE_ITEM.ID_MODELE_ITEM,"
                    + "ID_MODELE_FAMILLE,"
                    + "ID_TYPE_ITEM,"
                    + "NM_MODELE_ITEM,"
                    + "OBLIGATOIRE,"
                    + "CASE WHEN CONDITIONNE_PAR ='-1' THEN 0 else CONDITIONNE_PAR END,"
                    + "VALEUR_CONDITION,"
                    + "CASE WHEN val IS NULL OR val='' THEN 0 ELSE 1 END AS IS_SAISI,"
                    + "val, "
                    + "comItem, "
                    + "TRIE_CONDITION_ITEM, "
                    + "VALEUR_DEFAUT, "
                    + "IMAGE, "
                    + "flReserve "
                    + "FROM "
                    + "TREF_MODELE_ITEM LEFT OUTER JOIN "
                    + "(SELECT ID_MODELE_ITEM,VALEUR_ITEM,COMMENTAIRE_ITEM,FL_RESERVE FROM T_SAISIE_RAPPORT WHERE ID_INTERVENTION='"
                    + idInterv + "'" +
                    " AND ITERATION =" + iteration + ") AS newTab(idItem,val,comItem,flReserve) ON ( TREF_MODELE_ITEM.ID_MODELE_ITEM=newTab.idItem ) "
                    + "WHERE ID_MODELE_ITEM=" + idItem
                    + " ORDER BY NM_MODELE_ITEM ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                item = new Item(cursor.getInt(1), cursor.getInt(2),
                        cursor.getInt(3), encodeString(cursor.getBytes(4)),
                        cursor.getInt(5), cursor.getInt(6),
                        encodeString(cursor.getBytes(7)), cursor.getInt(8),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)), cursor.getInt(11),
                        encodeString(cursor.getBytes(12)), cursor.getBytes(13),
                        cursor.getInt(14), iteration);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return item;
    }

    /**
     * Adds a new shared block
     *
     * @param idCustomer
     * @param idModelRapport
     * @param idFamily
     * @param idInterv
     * @param idEquip
     * @param iteration
     * @param nameItem
     * @param obligatoire
     * @param pos
     * @return
     */
    public synchronized boolean addSharedBlock(int idCustomer, int idModelRapport, int idFamily, String idInterv, int idEquip, int iteration, String nameItem, int obligatoire, int pos) {

        PreparedStatement ps = null;
        boolean result;
        try {

            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_SAISIE_BLOC VALUES(?,?,?,?,?,?,?,?,?,CURRENT TIMESTAMP)");
            ps.set(1, idCustomer);
            ps.set(2, idModelRapport);
            ps.set(3, idFamily);
            ps.set(4, toBinary(idInterv));
            ps.set(5, idEquip);
            ps.set(6, iteration);
            ps.set(7, nameItem);
            ps.set(8, obligatoire);
            ps.set(9, pos);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Deletes all the items for a shared block
     *
     * @param idFamily
     * @param idInterv
     * @param iteration
     * @return
     */
    public synchronized boolean deleteSBItems(int idFamily, String idInterv, int iteration) {
        int idItem;
        String query = "SELECT ID_MODELE_ITEM FROM TREF_MODELE_ITEM WHERE ID_MODELE_FAMILLE = " + idFamily;
        boolean result = false;
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                idItem = cursor.getInt(1);

                //delete photo and signature if exist
                String photoType = "PIC_" + idItem;
                String signType = "SIGN_" + idItem;
                deletePhotoImage(photoType, idInterv, iteration);
                deletePhotoImage(signType, idInterv, iteration);

                try {
                    executeDDL("DELETE FROM T_SAISIE_RAPPORT WHERE ID_INTERVENTION='"
                            + idInterv + "' AND ID_MODELE_ITEM =" + idItem + " AND ITERATION =" + iteration);
                } catch (Exception e) {
                    Logger.printException(e);
                    result = false;
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Deletes the shared block in a job
     *
     * @param idFamily  : id of the family
     * @param idInterv  : id of the job
     * @param iteration : iteration in the job
     * @return boolean value for the result
     */
    public synchronized boolean deleteSharedBlock(int idFamily, String idInterv, int iteration) {
        try {
            executeDDL("DELETE FROM T_SAISIE_BLOC WHERE ID_INTERVENTION='"
                    + idInterv + "' AND ID_MODELE_FAMILLE =" + idFamily + " AND ITERATION =" + iteration);
            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }

    }


    /**
     * Gets the list of clients by using the starting offset.
     *
     * @return the clients
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Client> getClientsByOffset(int offset) {
        ArrayList<Client> listClt = new ArrayList<Client>();

        String query;

        query = "SELECT TOP 25 START AT " + offset +
                " ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_CP,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT,REF_CUSTOMER FROM T_CLIENTS "
                + " ORDER BY NM_CLIENT";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }

                Client clt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)));

                Log.e("REFFERENCE","REG_REFERENCE IS>>>>>>>>>>"+encodeString(cursor.getBytes(10)));
                listClt.add(clt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        Logger.log("CLients>>>>>>>>>>>>>", listClt.size() + "");
        return listClt;

    }

    /**
     * Gets the list of clients by searching through name and city.
     *
     * @return the clients
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Client> getClientsSearch(int offset, String value) {
        ArrayList<Client> listClt = new ArrayList<Client>();

        String query;

        query = "SELECT TOP 25 START AT " + offset +
                " ID_CLIENT,NM_CLIENT,ADR_CLIENT_RUE,ADR_CLIENT_VILLE,ADR_CLIENT_CP,ADR_CLIENT_GLOBALE,ADR_CLIENT_COMPLEMENT,GPS_POSX_CLIENT,GPS_POSY_CLIENT,REF_CUSTOMER FROM T_CLIENTS "
                + "WHERE NM_CLIENT LIKE '%" + value + "%' OR ADR_CLIENT_VILLE LIKE '%" + value + "%' OR ADR_CLIENT_CP LIKE '%" + value + "%'OR REF_CUSTOMER LIKE '%" + value + "%' ORDER BY NM_CLIENT";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }

                Client clt = new Client(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)));
                listClt.add(clt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Logger.output(TAG, "search size : " + listClt.size());
//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        return listClt;

    }

    /**
     * Gets list of site from given offset
     *
     * @param offset
     * @return
     */
    public synchronized ArrayList<Client_Site_Bean> getSitesWithOffset(int offset) {

        ArrayList<Client_Site_Bean> listSite = new ArrayList<>();

        String query;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            query = "SELECT TOP 15 START AT " + offset +
                    " ID_SITE_CLIENT,NM_SITE,ADR_SITE_RUE,ADR_SITE_VILLE,ADR_SITE_CP,ADR_SITE_GLOBALE,ADR_SITE_COMPLEMENT,GPS_POSX_SITE,GPS_POSY_SITE,NM_CLIENT,ADR_SITE_VILLE,T_SITES_CLIENTS.ID_CLIENT,T_SITES_CLIENTS.REF_CUSTOMER " +
                    " FROM T_SITES_CLIENTS LEFT OUTER JOIN T_CLIENTS ON T_SITES_CLIENTS.ID_CLIENT=T_CLIENTS.ID_CLIENT" +
                    " ORDER BY NM_CLIENT";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
//                int siteCliendId = cursor.getInt(12);
//                if (getClientDetail(siteCliendId).size() != 0) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }
                Client_Site_Bean site = new Client_Site_Bean(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        cursor.getInt(12),
                        encodeString(cursor.getBytes(13)));
                listSite.add(site);
//                }

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listSite;

    }


    public class EquipmentFilter {
        public int offset = 1;
        public String searchText = "";

    }

    /**
     * method to fetch the parts & service, reference & price for inventory list
     *
     * @return
     */
    public synchronized ArrayList<Client_Site_EquipmnentBean> _equipmentList(EquipmentFilter filter) {
        int offset = filter.offset;
        ArrayList<Client_Site_EquipmnentBean> listEqp = new ArrayList<>();
        try {

            PreparedStatement stmt = _equipmentListQuery(filter, false);
            if (stmt == null) return listEqp;

            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {

                String mPostalCode = encodeString(rs.getBytes(6));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(rs.getBytes(5));
                } else {
                    mCityCp = encodeString(rs.getBytes(5));
                }

                if ((rs.getInt(8) > 0)
                        && (getSitesDetail(rs.getInt(8)).size() != 0)) {

                    Client_Site_EquipmnentBean eqp = new Client_Site_EquipmnentBean(
                            rs.getInt(1), encodeString(rs.getBytes(2)),
                            encodeString(rs.getBytes(4)),
                            encodeString(rs.getBytes(3)),
                            mCityCp, rs.getInt(7),
                            rs.getInt(8),
                            rs.getString(9), encodeString(rs.getBytes(10)));
                    listEqp.add(eqp);

                } else if ((rs.getInt(7) > 0)
                        && (getClientDetail(rs.getInt(7)).size() != 0)) {

                    Client_Site_EquipmnentBean eqp = new Client_Site_EquipmnentBean(
                            rs.getInt(1), encodeString(rs.getBytes(2)),
                            encodeString(rs.getBytes(4)),
                            encodeString(rs.getBytes(3)),
                            mCityCp, rs.getInt(7),
                            rs.getInt(8),
                            rs.getString(9), encodeString(rs.getBytes(10)));
                    listEqp.add(eqp);

                }
            }
            rs.close();
            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return listEqp;
    }

    public synchronized int _equipmentListCount(EquipmentFilter filter) {

        int count = 0;

        try {
            PreparedStatement stmt = _equipmentListQuery(filter, true);
            if (stmt == null) return count;

            ResultSet rs = stmt.executeQuery();
            rs.first();
            count = rs.getInt(1);
            rs.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
        }

        return count;

    }


    private PreparedStatement _equipmentListQuery(EquipmentFilter filter, boolean isCount) {

        //Setup Base Query
        String query = "SELECT TOP 15 START AT " + filter.offset +
                " eqp.ID_EQUIPEMENT_CLIENT," +
                " eqp.NM_EQUIPEMENT," +
                " c.NM_CLIENT," +
                " sc.NM_SITE," +
                " c.ADR_CLIENT_VILLE," +
                " c.ADR_CLIENT_CP," +
                " eqp.ID_CLIENT," +
                " eqp.ID_SITE_CLIENT," +
                " eqp.PUBLIC_LINK,"+
                " eqp.REF_CUSTOMER ";

        if (isCount) query = "SELECT count(*) ";

        query += " FROM T_EQUIPEMENTS_CLIENTS eqp" +
                " INNER JOIN T_CLIENTS c ON eqp.ID_CLIENT= c.ID_CLIENT" +
                " LEFT JOIN T_SITES_CLIENTS sc ON eqp.ID_SITE_CLIENT=sc.ID_SITE_CLIENT #WHERE#";


        String where = "";

        if (!TextUtils.isEmpty(filter.searchText)) {
            where += " WHERE ( c.NM_CLIENT LIKE :searchText ";
            where += " OR sc.NM_SITE LIKE :searchText";
            where += " OR eqp.NM_EQUIPEMENT LIKE :searchText";
            where += " OR c.ADR_CLIENT_VILLE LIKE :searchText";
            where += " OR c.ADR_CLIENT_CP = :searchTextRight";
            where += " OR eqp.REF_CUSTOMER LIKE :searchText";
            where += ") ";
        }


        query = query.replace("#WHERE#", where);

        //Order when not counting
        query += isCount ? "" : " ORDER BY NM_CLIENT ";
        ;

        Logger.log("Equipment Query ", query.replace(":searchText", "%" + filter.searchText + "%").replace(":searchTextRight", filter.searchText + "%"));

        try {

            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(filter.searchText)) {
                stmt.set("searchText", "%" + filter.searchText + "%");
                stmt.set("searchTextRight", filter.searchText + "%");
            }
            return stmt;

        } catch (Exception e) {

            e.printStackTrace();
            Logger.printException(e);
            return null;

        }
    }


    /**
     * Gets list of site from given offset & search value
     *
     * @param offset
     * @return
     */
    public synchronized ArrayList<Client_Site_Bean> getSitesSearch(int offset, String value) {

        ArrayList<Client_Site_Bean> listSite = new ArrayList<>();

        String query;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            query = "SELECT TOP 15 START AT " + offset +
                    " ID_SITE_CLIENT,NM_SITE,ADR_SITE_RUE,ADR_SITE_VILLE,ADR_SITE_CP,ADR_SITE_GLOBALE,ADR_SITE_COMPLEMENT,GPS_POSX_SITE,GPS_POSY_SITE,NM_CLIENT,ADR_SITE_VILLE,T_SITES_CLIENTS.ID_CLIENT,T_SITES_CLIENTS.REF_CUSTOMER " +
                    " FROM T_SITES_CLIENTS LEFT OUTER JOIN T_CLIENTS ON T_SITES_CLIENTS.ID_CLIENT=T_CLIENTS.ID_CLIENT" +
                    " WHERE T_CLIENTS.NM_CLIENT LIKE '%" + value + "%'" +
                    " OR T_SITES_CLIENTS.NM_SITE LIKE '%" + value + "%'" +
                    " OR T_SITES_CLIENTS.ADR_SITE_VILLE LIKE '%" + value + "%'" +
                    " OR T_SITES_CLIENTS.ADR_SITE_CP LIKE '%" + value + "%'" +
                    " OR T_SITES_CLIENTS.REF_CUSTOMER LIKE '%" + value + "%'" +
                    " ORDER BY NM_CLIENT";

            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
//                int siteCliendId = cursor.getInt(12);
//                if (getClientDetail(siteCliendId).size() != 0) {
                String mPostalCode = encodeString(cursor.getBytes(5));
                String mCityCp;
                if (!TextUtils.isEmpty(mPostalCode)) {
                    mCityCp = mPostalCode + " " + encodeString(cursor.getBytes(4));
                } else {
                    mCityCp = encodeString(cursor.getBytes(4));
                }
                Client_Site_Bean site = new Client_Site_Bean(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(3)),
                        mCityCp,
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        encodeString(cursor.getBytes(10)),
                        encodeString(cursor.getBytes(11)),
                        cursor.getInt(12),
                        encodeString(cursor.getBytes(13)));
                listSite.add(site);
//                }

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return listSite;

    }

    /**
     * Gets the total count of customers.
     *
     * @return the all jobs count
     */
    public synchronized int getCustomerCount() {
        String query = "SELECT COUNT(*) FROM T_CLIENTS";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

//            resultSet.close();

//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }

    /**
     * Gets the total count of sitez.
     *
     * @return the all jobs count
     */
    public synchronized int getSitesCount() {
        String query = "SELECT COUNT(*) FROM T_SITES_CLIENTS LEFT OUTER JOIN T_CLIENTS ON T_SITES_CLIENTS.ID_CLIENT=T_CLIENTS.ID_CLIENT";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }


    /**
     * Gets the search count of customers.
     *
     * @return the all jobs count
     */
    public synchronized int getCustomerSearchCount(String value) {
        String query = "SELECT COUNT(*) FROM T_CLIENTS"
                + " WHERE NM_CLIENT LIKE '%" + value + "%' OR ADR_CLIENT_VILLE LIKE '%" + value + "%' OR ADR_CLIENT_CP LIKE '%" + value + "%'";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

//            resultSet.close();

//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }

    /**
     * Gets the search count of sites.
     *
     * @return the all jobs count
     */
    public synchronized int getSiteSearchCount(String value) {
        String query = "SELECT COUNT(*) FROM T_SITES_CLIENTS LEFT OUTER JOIN T_CLIENTS ON T_SITES_CLIENTS.ID_CLIENT=T_CLIENTS.ID_CLIENT" +
                " WHERE T_CLIENTS.NM_CLIENT LIKE '%" + value + "%'" +
                " OR T_SITES_CLIENTS.NM_SITE LIKE '%" + value + "%'" +
                " OR T_SITES_CLIENTS.ADR_SITE_VILLE LIKE '%" + value + "%'" +
                " OR T_SITES_CLIENTS.ADR_SITE_CP LIKE '%" + value + "%'";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();

            count = resultSet.getInt(1);

//            resultSet.close();

//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }


    /**
     * Sets the Login time.
     *
     * @param userName the user name
     */
    public synchronized void clearPassword(String userName) {
        int idUser = getUserID();
        executeDDL("UPDATE T_USERS SET AUTH_TOKEN= NULL , AUTH_EXPIRY= NULL WHERE LOGIN_USER='" + userName + "' AND ID_USER = " + idUser);
    }

    /**
     * Get all the families for a report using TREF_MODELE_BLOC & TREF_MODELE_FAMILLE alone.
     *
     * @param idReport
     */
    public synchronized ArrayList<Families> getAllFamilies(int idReport) {
        Vector<Families> familyVector = new Vector<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;
        ArrayList<Families> familles = new ArrayList<>();

        try {

            query = "SELECT b.ID_MODELE_FAMILLE, m.NM_MODELE_FAMILLE, b.POS" +
                    " FROM TREF_MODELE_BLOC b LEFT JOIN TREF_MODELE_FAMILLE m ON b.ID_MODELE_FAMILLE = m.ID_MODELE_FAMILLE" +
                    " WHERE b.ID_MODELE_RAPPORT =" + idReport + " AND b.DT_SUPPR IS NULL" + " ORDER BY b.POS";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                Families famille = new Families();
                famille.setIdFamily(cursor.getInt(1));
                famille.setNameFamily(cursor.getString(2));
                famille.setPosition(cursor.getInt(3));

                familles.add(famille);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return familles;
    }

    /**
     * Update photo by id.
     *
     * @param idPhoto the id photo
     */
    public synchronized void updatePhoto(String idPhoto, byte[] image) {

        PreparedStatement ps = null;
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PHOTOS_PDA SET PHOTO_PDA = ? WHERE ID_PHOTO_PDA = ?");
            ps.set(2, idPhoto);
            ps.set(1, image);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Update photo by id.
     *
     * @param comment   comment of image
     * @param iteration iteration count
     * @param image     byte array f image
     */
    public synchronized void updatePhotoByComment(String idInterv, String comment, int iteration, byte[] image) {

        PreparedStatement ps = null;
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PHOTOS_PDA SET PHOTO_PDA = ? WHERE ID_INTERVENTION = ? AND COMMENTAIRE_PHOTO_PDA = ? AND ITERATION = ?");
            ps.set(1, image);
            ps.set(2, idInterv);
            ps.set(3, comment);
            ps.set(4, iteration);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Gets the photo by id.
     *
     * @param idInter the id inter
     * @param idPhoto
     * @return the photo by id
     */
    public synchronized byte[] getPhotoByIdPhoto(String idInter, String idPhoto) {
        String sql_string = "SELECT PHOTO_PDA FROM T_PHOTOS_PDA WHERE ID_INTERVENTION='"
                + idInter + "' AND ID_PHOTO_PDA='" + idPhoto + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        byte[] res = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                res = cursor.getBytes(1);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            res = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return res;
    }

    /**
     * Gets public link of site
     *
     * @param idSite the id site
     * @return the public link
     */
    public synchronized String getSitePublicLink(int idSite) {
        String publicLink = null;

        String sql_string = "SELECT PUBLIC_LINK FROM T_SITES_CLIENTS WHERE ID_SITE_CLIENT="
                + idSite;

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                publicLink = encodeString(cursor.getBytes(1));

            }
            cursor.close();
            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            publicLink = null;
        }
        return publicLink;
    }

    /**
     * Gets public link of equipment
     *
     * @param idEquipment the id site
     * @return the public link
     */
    public synchronized String getEquipmentPublicLink(int idEquipment) {
        String publicLink = null;

        String sql_string = "SELECT PUBLIC_LINK FROM T_EQUIPEMENTS_CLIENTS WHERE ID_EQUIPEMENT_CLIENT="
                + idEquipment;

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                publicLink = encodeString(cursor.getBytes(1));

            }
            cursor.close();
            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            publicLink = null;

        }
        return publicLink;
    }


    public synchronized double getInvoicePaymentOfReceivedRefunded(String id_remote) {

        double receivedAmount = 0.00f;
        double refundAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {
            //Connection connection = getConnectionObj();
            query = "SELECT SUM(RECEIVED) AS TOTAL FROM T_PAYMENTS WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                receivedAmount = cursor.getDouble(1);
                Logger.log("Amt", " receivedAmount: " + receivedAmount);
            }
//            cursor.close();       // query = "SELECT RECEIVED FROM T_PAYMENTS WHERE ID_REMOTE = '" + id_remote + "'";
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        try {
            //Connection connection = getConnectionObj();
            query = "SELECT SUM(REFUNDED) AS TOTAL FROM T_PAYMENTS WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                refundAmount = cursor.getDouble(1);
                Logger.log("Amt", " refundAmount: " + refundAmount);
            }
//            cursor.close();     // query = "SELECT RECEIVED FROM T_PAYMENTS WHERE ID_REMOTE = '" + id_remote + "'";
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return receivedAmount - refundAmount;
    }


    public synchronized Boolean getVal() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        boolean result = true;
        try {

            String query = "SELECT TOP 1000 START AT 1 * FROM TREF_PIECES INNER JOIN TREF_CATEGORIE_PIECE ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = TREF_PIECES.ID_CATEGORIE_PIECE WHERE TREF_PIECES.DT_SUPPR IS NULL ORDER BY TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE ASC,TREF_PIECES.NM_PIECE ASC";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                Logger.log("val", "cu1 " + cursor.getString(1));
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }


    /**
     * Getting data from CConection table
     *
     * @return
     */
    public synchronized ArrayList<CConectionsBeans> getDataFromCConnection() {

        ArrayList<CConectionsBeans> cConectionsBeansArrayList = new ArrayList<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {
            query = "SELECT * FROM C_CONNECTIONS";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                CConectionsBeans cConectionsBeans = new CConectionsBeans();

                cConectionsBeans.setIdConnection(cursor.getInt(1));
                cConectionsBeans.setJsonAuth(cursor.getString(2));
                cConectionsBeans.setJsonSettings(cursor.getString(3));
                cConectionsBeans.setFl_active(cursor.getBoolean(4));

                cConectionsBeansArrayList.add(cConectionsBeans);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        return cConectionsBeansArrayList;
    }


    /**
     * Insert values when invoice payment is success
     *
     * @param idRemote
     * @param recieved
     * @param chargeId
     * @return
     */
    public synchronized String insertTPaymentsTable(String idRemote,
                                                    String recieved, String chargeId) {

        String uniqueId = getUniqueId();

        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("INSERT INTO T_PAYMENTS (ID_PAYMENT,ID_REMOTE,MODE,RECEIVED,CHARGE_ID,DT_CREATED) VALUES (?,?,?,?,?,CURRENT TIMESTAMP)");

            ps.set(1, uniqueId);
            ps.set(2, idRemote);
            ps.set(3, "online");
            ps.set(4, Float.parseFloat(recieved));
            ps.set(5, chargeId);

            ps.execute();
            ps.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (ULjException e) {
            Logger.printException(e);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        return uniqueId;
    }

    /**
     * Insert values when invoice payment is success
     *
     * @param idPayment - unique ID that generated in TPayments table
     * @param idRemote
     * @param amount
     * @param chargeId
     */
    public synchronized void insertTPaymentsLog(String idPayment, String idRemote,
                                                String amount, String chargeId) {

        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("INSERT INTO T_PAYMENTS_LOG (ID_PAYMENT_LOG,ID_PAYMENT,ID_REMOTE,AMOUNT,DT_CREATED) VALUES (?,?,?,?,CURRENT TIMESTAMP)");

            ps.set(1, getUniqueId());
            ps.set(2, idPayment);
            ps.set(3, idRemote);
            ps.set(4, Float.parseFloat(amount));

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (ULjException e) {
            Logger.printException(e);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    // v48 tables and functionalites queries

    public synchronized Boolean checkIsClockInAvailable(int idUser) {

        Logger.log(TAG, "user id migrate is : " + idUser);

        int flTT = 0;

        String sql_string = "SELECT FL_TT FROM T_USERS WHERE ID_USER = " + idUser;

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                flTT = cursor.getInt(1);
                Logger.log(TAG, "Time tracker available status---->>" + flTT);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();


//            return true;

        } catch (Exception e) {
            Logger.log(TAG, "user id migrate is : excep  " + e);
            Logger.printException(e);
            flTT = 0;
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return flTT == 1;
    }

    /**
     * Gets the conge.
     *
     * @return the conge
     */
    public synchronized Vector<Conge> getCongeNewExceptClockInActivity() {
        Vector<Conge> Conges = new Vector<Conge>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE" +
                    " AND TREF_TYPE_CONGE.FL_CLOCK = 0" +
                    " AND TREF_TYPE_CONGE.FL_DRIVING = 0" +
                    " AND T_CONGE.DT_FIN IS NULL "
                    + "ORDER BY DT_DEBUT DESC";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String dt_deb_prev = null;
            while (cursor.next()) {
                if (dt_deb_prev == null) {
                    try {
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(3), currentDateFormat,
                                dedlineHeaderFormat);

                        Logger.log("Date DEbut if ", dt_deb_prev + "");
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    // Conge conge = new Conge(true,
                    // dt_deb_prev);
                    // Conges.add(conge);

                } else {
                    String tempDate = "";
                    try {
                        if (cursor.getString(4) != null)
                            tempDate = getHeaderDateWithRequiredPattern(
                                    cursor.getString(4), currentDateFormat,
                                    dedlineHeaderFormat);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    if (!dt_deb_prev.equals(tempDate)) {
                        // dt_deb_prev = tempDate;
                        // Conge conge = new Conge(true,
                        // dt_deb_prev);
                        // Logger.log("Date DEbut else", dt_deb_prev + "");
                        // Conges.add(conge);
                    }
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), "", String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                Conges.add(Conge);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {

            Log.i("--", "" + exc.toString());

        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return Conges;
    }

    /**
     * Gets the clock in to check clocked in but not clocked out.
     *
     * @return the conge
     */
    public synchronized Vector<Conge> getClockIn() {
        Vector<Conge> Conges = new Vector<Conge>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.FL_CLOCK = 1 AND T_CONGE.DT_FIN IS NULL ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), "", String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                Conges.add(Conge);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {

            Log.i("--", "" + exc.toString());

        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return Conges;
    }

    /**
     * used to update the end date time for Clocked out
     *
     * @param id
     * @param endDate
     */
    public synchronized boolean updateClockedOutEndTime(String id, String endDate) {

        boolean result;
        PreparedStatement ps = null;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_CONGE SET DT_FIN = ? WHERE ID_REMOTE = ?");
            ps.set(1, endDate);
            ps.set(2, id);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    // To get the ClockInActivity ID
    public synchronized UnavailabilityBeans getClockInActivity() {

        UnavailabilityBeans unavailabilityBeans = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_UNAVAILABLE = 0 AND FL_DRIVING = 0 AND FL_CLOCK = 1 ORDER BY NOM_TYPE_CONGE ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilityBeans;

    }

    // To get the intervention ID for pause/stop in home page
    public synchronized String getStartedInterventionIDToPauseStop(int idUser) {

        String interventionID = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getIntervID = "SELECT ID_INTERVENTION FROM T_INTERVENTIONS WHERE ID_USER = ? AND CD_STATUT_INTERV = 3";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getIntervID);

            stmt.set(1, idUser);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                interventionID = cursor.getString(1);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return interventionID;

    }

    // To check the activity is payable or not
    public synchronized boolean checkActivityOrDrivingIsPayable(int idTypeConge) {

        int isPayable = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getIntervID = "SELECT FL_PAYABLE FROM TREF_TYPE_CONGE WHERE ID_TYPE_CONGE = ?";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getIntervID);

            stmt.set(1, idTypeConge);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                isPayable = cursor.getInt(1);
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return isPayable == 1;

    }

    // To get the Driving ID details
    public synchronized UnavailabilityBeans getDrivingDetail() {

        UnavailabilityBeans unavailabilityBeans = null;

        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_UNAVAILABLE = 0 AND FL_DRIVING = 1 AND FL_CLOCK = 0 ORDER BY NOM_TYPE_CONGE ASC";
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        }

        return unavailabilityBeans;

    }

    public synchronized String addDrivingActivityAndReturnID(int unavailabilityType, String startDate, String endDate, String notesdesc) {

        int u = getUser().getId();
        String idUser = String.valueOf(u);
        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        try {

            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (ID_REMOTE,ID_TYPE_CONGE,ID_USER,DT_DEBUT,DT_FIN,NOTES )"
                    + "VALUES(?,?,?,?,?,?)");

            ps.set(1, uniqueId);
            ps.set(2, unavailabilityType);
            ps.set(3, idUser);
            ps.set(4, startDate);
            ps.set(5, endDate);
            ps.set(6, notesdesc);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            e.printStackTrace();
            uniqueId = null;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return uniqueId;
    }


    /**
     * Hitting web service in the case of hort or port is null
     *
     * @param domain
     */
    private synchronized void hitSyncServerInTheCaseOfNullHost(final String domain) {

        ApiInterface apiService =
                Apiclient.getClient().create(ApiInterface.class);

        Call<SyncService> call = apiService.synchronizeServer(domain);
        call.enqueue(new Callback<SyncService>() {
            @Override
            public void onResponse(Call<SyncService> call, Response<SyncService> response) {

                try {

                    // Saving Server, port, ssl from Response to Shared Preferences
                    SharedPref.setSyncStdServer(response.body().getStd().getServer(), context);
                    SharedPref.setSyncStdPort(response.body().getStd().getPort(), context);
                    SharedPref.setSyncStdSsl(response.body().getStd().getSsl(), context);

                    SharedPref.setSyncDebugServer(response.body().getDebug().getServer(), context);
                    SharedPref.setSyncDebugPort(response.body().getDebug().getPort(), context);
                    SharedPref.setSyncDebugSsl(response.body().getDebug().getSsl(), context);

                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

            @Override
            public void onFailure(Call<SyncService> call, Throwable t) {
//                        Logger.log("Sync", "Retrofit failure :" + t);
            }
        });
    }

    /**
     * used to update the start lat & lon for the driving activity
     *
     * @param id       : activity id
     * @param startLat : start latitued
     * @param startLon : start longitude
     */
    public synchronized boolean updateStartLatLon(String id, double startLat, double startLon) {
        PreparedStatement ps = null;
        boolean result;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_CONGE SET LAT_START = ?,LNG_START = ? WHERE ID_REMOTE = ?");
            ps.set(1, startLat);
            ps.set(2, startLon);
            ps.set(3, id);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * used to update the end date for unavailability when it is started withou
     * end time
     *
     * @param id
     * @param endDate
     */
    public synchronized boolean updateStopLatLonAndFinishDriving(String id, String endDate, double stopLat,
                                                                 double stopLon, Double distance) {
        PreparedStatement ps = null;
        boolean result;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_CONGE SET LAT_END = ?,LNG_END = ?,DT_FIN = ?,DISTANCE = ? WHERE ID_REMOTE = ?");
            ps.set(1, stopLat);
            ps.set(2, stopLon);
            ps.set(3, endDate);
            ps.set(4, distance.intValue());
            ps.set(5, id);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * To check whether the driving is started or not
     *
     * @return boolean value
     */
    public synchronized TravelActivity isDrivingStarted() {
        TravelActivity travelActivity = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT ID_REMOTE, TREF_TYPE_CONGE.ID_TYPE_CONGE, TREF_TYPE_CONGE.NOM_TYPE_CONGE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE"
                    + " AND TREF_TYPE_CONGE.FL_DRIVING = 1"
                    + " AND T_CONGE.DT_FIN IS NULL";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                travelActivity = new TravelActivity();
                travelActivity.setIdTravel(cursor.getString(1));
                travelActivity.setIdType(cursor.getInt(2));
                travelActivity.setTravelName(cursor.getString(3));
            }
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return travelActivity;
    }


    /**
     * gets list of travel activities
     *
     * @return
     */
    public synchronized ArrayList<TravelActivity> getTravelActivities() {
        ArrayList<TravelActivity> travelList = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT ID_TYPE_CONGE, NOM_TYPE_CONGE" +
                    " FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 1 ORDER BY NOM_TYPE_CONGE ASC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);
            cursor = stmt.executeQuery();
            TravelActivity travelActivity = null;
            while (cursor.next()) {
                travelActivity = new TravelActivity();
                travelActivity.setIdType(cursor.getInt(1));
                travelActivity.setTravelName(cursor.getString(2));
                travelList.add(travelActivity);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return travelList;
    }

    // To get the unavailabilities from server
    public synchronized ArrayList<UnavailabilityBeans> getSimilarUnavailabilities(int flUnavailable, int flPayable) {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 0 " +
                    "AND FL_CLOCK = 0 " +
                    "AND FL_UNAVAILABLE = " + flUnavailable + " " +
                    "AND FL_PAYABLE = " + flPayable + " ORDER BY NOM_TYPE_CONGE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    public synchronized ArrayList<UnavailabilityBeans> getSimilarUnavailabilitiesDriving(int flUnavailable, int flPayable) {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 0 " +
                    "AND FL_CLOCK = 0 " +
                    "AND FL_UNAVAILABLE = " + flUnavailable + " " +
                    "AND FL_PAYABLE = " + flPayable + " ORDER BY NOM_TYPE_CONGE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    // To get the unavailabilities from server
    public synchronized ArrayList<UnavailabilityBeans> getSimilarUnavailabilities(int flUnavailable) {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 0 " +
                    "AND FL_CLOCK = 0 " +
                    "AND FL_UNAVAILABLE = " + flUnavailable +
                    " ORDER BY NOM_TYPE_CONGE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    /**
     * For getting the auto clock out time from the T_CUSTOMERS table
     *
     * @return minute
     */
    public synchronized String getAutoClockOutTime() {
        String autoCLockOut = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAutoClockOutQuery = "SELECT JSON_SETTINGS  FROM T_CUSTOMERS";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj()
                    .prepareStatement(getAutoClockOutQuery);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                String jsonCLockOut = cursor.getString(1);
                if (jsonCLockOut != null) {
                    //getting time out from json
                    JSONObject jsonObject = new JSONObject(jsonCLockOut);
                    autoCLockOut = jsonObject.getJSONObject("Auto-ClockOut").getString("tt_mobile_timeout");
                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();

            } else {
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                //connection.release();
                autoCLockOut = null;
            }

        } catch (ULjException e) {
            Logger.printException(e);
            autoCLockOut = null;
        } catch (Exception e) {
            e.printStackTrace();
            autoCLockOut = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return autoCLockOut;
    }

    public synchronized String getTotalClockExactDate() {

        String returnDate = null;
        ArrayList<String> list = new ArrayList<>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);

        Date mCurrentDate = new Date();
        String currentDate = sdf.format(mCurrentDate);
        returnDate = currentDate;

        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, -1);
        Date prevDate = cal.getTime();
        String previousDate = sdf.format(prevDate);
        PreparedStatement stmt = null;
        ResultSet cursor = null;

        query = "SELECT " +
                "T_CONGE.DT_DEBUT, " +
                "T_CONGE.DT_FIN " +
                "FROM T_CONGE,TREF_TYPE_CONGE WHERE " +
                "T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND " +
                "TREF_TYPE_CONGE.FL_CLOCK = 1 AND T_CONGE.DT_FIN IS NULL";

        //Connection connection = getConnectionObj();
        try {
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String dateTime[] = cursor.getString(1).split(" ");

                Logger.log("CHECK PREVIOUS CLOCK DATE", "current date is :" + currentDate);
                Logger.log("CHECK PREVIOUS CLOCK DATE", "current date in table is :" + dateTime[0]);

//                if (previousDate.equals(dateTime[0])) {
//                    returnDate = previousDate;
//                } else {
//                    returnDate = currentDate;
//                }

                //todo check the condition and do some logic
                if (currentDate.equals(dateTime[0])) {

                    returnDate = currentDate;

                } else {

                    returnDate = dateTime[0];
                }

            }
        } catch (Exception exc) {
            Logger.printException(exc);
            returnDate = currentDate;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return returnDate;
    }


    public synchronized long getTotalClockIn(String filterDate) {

        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        SimpleDateFormat dateFormat = new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss", Locale.US);
        Date mCurrentDate1 = new Date();
        String currentDate1 = dateFormat.format(mCurrentDate1);

        Date mCurrentDate = new Date();
        String currentDate = sdf.format(mCurrentDate);
        long clockDiffTime = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        query = "SELECT " +
                "T_CONGE.DT_DEBUT, " +
                "T_CONGE.DT_FIN " +
                "FROM T_CONGE,TREF_TYPE_CONGE WHERE " +
                "T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND " +
                "TREF_TYPE_CONGE.FL_CLOCK = 1 AND" +
                "(DATEFORMAT(T_CONGE.DT_DEBUT,'yyyy-mm-dd') ='"
                + filterDate + "')";
        //Connection connection = getConnectionObj();
        try {
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                if (!TextUtils.isEmpty(cursor.getString(2))) {
                    clockDiffTime = clockDiffTime
                            + getClockDiffTime(cursor.getString(2),
                            cursor.getString(1));

                } else {
                    clockDiffTime = clockDiffTime + getClockDiffTime(currentDate1, cursor
                            .getString(1));

                }


            }
        } catch (Exception exc) {
            Logger.printException(exc);
            clockDiffTime = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return clockDiffTime;

    }

    /**
     * Gets the difference between 2 time.
     *
     * @param dtFin    the dt fin
     * @param dt_debut the dt_debut
     * @return the clock difference time
     */
    private synchronized long getClockDiffTime(String dtFin, String dt_debut) {

        SimpleDateFormat dateFormat = new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss", Locale.US);
        long timeinterval = 0;
        try {
            long dtFinMiliseconds = dateFormat.parse(dtFin).getTime();
            long dtDebutMiliSeconds = dateFormat.parse(dt_debut).getTime();
            String currentDate = dateFormat.format(dtDebutMiliSeconds);
            String endDate = dateFormat.format(dtFinMiliseconds);

            Logger.log(TAG, "Clock timeinterval START in DATETIME format  --------> " + currentDate);
            Logger.log(TAG, "Clock timeinterval END in DATETIME format  --------> " + endDate);
            timeinterval = dtFinMiliseconds - dtDebutMiliSeconds;

            if (timeinterval < 0) {
                timeinterval = 0;
            }
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }

        return timeinterval;

    }


    /**
     * For getting the current active jobs of today
     *
     * @return detailsModel
     */
    public synchronized JobDetailsModel getCurrentActiveJobs() {
        JobDetailsModel detailsModel = null;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "NO_INT_CUST, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "REF_CUSTOMER, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND " +
                    "(CD_STATUT_INTERV=" + KEYS.CurrentJobs.JOB__STARTED +
                    "  ) "
                    + "AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId();

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            if (cursor.next()) {
                detailsModel = new JobDetailsModel();
                detailsModel.setIdJob(cursor.getString(1));
                detailsModel.setJobStatus(cursor.getInt(4));
                detailsModel.setSiteName(cursor.getString(5));
                detailsModel.setJobType(cursor.getString(6));
                detailsModel.setIdModel(String.valueOf(cursor.getInt(7)));
                detailsModel.setLat(cursor.getString(9));
                detailsModel.setLon(cursor.getString(10));
                detailsModel.setJobNumber(cursor.getInt(11));
                detailsModel.setEquipmentName(cursor.getString(12));
                detailsModel.setIdClient(cursor.getInt(13));
                detailsModel.setIdSite(cursor.getInt(14));
                detailsModel.setIdEquipment(cursor.getInt(15));
                detailsModel.setRefCustomer(cursor.getString(16));
                detailsModel.setJobUserId(cursor.getInt(8));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return detailsModel;
    }


    /**
     * This function used to fetch the job detail of a job. The job will be selected from the db by
     * the following preference.
     * Job which scheduled today and is in pause state now
     *
     * @return detail of selected job
     */
    public synchronized JobDetailsModel getAllAvailableJobsToday(Date date) {

        JobDetailsModel detailsModel = null;
        String query;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "NO_INT_CUST, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "REF_CUSTOMER, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND(" +
                    "("
                    + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                    + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                    currentDate + "')) AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                    + ")" +
                    "OR " +
                    "(" +
                    "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                    + dateOfToday
                    + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                    + getUser().getId() +
                    ")" +
                    "OR " +
                    "(" +
                    "CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + currentDate + "'))" +
                    ")" +
                    "OR " +
                    "(" +
                    "T_INTERVENTIONS.ID_USER!=" + getUser().getId()
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__STARTED +
                    ")" +
                    "OR " +
                    "(" +
                    "T_INTERVENTIONS.ID_USER!=" + getUser().getId()
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")" +
                    ") "
                    + "AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId()
                    + " ORDER BY DT_DEB_PREV";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            if (cursor.next()) {
                detailsModel = new JobDetailsModel();
                detailsModel.setIdJob(cursor.getString(1));
                detailsModel.setJobStatus(cursor.getInt(4));
                detailsModel.setSiteName(cursor.getString(5));
                detailsModel.setJobType(cursor.getString(6));
                detailsModel.setIdModel(String.valueOf(cursor.getInt(7)));
                detailsModel.setLat(cursor.getString(9));
                detailsModel.setLon(cursor.getString(10));
                detailsModel.setJobNumber(cursor.getInt(11));
                detailsModel.setEquipmentName(cursor.getString(12));
                detailsModel.setIdClient(cursor.getInt(13));
                detailsModel.setIdSite(cursor.getInt(14));
                detailsModel.setIdEquipment(cursor.getInt(15));
                detailsModel.setRefCustomer(cursor.getString(16));
                detailsModel.setJobUserId(cursor.getInt(8));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return detailsModel;
    }


    public synchronized JobDetailsModel getDeadlineExceededJobDetails() {
        JobDetailsModel detailsModel = null;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "NO_INT_CUST, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "REF_CUSTOMER, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2
                    + " AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId()
                    + " ORDER BY DT_DEB_PREV";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            if (cursor.next()) {
                detailsModel = new JobDetailsModel();
                detailsModel.setIdJob(cursor.getString(1));
                detailsModel.setJobStatus(cursor.getInt(4));
                detailsModel.setSiteName(cursor.getString(5));
                detailsModel.setJobType(cursor.getString(6));
                detailsModel.setIdModel(String.valueOf(cursor.getInt(7)));
                detailsModel.setLat(cursor.getString(9));
                detailsModel.setLon(cursor.getString(10));
                detailsModel.setJobNumber(cursor.getInt(11));
                detailsModel.setEquipmentName(cursor.getString(12));
                detailsModel.setIdClient(cursor.getInt(13));
                detailsModel.setIdSite(cursor.getInt(14));
                detailsModel.setIdEquipment(cursor.getInt(15));
                detailsModel.setRefCustomer(cursor.getString(16));
                detailsModel.setJobUserId(cursor.getInt(8));
            } else {
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return detailsModel;
    }


    public synchronized JobDetailsModel getToComeJobDetails() {
        JobDetailsModel detailsModel = null;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "NO_INT_CUST, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "REF_CUSTOMER, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId() + " "
                    + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3 ORDER BY DT_DEB_PREV";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            if (cursor.next()) {
                detailsModel = new JobDetailsModel();
                detailsModel.setIdJob(cursor.getString(1));
                detailsModel.setJobStatus(cursor.getInt(4));
                detailsModel.setSiteName(cursor.getString(5));
                detailsModel.setJobType(cursor.getString(6));
                detailsModel.setIdModel(String.valueOf(cursor.getInt(7)));
                detailsModel.setLat(cursor.getString(9));
                detailsModel.setLon(cursor.getString(10));
                detailsModel.setJobNumber(cursor.getInt(11));
                detailsModel.setEquipmentName(cursor.getString(12));
                detailsModel.setIdClient(cursor.getInt(13));
                detailsModel.setIdSite(cursor.getInt(14));
                detailsModel.setIdEquipment(cursor.getInt(15));
                detailsModel.setRefCustomer(cursor.getString(16));
                detailsModel.setJobUserId(cursor.getInt(8));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return detailsModel;
    }

    /**
     * Gets the dedline exceeded jobs count excluding Auxillary user.
     *
     * @param userId the user id
     * @return the dedline exceeded jobs count
     */
    public synchronized int getDedlineExceededJobsCountExcludingAuxUser(int userId) {

        String query = "SELECT COUNT(ID_INTERVENTION) "
//                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND (date(DT_FIN_PREV )< CURRENT DATE) AND CD_STATUT_INTERV<="
                + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                + "AND "
                + "T_INTERVENTIONS.ID_USER=" + getUser().getId();

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count = 0;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();

            count = count + resultSet.getInt(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        query = "SELECT COUNT(ID_INTERVENTION) "
//                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND "
                + "ID_INTERVENTION IN (SELECT ID_INTERVENTION "
                + "FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION "
                + "HAVING date(MAX(DT_FIN)) < CURRENT DATE) AND CD_STATUT_INTERV=4 "
                + "AND "
                + "T_INTERVENTIONS.ID_USER=" + getUser().getId();
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();

            count = count + resultSet.getInt(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT COUNT(ID_INTERVENTION) "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND " + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND date(DT_DEB_REAL) < CURRENT DATE"
                    + " AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId();
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {
                    preparedStatement = getConnectionObj().prepareStatement(query);
                    resultSet = preparedStatement.executeQuery();
                    resultSet.first();

                    count = count + resultSet.getInt(1);

//                    resultSet.close();
//                    preparedStatement.close();
                    //connection.commit();
//                    connDao.commit();
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (resultSet != null) {
                    try {
                        resultSet.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (preparedStatement != null) {
                    try {
                        preparedStatement.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }

    /**
     * Gets the to come job count excluding Auxillary user..
     *
     * @return the to come job count
     */
    public synchronized String getToComeJobCountExcludingAuxUser(int userId) {
        String query = "SELECT COUNT(ID_INTERVENTION) "
//                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                + "WHERE "
                + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                + "AND "
//                + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                + "AND date(dt_deb_prev) > CURRENT DATE AND CD_STATUT_INTERV <3"
                + " AND "
                + "T_INTERVENTIONS.ID_USER=" + getUser().getId();

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        String count = null;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            resultSet.first();
            count = resultSet.getString(1);

//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;
    }


    /**
     * Gets the to come job count excluding Auxillary user..
     *
     * @return the to come job count
     */
    public synchronized CurrentJobDataBean getCurrentJobsExcludingAuxUser(Date date, int userId) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            if (sdf.format(new Date()).equals(sdf.format(date))) {


                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ") "
                        + "AND "
                        + "T_INTERVENTIONS.ID_USER=" + getUser().getId()
                        + " ORDER BY DT_DEB_PREV";
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ") "
                        + "AND "
                        + "T_INTERVENTIONS.ID_USER=" + getUser().getId()
                        + " ORDER BY DT_DEB_PREV";
            }


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);


                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                    + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                    + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 " +
                    "AND TREF_TYPE_CONGE.FL_DRIVING = 0" +
                    " ORDER BY DT_DEBUT";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String headerDate = "";
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(3), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), headerDate,
                        String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                currentJobsBeans.add(Conge);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {

            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }


    public synchronized Boolean checkIsTravelActivity(int idUser) {

        int flDriving = 0;

        String sql_string = "SELECT FL_DRIVING FROM TREF_TYPE_CONGE WHERE ID_TYPE_CONGE = " + idUser;

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
//            Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                flDriving = cursor.getInt(1);

            }
//            cursor.close();
//            stmt.close();
//            connDao.commit();
//            connection.release();


//            return true;

        } catch (Exception e) {

            Logger.printException(e);
            flDriving = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return flDriving == 1;
    }


    public synchronized ArrayList<UnavailabilityBeans> getSimilarTravelActivities() {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 1 " +
                    " ORDER BY NOM_TYPE_CONGE ASC";
//            Connection connection = getConnectionObj();

            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
//            connDao.commit();
//            connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }


    /**
     * Update app version.
     *
     * @param appVersion the id photo
     * @param appVersion
     */
    public synchronized void updateAppVersion(int userId, String appVersion) {
        PreparedStatement ps = null;
        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_USERS SET APP_VERSION = ? WHERE ID_USER = ?");
            ps.set(2, userId);
            ps.set(1, appVersion);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }


    /**
     * Update FL_GPS_TRACKED.
     */
    public synchronized void updateFL_GPS_TRACKED(int userId, boolean tracked) {
        PreparedStatement ps = null;
        try {
            String qry = "UPDATE T_USERS SET FL_GPS_TRACKED = 1 WHERE ID_USER = ?";

            if (!tracked)
                qry = "UPDATE T_USERS SET FL_GPS_TRACKED = 0 WHERE ID_USER = ?";

            ps = getConnectionObj()
                    .prepareStatement(qry);
            ps.set(1, userId);

            ps.execute();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    //------------------------------------CHANGES V49----------------------------------------------


    /**
     * Insert sortie piece for take back serialized part.
     *
     * @param idIter         the id iter
     * @param idPiece        the id piece
     * @param valDepot       the quantite reprise
     * @param qty_reprise    the val depot
     * @param serial_reprise the val depot
     */
    public synchronized boolean insertSortiePieceTakeBackSP(String idIter, String idPiece,
                                                            int valDepot, int qty_reprise,
                                                            String serial_reprise, String qtySortie) {

        String query = "INSERT INTO T_REPRISE_PIECE(ID_INTERVENTION,ID_PIECE,SERIAL_REPRISE,QUANTITE_REPRISE) VALUES ('"
                + idIter
                + "','"
                + idPiece
                + "','"
                + serial_reprise
                + "',"
                + qty_reprise
                + ")";
        try {
            PreparedStatement ps;
            Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_SORTIE_PIECE(ID_INTERVENTION,ID_PIECE,QUANTITE_SORTIE," +
                    "FL_FACTURABLE,QUANTITE_REPRISE,SERIAL_REPRISE) VALUES ('"
                    + idIter + "','" + idPiece + "','" + qtySortie + "'," + valDepot + "," + qty_reprise + ",'"
                    + serial_reprise + "')");

//            ps = getConnectionObj().prepareStatement(query);
            ps.execute();
            ps.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }


    public synchronized boolean updateSortiePieceTakeBackSP(String idInterv, String idPiece,
                                                            int valDepot, int qty_reprise,
                                                            String serial_reprise, String qtySortie) {

        try {
            //Connection connection = getConnectionObj();
            PreparedStatement ps;
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_SORTIE_PIECE SET ID_INTERVENTION = ?,SERIAL_REPRISE = ? WHERE ID_PIECE = ?");
            ps.set(1, idInterv);
            ps.set(2, serial_reprise);
            ps.set(3, idPiece);
            ps.execute();
            ps.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    public boolean checkSortiePieceTakeBackPart(int idPiece, String idIntervention) {
        try {
            String query;
            query = "SELECT ID_PIECE,"
                    + " SERIAL_REPRISE, QUANTITE_SORTIE, QUANTITE_REPRISE, FL_FACTURABLE "
                    + "FROM T_SORTIE_PIECE WHERE T_SORTIE_PIECE.ID_PIECE = "
                    + idPiece
                    + " AND ID_INTERVENTION = '" + idIntervention + "'";

            PreparedStatement stmt = connDao.prepareStatement(query);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {

                Logger.log(TAG, "Check in T_SORTIE_PIECE  ID_PIECE is" + cursor.getInt(1));
                Logger.log(TAG, "Check in T_SORTIE_PIECE  SERIAL_REPRISE is" + encodeString(cursor.getBytes(2)));
                Logger.log(TAG, "Check in T_SORTIE_PIECE  QUANTITE_SORTIE is" + cursor.getDouble(3));
                Logger.log(TAG, "Check in T_SORTIE_PIECE  QUANTITE_REPRISE is" + cursor.getInt(4));

            }

            cursor.close();
            stmt.close();
            connDao.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    //------------------------------------CHANGES V49----------------------------------------------


    //------------------------------------NEW CHANGES V49----------------------------------------------

    /**
     * Update the intervention id and date used of the serial number when added
     * to parts & services for take back serialized part.
     *
     * @return
     */
    public synchronized boolean updatePieceSerialTakeBackSP(String idInterv, String dateUsed,
                                                            String idPieceSerial, String status, String idUserStock) {
        PreparedStatement ps = null;
        boolean result;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PIECE_SERIALS SET ID_INTERVENTION = ?,DT_USED = ?," +
                            "STATUS = ?,ID_STOCK = ? WHERE ID_PIECE_SERIAL = ?");

//            ps = getConnectionObj()
//                    .prepareStatement("UPDATE T_PIECE_SERIALS SET DT_USED = ?,STATUS = ?,ID_STOCK = ? WHERE ID_PIECE_SERIAL = ?");

            //check for now
            ps.set(1, idInterv);
            ps.set(2, dateUsed);
            ps.set(3, status);
            ps.set(4, idUserStock);
            ps.set(5, idPieceSerial);

//            ps.set(1, dateUsed);
//            ps.set(2, status);
//            ps.set(3, idUserStock);
//            ps.set(4, idPieceSerial);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    /**
     * method to fetch the serial numbers of particular depot order by date
     * used.
     *
     * @return array list of stock model class
     */
    public synchronized ArrayList<InventorySerialNumbersBeans> getPartsSerialNumbersTakeBack(
            String idUserStock, int idPiece, String serial) {
        ArrayList<InventorySerialNumbersBeans> serialNosList = new ArrayList<InventorySerialNumbersBeans>();

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '"
                    + idUserStock + "' AND ID_PIECE=" + idPiece + " AND SERIAL='" + serial + "' "
                    + "ORDER BY DT_USED ASC";


            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventorySerialNumbersBeans serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans
                        .setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialNosList.add(serialBeans);
            }
//            cursor.close();
//            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        try {
//            //connection.commit();
//            connDao.commit();
//            //connection.release();
//        } catch (Exception e) {
//            e.printStackTrace();
//        }

        return serialNosList;
    }

    /**
     * method to fetch the serial numbers of particular depot ordered by serial
     * numbers.
     *
     * @return array list of stock model class
     */
    public synchronized InventorySerialNumbersBeans getAllDepotSerialNumbers(
            String idUserStock, String pieceSerial, int clientId, String idInterv) {

        InventorySerialNumbersBeans serialBeans = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

//            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '" + idUserStock
//                    + "' AND SERIAL = '" + pieceSerial + "' AND DT_USED IS NOT NULL";

            if (clientId == -1) {
                query = "SELECT * FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' AND DT_USED IS NOT NULL";
            } else {
                query = "SELECT * FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "'" +
                        "AND ID_CLIENT = "
                        + clientId +
                        " AND ID_INTERVENTION != '" + idInterv + "'" +
                        " AND DT_USED IS NOT NULL";
            }

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans
                        .setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialBeans.setIdPiece(cursor.getInt(3));
                serialBeans.setIdStock(cursor.getString(2));


                if (!isIntervComplete(cursor.getString(5))) {
                    serialBeans = null;
                }

                Logger.log(TAG, "selected IDSTOCK is:" + cursor.getString(2));
                Logger.log(TAG, "selected CLIENT ID is:" + cursor.getInt(8));
                Logger.log(TAG, "selected SerialNumber is:" + String.valueOf(cursor.getString(4)));


            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            serialBeans = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return serialBeans;
    }

    public synchronized String getIdForSerial(String pieceSerial) {

        String idPieceSerial = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT ID_PIECE_SERIAL FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' AND DT_USED IS NULL";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                idPieceSerial = cursor.getString(1);

                Logger.log(TAG, "During finish taken part id SerialNumber is:" + idPieceSerial);

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            idPieceSerial = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return idPieceSerial;
    }


    public synchronized int getDepotClientId(String pieceSerial) {

        int id_client = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT ID_CLIENT FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' AND DT_USED IS NOT NULL";


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                id_client = cursor.getInt(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            id_client = -1;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return id_client;
    }


    public synchronized InventorySerialNumbersBeans getAllDepotSerialNumbersNew(
            String idUserStock, String pieceSerial) {
        InventorySerialNumbersBeans serialBeans = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

//            query = "SELECT * FROM T_PIECE_SERIALS WHERE ID_STOCK = '" + idUserStock
//                    + "' AND SERIAL = '" + pieceSerial + "' ";

            query = "SELECT * FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' ";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans
                        .setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialBeans.setIdPiece(cursor.getInt(3));
                serialBeans.setStatusName(cursor.getString(7));

                Logger.log(TAG, "selected IdSerialNumber is:" + cursor.getString(1));
                Logger.log(TAG, "selected SerialNumber is:" + String.valueOf(cursor.getString(4)));

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            serialBeans = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return serialBeans;
    }

    public synchronized ArrayList<String> getStockNameID() {
        ArrayList<String> nameStock = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT * FROM T_STOCKS ";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            nameStock = new ArrayList<>();
            while (cursor.next()) {
                nameStock.add(cursor.getString(1));

                Logger.log(TAG, "ID STOCK NAME :" + cursor.getString(2));
                Logger.log(TAG, "ID STOCK NAME ID :" + cursor.getString(1));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return nameStock;
    }


    /**
     * Insert sortie piece for take back serialized part.
     *
     * @param idIter         the id iter
     * @param idPiece        the id piece
     * @param qty_reprise    the val depot
     * @param serial_reprise the val depot
     */
    public synchronized boolean insertReprisePieceTakeBack(String idIter, String idPiece,
                                                           int qty_reprise, String serial_reprise, String dateUsed) {

        String query = "INSERT INTO T_REPRISE_PIECE(ID_INTERVENTION,ID_PIECE,SERIAL_REPRISE,QUANTITE_REPRISE) VALUES ('"
                + idIter
                + "','"
                + idPiece
                + "','"
                + serial_reprise
                + "',"
                + qty_reprise
                + ")";
        PreparedStatement ps = null;
        boolean result;
        try {

            Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement(query);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public synchronized boolean updateReprisePieceTakeBack(String idInterv, String idPiece,
                                                           int qty_reprise, String serial_reprise) {
        PreparedStatement ps = null;
        boolean result;
        try {

            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_REPRISE_PIECE SET " +
                            "SERIAL_REPRISE = ?,QUANTITE_REPRISE = ? WHERE ID_INTERVENTION=? AND ID_PIECE = ?");
            ps.set(1, serial_reprise);
            ps.set(2, qty_reprise);
            ps.set(3, idInterv);
            ps.set(4, idPiece);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public synchronized boolean updateReprisePieceTakeBackSerial(String idInterv, String idPiece,
                                                                 String serial_reprise) {
        PreparedStatement ps = null;
        boolean result;
        try {

            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_REPRISE_PIECE SET " +
                            "SERIAL_REPRISE = ? WHERE ID_INTERVENTION=? AND ID_PIECE = ?");
            ps.set(1, serial_reprise);
            ps.set(2, idInterv);
            ps.set(3, idPiece);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    public boolean checkReprisePieceTakeBackPart(int idPiece, String idIntervention) {
        int hasPiece = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT "
                    + "SERIAL_REPRISE, QUANTITE_REPRISE "
                    + "FROM T_REPRISE_PIECE WHERE ID_PIECE = "
                    + idPiece
                    + " AND ID_INTERVENTION = '" + idIntervention + "'";


            stmt = connDao.prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                hasPiece = 1;
                Logger.log(TAG, "Check in T_REPRISE_PIECE  SERIAL_REPRISE is" + encodeString(cursor.getBytes(1)));
                Logger.log(TAG, "Check in T_REPRISE_PIECE  QUANTITE_REPRISE is" + cursor.getInt(2));

            }

//            cursor.close();
//            stmt.close();
//            connDao.commit();

        } catch (Exception e) {
            e.printStackTrace();

        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return hasPiece == 1;

    }

    public boolean checkTest() {
        int hasPiece = 0;
        try {
            String query;
//            query = "SELECT r.*, serials.row_value as serial FROM T_REPRISE_PIECE as " +
//                    "r LEFT JOIN sa_split_list(r.SERIAL_REPRISE) as serials on 1=1 " +
//                    "WHERE r.ID_INTERVENTION = '5cd40b64-7357-11e8-8000-da7d8c294cd1'";

            query = "select * from sa_split_list ('1234,5678')";

            PreparedStatement stmt = connDao.prepareStatement(query);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {

                hasPiece = 1;
                Logger.log(TAG, "Check in T_REPRISE_PIECE  SERIAL_REPRISE is" + cursor.getString(1));
                Logger.log(TAG, "Check in T_REPRISE_PIECE  QUANTITE_REPRISE is" + cursor.getString(2));

            }

            cursor.close();
            stmt.close();
            connDao.commit();

        } catch (Exception e) {
            e.printStackTrace();

        }
        return hasPiece == 1;

    }

    /**
     * Gets the take back reprise piece.
     *
     * @param idInter the id inter
     * @return the sortiepiece
     */
    public synchronized Vector<SortiePiece> getReprisePieceTakeBackSP(String idInter) {

        Vector<SortiePiece> st = new Vector<SortiePiece>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {


            String query = " SELECT "
                    + " TREF_PIECES.ID_PIECE,"
                    + " NM_PIECE,"
                    + " PRIX_PIECE,"
                    + " FL_SERIALIZABLE,"
                    + " NM_CATEGORIE_PIECE, "
                    + " SERIAL_REPRISE,"
                    + " QUANTITE_REPRISE, "
                    + " FL_TRACK_STOCK "
                    + " FROM "
                    + " T_REPRISE_PIECE ,TREF_PIECES ,TREF_CATEGORIE_PIECE "
                    + " WHERE TREF_PIECES.ID_PIECE = T_REPRISE_PIECE.ID_PIECE "
                    + " AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                    + " AND T_REPRISE_PIECE.QUANTITE_REPRISE > 0"
                    + " AND ID_INTERVENTION = '" + idInter + "'";


            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                SortiePiece sp = new SortiePiece(cursor.getInt(1),
                        encodeString(cursor.getBytes(2)), cursor.getDouble(3),
                        cursor.getInt(4), 0.00,
                        encodeString(cursor.getBytes(5)), 0,
                        encodeString(cursor.getBytes(6)), cursor.getInt(7), "", cursor.getInt(8));


                st.add(sp);
            }

        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return st;
    }

    /**
     * Delete saisie piece.
     *
     * @param idPiece  the id piece
     * @param idInterv the id interv
     */
    public synchronized void deleteReprisePiece(String idPiece, String idInterv) {
        executeDDL("DELETE FROM T_REPRISE_PIECE WHERE ID_PIECE='" + idPiece
                + "' AND ID_INTERVENTION='" + idInterv + "'");
    }


    /**
     * Delete saisie piece.
     *
     * @param idPiece  the id piece
     * @param idSerial the id serial
     */
    public synchronized void deleteTPieceSerial(String idPiece, String idSerial) {
        executeDDL("DELETE FROM T_PIECE_SERIALS WHERE ID_PIECE='" + idPiece
                + "' AND ID_PIECE_SERIAL='" + idSerial + "'");
    }

    /**
     * Update the intervention id and date used of the serial number when added
     * to parts & services.
     *
     * @return
     */
    public synchronized boolean removeReprisePieceSerialTB(String idInterv, String dateUsed, String statusName,
                                                           String idStock, String idPieceSerial) {
        PreparedStatement ps = null;
        boolean result;
        try {
            //Connection connection = getConnectionObj();

            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_PIECE_SERIALS SET ID_INTERVENTION = ?,STATUS = ?," +
                            "DT_USED = ?,ID_STOCK = ? WHERE ID_PIECE_SERIAL = ?");
//            ps = getConnectionObj()
//                    .prepareStatement("UPDATE T_PIECE_SERIALS SET STATUS = ?,DT_USED = ? WHERE ID_PIECE_SERIAL = ?");

            ps.set(1, idInterv);
            ps.set(2, statusName);
            ps.set(3, dateUsed);
            ps.set(4, idStock);
            ps.set(5, idPieceSerial);
            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * Check the status of Job to Scheduled,Started,Suspended or completed.
     *
     * @param idInterv the idinterv
     */
    public synchronized boolean isIntervComplete(String idInterv) {

        int status = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT "
                    + "CD_STATUT_INTERV "
                    + "FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '" + idInterv + "' ";
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId();


            stmt = connDao.prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                status = cursor.getInt(1);

                Logger.log(TAG, "INTERVENTION STATUS IS " + cursor.getInt(1));

            }

//            cursor.close();
//            stmt.close();
//            connDao.commit();

        } catch (Exception e) {
            e.printStackTrace();

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


        if (status == -1)
            return true;
        else
            return status == KEYS.JObDetail.JOB__COMPLETE;

    }

    public synchronized boolean checkTakeBackPiece(String idPiece, String idIntervention,
                                                   String idPieceSerial) {
        String query = "SELECT SERIAL_REPRISE FROM T_REPRISE_PIECE WHERE ID_PIECE = " + idPiece
                + " AND ID_INTERVENTION = '" + idIntervention
                + "' AND SERIAL_REPRISE = '" + idPieceSerial
                + "'";
        try {
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj().prepareStatement(query);
            ResultSet cursor = stmt.executeQuery();
            if (cursor.next()) {
                cursor.close();
                stmt.close();
                //connection.commit();
                connDao.commit();
                //connection.release();
                return true;
            } else {
                cursor.close();
                stmt.close();
                //connection.commit();
                connDao.commit();
                //connection.release();
                return false;
            }
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }


    public synchronized ArrayList<String> getTakeBackPieceSerialList(String idPiece, String idIntervention) {
        ArrayList<String> serialList = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT SERIAL_REPRISE FROM T_REPRISE_PIECE WHERE ID_PIECE = " + idPiece
                    + " AND ID_INTERVENTION = '" + idIntervention
                    + "'";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            serialList = new ArrayList<>();
            while (cursor.next()) {
                String serial = encodeString(cursor.getBytes(1));

                if (!serial.contains(",")) {
                    serialList.add(serial.trim());
                } else {
                    String list[] = serial.split(",");
                    for (int i = 0; i < list.length; i++) {
                        serialList.add(list[i].trim());
                    }
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
            serialList = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return serialList;

    }


    public synchronized ArrayList<String> getAllTakeBackPieceSerialList(String idIntervention) {
        ArrayList<String> serialList = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT SERIAL_REPRISE FROM T_REPRISE_PIECE WHERE  ID_INTERVENTION = '" + idIntervention
                    + "'";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            serialList = new ArrayList<>();
            while (cursor.next()) {
                String serial = encodeString(cursor.getBytes(1));

                if (!serial.contains(",")) {
                    serialList.add(serial.trim());
                } else {
                    String list[] = serial.split(",");
                    for (int i = 0; i < list.length; i++) {
                        serialList.add(list[i].trim());
                    }
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
            serialList = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return serialList;

    }

    /**
     * check if the job has client id
     *
     * @param idInterv is the intervention id
     */
    public synchronized int hasClientID(String idInterv) {

        int id_client = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT "
                    + "ID_CLIENT "
                    + "FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '" + idInterv + "' ";


            stmt = connDao.prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {

                id_client = cursor.getInt(1);
            }

//            cursor.close();
//            stmt.close();
//            connDao.commit();

        } catch (Exception e) {
            e.printStackTrace();

            id_client = -1;

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return id_client;

    }


    /**
     * Gets the nbre sor pie by id pie and id inter.
     *
     * @param idPiece the id piece
     * @param idInter the id inter
     * @return the nbre sor pie by id pie and id inter
     */
    public synchronized String[] getQtySerialRepPieceByIdPieAndIdInter(String idPiece,
                                                                       String idInter) {
        String sql_string = "SELECT QUANTITE_REPRISE,SERIAL_REPRISE FROM T_REPRISE_PIECE WHERE ID_INTERVENTION='"
                + idInter + "' AND ID_PIECE='" + idPiece + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String[] qtySerial = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                qtySerial = new String[]{Integer.toString(cursor.getInt(1)),
                        encodeString(cursor.getBytes(2))};
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            qtySerial = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return qtySerial;
    }


    public synchronized String getStatusForSerial(String pieceSerial, int idPiece) {
        String statusName = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT "
                    + "STATUS "
                    + "FROM T_PIECE_SERIALS WHERE ID_PIECE = "
                    + idPiece
                    + " AND SERIAL = '" + pieceSerial + "'";
//                    + "DT_USED IS NULL";

//            query = "SELECT STATUS FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' ";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                statusName = encodeString(cursor.getBytes(1));

                Logger.log(TAG, "selected statusName is:" + statusName);

            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            statusName = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return statusName;
    }


    public synchronized boolean isEditForSerial(String pieceSerial, int idPiece) {
        String statusName = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        boolean result;
        try {
            String query;

            query = "SELECT "
                    + "STATUS "
                    + "FROM T_PIECE_SERIALS WHERE ID_PIECE = "
                    + idPiece
                    + " AND SERIAL = '" + pieceSerial + "'";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {

                statusName = encodeString(cursor.getBytes(1));


//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                result = true;
            } else {

                Logger.log(TAG, "selected statusName is:" + statusName);
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
                result = false;
            }
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public synchronized ArrayList<InventorySerialNumbersBeans> getAllDepotSNDemoNEw() {

        ArrayList<InventorySerialNumbersBeans> selectedPiece = new ArrayList<InventorySerialNumbersBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;


            query = "SELECT * FROM T_PIECE_SERIALS WHERE  DT_USED IS NOT NULL";

//            query = "SELECT * FROM T_PIECE_SERIALS WHERE SERIAL = '" + pieceSerial + "' ";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                InventorySerialNumbersBeans serialBeans = new InventorySerialNumbersBeans();
                serialBeans.setIdSerialNumber(cursor.getString(1));
                serialBeans
                        .setSerialNumber(String.valueOf(cursor.getString(4)));
                serialBeans.setIdInterv(cursor.getString(5));
                serialBeans.setDateUsed(cursor.getString(6));
                serialBeans.setIdPiece(cursor.getInt(3));

                selectedPiece.add(serialBeans);

                Logger.log(TAG, "DT_USED IS NOT NULL SERIAL NO IN OUR DEPOT------>" +
                        String.valueOf(cursor.getString(4)));

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            selectedPiece = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (selectedPiece != null && selectedPiece.size() > 0) {
            Logger.log(TAG, "size is " + selectedPiece.size());
        } else {
            Logger.log(TAG, "size is 0  ");
        }

        return selectedPiece;
    }


    /**
     * Gets the take back reprise piece.
     *
     * @param idPiece the id inter
     * @return the sortiepiece
     */
    public synchronized String[] getPartCatNameForSerial(int idPiece) {

        String[] partCatName;
        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {

            String query = " SELECT "
                    + " TREF_PIECES.ID_PIECE,"
                    + " NM_PIECE,"
                    + " PRIX_PIECE,"
                    + " NM_CATEGORIE_PIECE "
                    + " FROM "
                    + " TREF_PIECES ,TREF_CATEGORIE_PIECE "
                    + " WHERE TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                    + " AND TREF_PIECES.ID_PIECE = " + idPiece + " ";

            partCatName = null;
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                partCatName = new String[]{encodeString(cursor.getBytes(2)),
                        encodeString(cursor.getBytes(4)), String.valueOf(cursor.getDouble(3))};

            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            partCatName = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return partCatName;
    }

    /**
     * Gets the list of clients.
     *
     * @return the clients
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<PartCategoryNameBeans> getPartNameList(int idCategoryPiece) {
        ArrayList<PartCategoryNameBeans> listClt = new ArrayList<>();

        String query;

        if (idCategoryPiece <= 0) {
            query = "SELECT "
                    + "TREF_PIECES.NM_PIECE,"
                    + "TREF_PIECES.CD_PRODUIT,"
                    + "ID_PIECE,"
                    + "TREF_PIECES.ID_CATEGORIE_PIECE,"
                    + "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE "
                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                    + "AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                    + "AND TREF_PIECES.FL_SERIALIZABLE = 1";
        } else {
            query = "SELECT "
                    + "TREF_PIECES.NM_PIECE,"
                    + "TREF_PIECES.CD_PRODUIT,"
                    + "ID_PIECE,"
                    + "TREF_PIECES.ID_CATEGORIE_PIECE,"
                    + "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE "
                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                    + "AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                    + "AND TREF_PIECES.FL_SERIALIZABLE = 1 "
                    + "AND TREF_PIECES.ID_CATEGORIE_PIECE = " + idCategoryPiece + " ";
        }

        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                PartCategoryNameBeans partCategoryNameBeans = new PartCategoryNameBeans(cursor.getInt(3),
                        cursor.getInt(4), encodeString(cursor.getBytes(1)), encodeString(cursor.getBytes(2)), encodeString(cursor.getBytes(5)));
                listClt.add(partCategoryNameBeans);
                Logger.output("CLients>>>>>>>>>>>>>", "NM_PIECE name is :" + encodeString(cursor.getBytes(1)));
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }


//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        Logger.output("CLients>>>>>>>>>>>>>", listClt.size() + "");
        return listClt;

    }


    /**
     * Gets the list of clients.
     *
     * @return the clients
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<PartCategoryNameBeans> getCategoryList(int idCategoryPiece) {
        ArrayList<PartCategoryNameBeans> listClt = new ArrayList<>();

        String query;

//        if (idCategoryPiece <= 0) {
        query = "SELECT DISTINCT "
                + "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE,"
                + "NM_CATEGORIE_PIECE "
                + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                + "AND TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE "
                + "AND TREF_PIECES.FL_SERIALIZABLE = 1";
//        } else {
//            query = "SELECT "
//                    + "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE,"
//                    + "NM_CATEGORIE_PIECE,"
//                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
//                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
//                    + "AND TREF_PIECES.FL_SERIALIZABLE = 1 "
//                    + "AND TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " + idCategoryPiece + " ";
//        }


        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                PartCategoryNameBeans partCategoryNameBeans = new PartCategoryNameBeans(
                        cursor.getInt(1), encodeString(cursor.getBytes(2)));
                listClt.add(partCategoryNameBeans);
                Logger.output("CLients>>>>>>>>>>>>>", "NM_CATEGORIE_PIECE name is :" + encodeString(cursor.getBytes(2)) + " id :" + cursor.getInt(1));

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//        cursor.close();
//        preparedStatement.close();
        //connection.commit();
//        connDao.commit();
        //connection.release();
        Logger.output("CLients>>>>>>>>>>>>>", listClt.size() + "");
        return listClt;
    }

    public synchronized int getPartsCount(int idCategoryPiece) {

        int clientCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;
            if (idCategoryPiece <= 0) {
                query = "SELECT "
                        + "count(TREF_PIECES.NM_PIECE) "
                        + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                        + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                        + "AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                        + "AND TREF_PIECES.FL_SERIALIZABLE = 1";
            } else {
                query = "SELECT "
                        + "count(TREF_PIECES.NM_PIECE) "
                        + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                        + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                        + "AND TREF_PIECES.ID_CATEGORIE_PIECE = TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE "
                        + "AND TREF_PIECES.FL_SERIALIZABLE = 1 "
                        + "AND TREF_PIECES.ID_CATEGORIE_PIECE = " + idCategoryPiece + " ";
            }
//            String query = "SELECT "
//                    + "count(*) FROM TREF_PIECES "
//                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
//                    + "AND TREF_PIECES.FL_SERIALIZABLE = 1";

            preparedStatement = getConnectionObj()
                    .prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientCount = cursor.getInt(1);

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            clientCount = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return clientCount;
    }

    public synchronized int getCateCount() {
        int clientCount = 0;
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {

            String query = "SELECT count(DISTINCT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE) "
                    + "FROM TREF_PIECES,TREF_CATEGORIE_PIECE "
                    + "WHERE TREF_PIECES.DT_SUPPR IS NULL "
                    + "AND TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE=TREF_PIECES.ID_CATEGORIE_PIECE "
                    + "AND TREF_PIECES.FL_SERIALIZABLE = 1";

            preparedStatement = getConnectionObj()
                    .prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientCount = cursor.getInt(1);

            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            Logger.printException(e);
            clientCount = 0;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return clientCount;
    }

    public synchronized String insertNewSerialPart(String idUserStock, int idClient, String dateUsed,
                                                   String idIntervention, String serialNumber,
                                                   int idPiece, String status, int idCustomer) {

        boolean isInserted = false;
        String serialId = getUniqueId();

        isInserted = executeDDL("INSERT INTO T_PIECE_SERIALS(ID_INTERVENTION,ID_PIECE_SERIAL," +
                "SERIAL,ID_CLIENT,ID_STOCK,ID_PIECE,DT_USED,STATUS) VALUES ( NULL"
                + ",'"
                + serialId
                + "','"
                + serialNumber
                + "',"
                + idClient
                + ",'"
                + idUserStock
                + "',"
                + idPiece
                + ",NULL"
                + ",'"
                + status
                + "' )");

        if (isInserted)
            return serialId;
        else
            return "";


//        try {
//            //Connection connection = getConnectionObj();
//            PreparedStatement ps;
//
//            ps = getConnectionObj()
//                    .prepareStatement("INSERT INTO T_PIECE_SERIALS (ID_INTERVENTION," +
//                            "ID_CLIENT," +
//                            "ID_PIECE," +
//                            "ID_STOCK," +
//                            "SERIAL," +
//                            "DT_USED," +
//                            "STATUS,ID_PIECE_SERIAL) VALUES (?,?,?,?,?,?,?,?)");
//
//
//            //check for now
//            ps.set(1, idIntervention);
//            ps.set(2, idClient);
//            ps.set(3, idPiece);
//            ps.set(4, idUserStock);
//            ps.set(5, serialNumber);
//            ps.set(6, dateUsed);
//            ps.set(7, status);
//            ps.set(8, getUniqueId());
//
//
//            ps.execute();
//            ps.close();
//            //connection.commit();
//            connDao.commit();
//            //connection.release();
//            return true;
//        } catch (Exception e) {
//            e.printStackTrace();
//            return false;
//        }

    }


    public synchronized String checkTPieceTB(String pieceSerial) {
        String clientCount = null;
        try {


            String query = "SELECT ID_EQUIPEMENT_CLIENT FROM T_PIECE_SERIALS WHERE ID_PIECE_SERIAL = '" + pieceSerial + "'";
//                    " AND ID_EQUIPEMENT_CLIENT IS NULL";

            PreparedStatement preparedStatement = getConnectionObj()
                    .prepareStatement(query);
            ResultSet cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientCount = "" + cursor.getString(1);

            }
            cursor.close();
            preparedStatement.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return clientCount;
        } catch (Exception e) {
            Logger.printException(e);
            return null;
        }
    }


    /**
     * remove foreign key in T_INTERVENTIONS table
     *
     * @author Trident
     */
    public synchronized void removeInterventionFK() {
        executeDDL("ALTER TABLE T_INTERVENTIONS DROP CONSTRAINT FK_T_INTERV_REF_T_USERS");
    }


    //------------------------------------NEW CHANGES V49----------------------------------------------

    //------------------------------------NEW CHANGES V50----------------------------------------------

    public synchronized void updateDtModifIntervention(String idInterv, String userId) {

        executeDDL("UPDATE T_TEMPS_INTERV SET DT_MODIF = CURRENT TIMESTAMP WHERE ID_INTERVENTION ='"
                + idInterv + "' AND ID_USER='" + userId
                + "' AND FL_SCHEDULED = 1 AND DT_SUPPR IS NULL");

    }

    public synchronized boolean checkInterventionInT_TEMPS_INTERV(String jobId) {
        boolean result = false;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT ID_TEMPS_INTERV  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
                    + jobId + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    if (!TextUtils.isEmpty(resultSet.getString(1))) {
                        result = true;
                        Logger.log(TAG, "PRIMARY KEY T_TEMPS_INTERV--->" + resultSet.getString(1));
                    }

                } catch (Exception e) {
                    Logger.printException(e);
                    result = false;
                }
            }
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;

    }

    /**
     * get the json value for custom field in site
     *
     * @return
     */
    public synchronized String getDateMeetingForIntervention(String idInterv) {


        String dateMeeting = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query;
            query = "SELECT DT_MEETING FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                dateMeeting = cursor.getString(1);

            }
//            cursor.close();
//            stmt.close();


            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            dateMeeting = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return dateMeeting;

    }


    //------------------------------------NEW CHANGES V50----------------------------------------------


    /**
     * For getting the current active jobs of today
     *
     * @return detailsModel
     */
    public synchronized JobDetailsModel getCurrentJob(String jobId) {
        JobDetailsModel detailsModel = null;
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "NO_INT_CUST, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "REF_CUSTOMER, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
                    + "ID_INTERVENTION='"
                    + jobId + "' "
                    + "AND "
                    + "T_INTERVENTIONS.ID_USER=" + getUser().getId();

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            if (cursor.next()) {
                detailsModel = new JobDetailsModel();
                detailsModel.setIdJob(cursor.getString(1));
                detailsModel.setJobStatus(cursor.getInt(4));
                detailsModel.setSiteName(cursor.getString(5));
                detailsModel.setJobType(cursor.getString(6));
                detailsModel.setIdModel(String.valueOf(cursor.getInt(7)));
                detailsModel.setLat(cursor.getString(9));
                detailsModel.setLon(cursor.getString(10));
                detailsModel.setJobNumber(cursor.getInt(11));
                detailsModel.setEquipmentName(cursor.getString(12));
                detailsModel.setIdClient(cursor.getInt(13));
                detailsModel.setIdSite(cursor.getInt(14));
                detailsModel.setIdEquipment(cursor.getInt(15));
                detailsModel.setRefCustomer(cursor.getString(16));
                detailsModel.setJobUserId(cursor.getInt(8));
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return detailsModel;
    }


    /**
     * Get the values for a single invoice or quotation
     *
     * @return object for Invoice_Quotation_Beans
     */
    public synchronized ArrayList<Invoice_Quotation_Beans> getInvoiceQuotationDetailsList(String idInterv) {

        ArrayList<Invoice_Quotation_Beans> beansArrayList = new ArrayList<>();

        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query = "SELECT * FROM T_FACTURES WHERE ID_INTERVENTION = '"
                    + idInterv + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                Invoice_Quotation_Beans listInvoiceQuotation = new Invoice_Quotation_Beans();
                listInvoiceQuotation.setId(cursor.getString(12));
                listInvoiceQuotation.setCustomerId(cursor.getInt(1));
                listInvoiceQuotation.setJobId(cursor.getString(2));
                listInvoiceQuotation.setNumberOfIQ(cursor.getInt(3));
                listInvoiceQuotation.setFlag(cursor.getInt(4));
                listInvoiceQuotation.setDateOfCreation(cursor.getString(5));
                listInvoiceQuotation.setClientId(cursor.getInt(7));
                listInvoiceQuotation.setSiteId(cursor.getInt(8));
                listInvoiceQuotation.setTotalWithoutTax(cursor.getFloat(9));
                listInvoiceQuotation.setTax(cursor.getFloat(10));
                listInvoiceQuotation.setTotalWithTax(cursor.getFloat(11));
                beansArrayList.add(listInvoiceQuotation);
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
            beansArrayList = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return beansArrayList;

    }

// ---------------------------------------------------PARTS_SERVICES_UPDATED-------------------------------------------------


    /**
     * method to fetch the parts & service, reference & price for inventory list
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> _partsList(PartsFilter filter) {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        try {

            PreparedStatement stmt = _partsListQuery(filter, false);
            if (stmt == null) return subcategoryList;

            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(rs.getInt(1)));
                subCatBeans.setPartsService(rs.getString(2));
                subCatBeans.setCategory(rs.getString(3));
                subCatBeans.setReference(rs.getString(4));
                subCatBeans.setCostOfItem(rs.getDouble(5));
                subCatBeans.setIsSerializable(rs.getInt(6));
                subCatBeans.setIdTaxRate(rs.getInt(7));
                subCatBeans.setNoOfPieces(String.valueOf(rs.getInt(8)));
                subCatBeans.setIsTracked(rs.getInt(9));
                subCatBeans.setDescription(rs.getString(10));
                subcategoryList.add(subCatBeans);
            }
            rs.close();
            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return subcategoryList;
    }

    public synchronized int _partsListCount(PartsFilter filter) {

        int count = 0;

        try {
            PreparedStatement stmt = _partsListQuery(filter, true);
            if (stmt == null) return count;

            ResultSet rs = stmt.executeQuery();
            rs.first();
            count = rs.getInt(1);
            rs.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
        }

        return count;

    }

    private PreparedStatement _partsListQuery(PartsFilter filter, boolean isCount) {

        //Setup Base Query
        String query = "SELECT TOP 20 START AT " + filter.offset
                + "p.ID_PIECE,"
                + "p.NM_PIECE,"
                + "cat.NM_CATEGORIE_PIECE,"
                + "p.CD_PRODUIT,"
                + "p.PRIX_PIECE,"
                + "p.FL_SERIALIZABLE,"
                + "p.ID_TAXRATE, "
                + "s.QUANTITY, "
                + "p.FL_TRACK_STOCK,"
                + "p.DESCRIPTION ";

        if (isCount) query = "SELECT count(*) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL #WHERE#";


        String where = "";

        if (filter.inStock) {
            where += " AND s.QUANTITY > 0 ";
            where += " AND p.FL_TRACK_STOCK = 1 ";
        }

        if (!TextUtils.isEmpty(filter.filterCategory) && filter.categoryId == 0) { //We've select a category, get the ID
            filter.categoryId = _inventoryPartListCategoryId(filter.filterCategory);
        }
        if (filter.categoryId > 0) {
            where += " AND p.ID_CATEGORIE_PIECE = :categoryId ";
        }
        if (!TextUtils.isEmpty(filter.searchText)) {
            where += " AND ( p.CD_PRODUIT LIKE :searchText OR p.NM_PIECE LIKE :searchText ";
            if (filter.categoryId == 0)
                where += " OR cat.NM_CATEGORIE_PIECE LIKE :searchText "; //only search category if we have no Id
            where += ") ";
        }

        query = query.replace("#WHERE#", where);

        //Order by clause when not counting
        query += isCount ? "" : " ORDER BY p.NM_PIECE ";

        Logger.log("Q", query.replace(":searchText", "%" + filter.searchText + "%").replace(":categoryId", String.valueOf(filter.categoryId)));

        try {

            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            if (filter.categoryId > 0) stmt.set("categoryId", filter.categoryId);
            if (!TextUtils.isEmpty(filter.searchText))
                stmt.set("searchText", "%" + filter.searchText + "%");

            return stmt;

        } catch (Exception e) {

            Logger.printException(e);
            return null;

        }
    }

    public class PartsFilter {
        public boolean inStock = false;

        public int offset = 1;
        public int categoryId = 0;
        public String filterCategory = "";
        public String searchText = "";

        public void resetCategory(String newCategory) {
            this.filterCategory = newCategory;
            this.categoryId = 0;
        }
    }


    public class InventoryFilter {
        public int offset = 1;
        public boolean inStock = false;
        public boolean isRequested = false;
        public String category = "";
        public int categoryId = 0;
        public String searchText = "";

        transient public boolean isFiltering;    // (1)

        protected boolean getIsFiltering() {    // (2)
            return !TextUtils.isEmpty(category) || !TextUtils.isEmpty(searchText);
        }

        public void resetCategory(String newCategory) {
            this.category = newCategory;
            this.categoryId = 0;
        }
        /*public partsFilter(){

            this.offset = 0;
            this.inStock = false;
            this.isRequested = false;
        }*/
    }

    /**
     * method to fetch the parts & service, reference & price for inventory list
     *
     * @return
     */
    public synchronized ArrayList<InventoryItemBeans> _inventoryList(InventoryFilter filter) {
        ArrayList<InventoryItemBeans> subcategoryList = new ArrayList<>();
        try {

            PreparedStatement stmt = _inventoryListQuery(filter, false);
            if (stmt == null) return subcategoryList;

            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                InventoryItemBeans subCatBeans = new InventoryItemBeans();
                subCatBeans.setIdPiece(String.valueOf(rs.getInt(1)));
                subCatBeans.setPartsService(rs.getString(2));
                subCatBeans.setReference(rs.getString(3));
                subCatBeans.setCostOfItem((rs.getDouble(4)));
                subCatBeans.setIsSerializable((rs.getInt(5)));
                subCatBeans.setCategory(rs.getString(6));
                subCatBeans.setNoOfPieces(String.valueOf(rs.getInt(7)));
                subCatBeans.setDescription(rs.getString(8));
                subcategoryList.add(subCatBeans);
            }
            rs.close();
            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return subcategoryList;
    }

    public synchronized int _inventoryListCount(InventoryFilter filter) {

        int count = 0;

        try {
            PreparedStatement stmt = _inventoryListQuery(filter, true);
            if (stmt == null) return count;

            ResultSet rs = stmt.executeQuery();
            rs.first();
            count = rs.getInt(1);
            rs.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
        }

        return count;

    }


    private int _inventoryPartListCategoryId(String categoryName) {
        int id = 0;

        try {

            PreparedStatement stmt = getConnectionObj().prepareStatement("SELECT ID_CATEGORIE_PIECE FROM TREF_CATEGORIE_PIECE WHERE NM_CATEGORIE_PIECE = :categoryName");
            stmt.set("categoryName", categoryName);

            ResultSet rs = stmt.executeQuery();
            rs.first();
            id = rs.getInt(1);
            rs.close();
            stmt.close();

        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
        }

        return id;
    }

    private PreparedStatement _inventoryListQuery(InventoryFilter filter, boolean isCount) {

        //Setup Base Query
        String query = "SELECT TOP 50 START AT " + filter.offset
                + " p.ID_PIECE,"
                + " p.NM_PIECE,"
                + " p.CD_PRODUIT,"
                + " p.PRIX_PIECE,"
                + " p.FL_SERIALIZABLE,"
                + " cat.NM_CATEGORIE_PIECE,"
                + " s.QUANTITY,p.DESCRIPTION";

        if (isCount) query = "SELECT count(*) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        if (filter.inStock) {
            where += " AND s.QUANTITY > 0 ";
        }
        if (filter.isRequested) {
            joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
            where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";
        }
        if (!TextUtils.isEmpty(filter.category) && filter.categoryId == 0) { //We've select a category, get the ID
            filter.categoryId = _inventoryPartListCategoryId(filter.category);
        }
        if (filter.categoryId > 0) {
            where += " AND p.ID_CATEGORIE_PIECE = :categoryId ";
        }
        if (!TextUtils.isEmpty(filter.searchText)) {
            where += " AND ( p.CD_PRODUIT LIKE :searchText OR p.NM_PIECE LIKE :searchText ";
            if (filter.categoryId == 0)
                where += " OR cat.NM_CATEGORIE_PIECE LIKE :searchText "; //only search category if we have no Id
            where += ") ";
        }


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        //Order by clause when not counting
        query += isCount ? "" : " ORDER BY p.NM_PIECE ASC";

        Logger.log("Q", query.replace(":searchText", "%" + filter.searchText + "%").replace(":categoryId", String.valueOf(filter.categoryId)));

        try {

            PreparedStatement stmt = getConnectionObj().prepareStatement(query);

            if (filter.categoryId > 0) stmt.set("categoryId", filter.categoryId);
            if (!TextUtils.isEmpty(filter.searchText))
                stmt.set("searchText", "%" + filter.searchText + "%");

            return stmt;

        } catch (Exception e) {

            e.printStackTrace();
            Logger.printException(e);
            return null;

        }
    }


    // ---------------------------------------------------PARTS_SERVICES_UPDATED-------------------------------------------------


    //---------------FOR TEST----------------

    /**
     * Fetches all jobs.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionByDateNew() {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + " ORDER BY DT_MEETING DESC,"
                    + "DT_PREF DESC ,"
                    + "NO_INT_CUST ASC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {
                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNearByNew(String gpsX,
                                                                       String gpsY) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "AND CD_STATUT_INTERV = "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' " +
                    "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNew() {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }


                currentJobsBeans.add(currentJobsBean);

            }
            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }


    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionJobPool() {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "ORDER BY "
                    + "NO_INT_CUST ASC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Get start time of the job window.
     *
     * @param id the id
     */
    public synchronized String startTimeJobWindow(int id) {

        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String requiredStartTime = " ";
        String result = " ";
        try {

            query = "SELECT "
                    + "TIME_START "
                    + "FROM T_JOB_WINDOWS "
                    + "WHERE "
                    + "ID_JOB_WINDOW = '" + id
                    + "'";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                if (cursor.getString(1) != null && cursor.getString(1).length() > 0) {
                    result = cursor.getString(1);

                    try {
                        requiredStartTime = getDateWithRequiredpatternForCalander(result, "HH:mm:ss",
                                "hh:mm a");
                    } catch (ParseException e) {
                        e.printStackTrace();
                        requiredStartTime = result;
                    }
                }
            }

        } catch (Exception exc) {
            Logger.printException(exc);
            requiredStartTime = " ";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return requiredStartTime;
    }


    /**
     * Get start time of the job window.
     *
     * @param id the id
     */
    public synchronized String endTimeJobWindow(int id) {

        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String requiredEndTime = " ";
        String result = " ";
        try {

            query = "SELECT "
                    + "TIME_END "
                    + "FROM T_JOB_WINDOWS "
                    + "WHERE "
                    + "ID_JOB_WINDOW = '" + id
                    + "'";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                if (cursor.getString(1) != null && cursor.getString(1).length() > 0) {
                    result = cursor.getString(1);

                    try {
                        requiredEndTime = getDateWithRequiredpatternForCalander(result, "HH:mm:ss",
                                "hh:mm a");
                    } catch (ParseException e) {
                        e.printStackTrace();
                        requiredEndTime = result;
                    }
                }
            }

        } catch (Exception exc) {
            Logger.printException(exc);
            requiredEndTime = " ";
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return requiredEndTime;
    }

    public synchronized String getDTMEETINGList(String id_interv) {
        String result = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = null;

            query = "SELECT DT_MEETING FROM T_INTERVENTIONS WHERE ID_INTERVENTION='"
                    + id_interv + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                result = cursor.getString(1);
            }


        } catch (Exception exc) {
            Logger.printException(exc);
            result = null;
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    public synchronized Vector<CommonJobBean> getAllJobsOfParticularDateNew(String date,
                                                                            int userId) {
        Vector<CommonJobBean> tmp = new Vector<CommonJobBean>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        //Connection connection = getConnectionObj();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {


            String dt_deb_prev = null;

            ;
            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND (DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <= '"
                    + date + "')"
                    + " AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + date
                    + "')" + " AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    try {
                        // schedules jobs
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);
//                    Log.e("2nd query execute : ", "@@@@@@@@@ ");

                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean allJobBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            dt_deb_prev,
                            cursor.getString(36));

                    allJobBean.setDt_deb_real(cursor.getString(34));
                    allJobBean.setDt_fin_real(cursor.getString(35));
                    tmp.add(allJobBean);

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();

            query = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT  AND "
                    + "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                    + date + "')=CURRENT DATE AND DT_FIN IS NULL)" + "AND "
                    + "T_INTERVENTIONS.CD_STATUT_INTERV = 3"
                    + " ORDER BY DT_DEB_PREV";

            // In the above query "AND " +
            // "T_INTERVENTIONS.CD_STATUT_INTERV = 3" this condition is added
            // for calculate started job count only
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    try {
                        dt_deb_prev = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);
//                    Log.e("3rd query execute : ", "@@@@@@@@@ ");

                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean allJobBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            dt_deb_prev,
                            cursor.getString(36));

                    allJobBean.setDt_deb_real(cursor.getString(34));
                    allJobBean.setDt_fin_real(cursor.getString(35));
                    tmp.add(allJobBean);

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            String getSuspendedJobId = "SELECT "
                    + "ID_INTERVENTION,"
                    + "DESCR_INTERVENTION,"
                    + "PRIORITE_INTERVENTION,"
                    + "DT_DEB_PREV,"
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT, "
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT "
                    + "AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + date + "'))" + " ORDER BY DT_DEB_PREV";

            try {
                stmt = getConnectionObj().prepareStatement(getSuspendedJobId);

                cursor = stmt.executeQuery();

                while (cursor.next()) {

                    boolean jobSuspendedStatusonCurrentDate = checkJobSuspendedStatus(
                            date, encodeString(cursor.getBytes(1)));
                    if (jobSuspendedStatusonCurrentDate) {
                        try {
                            // suspended jobs
                            dt_deb_prev = getHeaderDateWithRequiredPattern(
                                    cursor.getString(4), currentDateFormat,
                                    dedlineHeaderFormat);

//                        Logger.log("Date DEbut if ", dt_deb_prev + "");
//                        Log.e("4th query execute : ", "@@@@@@@@@ ");

                        } catch (ParseException e) {
                            Logger.printException(e);
                        }

                        CommonJobBean allJobBean = new CommonJobBean(
                                encodeString(cursor.getBytes(1)),
                                encodeString(cursor.getBytes(2)),
                                cursor.getInt(3),
                                cursor.getString(4),
                                cursor.getString(5),
                                encodeString(cursor.getBytes(6)),
                                encodeString(cursor.getBytes(7)),
                                encodeString(cursor.getBytes(8)),
                                encodeString(cursor.getBytes(9)),
                                cursor.getInt(10),
                                encodeString(cursor.getBytes(11)),
                                encodeString(cursor.getBytes(12)),
                                encodeString(cursor.getBytes(13)),
                                encodeString(cursor.getBytes(14)),
                                encodeString(cursor.getBytes(15)),
                                cursor.getInt(16),
                                cursor.getInt(17),
                                cursor.getString(19),
                                cursor.getString(18),
                                cursor.getString(20),
                                cursor.getString(21),
                                cursor.getInt(22),
                                cursor.getString(23),
                                cursor.getString(24),
                                cursor.getString(25),
                                encodeString(cursor.getBytes(26)),
                                cursor.getInt(27),
                                cursor.getInt(28),
                                cursor.getInt(29),
                                encodeString(cursor.getBytes(30)),
                                cursor.getString(31),
                                cursor.getString(32),
                                cursor.getString(33),
                                dt_deb_prev,
                                cursor.getString(36));

                        allJobBean.setDt_deb_real(cursor.getString(34));
                        allJobBean.setDt_fin_real(cursor.getString(35));


                        tmp.add(allJobBean);
                    }

                }
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
        } catch (ULjException exc) {
            Logger.printException(exc);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (sdf.format(new Date()).equals(date)) {
            try {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                        + "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED;

                stmt = getConnectionObj().prepareStatement(query);

                cursor = stmt.executeQuery();
                String headerDate = null;
                while (cursor.next()) {
                    try {
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

//                        Log.e("5th query execute : ", "@@@@@@@@@   " + date);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }

                    CommonJobBean currentJobsBean = new CommonJobBean(
                            encodeString(cursor.getBytes(1)),
                            encodeString(cursor.getBytes(2)),
                            cursor.getInt(3),
                            cursor.getString(4),
                            cursor.getString(5),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)),
                            encodeString(cursor.getBytes(8)),
                            encodeString(cursor.getBytes(9)),
                            cursor.getInt(10),
                            encodeString(cursor.getBytes(11)),
                            encodeString(cursor.getBytes(12)),
                            encodeString(cursor.getBytes(13)),
                            encodeString(cursor.getBytes(14)),
                            encodeString(cursor.getBytes(15)),
                            cursor.getInt(16),
                            cursor.getInt(17),
                            cursor.getString(19),
                            cursor.getString(18),
                            cursor.getString(20),
                            cursor.getString(21),
                            cursor.getInt(22),
                            cursor.getString(23),
                            cursor.getString(24),
                            cursor.getString(25),
                            encodeString(cursor.getBytes(26)),
                            cursor.getInt(27),
                            cursor.getInt(28),
                            cursor.getInt(29),
                            encodeString(cursor.getBytes(30)),
                            cursor.getString(31),
                            cursor.getString(32),
                            cursor.getString(33),
                            headerDate,
                            cursor.getString(36));

                    currentJobsBean.setDt_deb_real(cursor.getString(34));
                    currentJobsBean.setDt_fin_real(cursor.getString(35));

                    tmp.add(currentJobsBean);
                }
//                cursor.close();
//                stmt.close();
                //connection.commit();
//                connDao.commit();
            } catch (ULjException exc) {
                Logger.printException(exc);
            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
//                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND "
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND "
                    + "T_INTERVENTIONS.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='" + date
                    + "'";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
//                    Log.e("6th query execute : ", "@@@@@@@@@   ");
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                tmp.add(currentJobsBean);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (ULjException exc) {
            Logger.printException(exc);
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Collections.sort(tmp, new Comparator<CommonJobBean>(

        ) {

            @Override
            public int compare(CommonJobBean lhs, CommonJobBean rhs) {
                return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
            }
        });

        // end*********
        return tmp;

    }


    /**
     * Fetches all jobs.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionByDateUpdated(int userId) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "T_INTERVENTIONS.ID_CLIENT, "
                    + "T_INTERVENTIONS.ID_SITE, "
                    + "T_INTERVENTIONS.ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM TREF_TYPE_INTERVENTION,T_INTERVENTIONS " +
                    "LEFT JOIN T_SITES_CLIENTS ON T_INTERVENTIONS.ID_SITE=T_SITES_CLIENTS.ID_SITE_CLIENT " +
                    "LEFT JOIN T_CLIENTS ON T_INTERVENTIONS.ID_CLIENT=T_CLIENTS.ID_CLIENT " +
                    "LEFT JOIN T_EQUIPEMENTS_CLIENTS ON T_INTERVENTIONS.ID_EQUIPEMENT=T_EQUIPEMENTS_CLIENTS.ID_EQUIPEMENT_CLIENT " +
                    "WHERE ((T_INTERVENTIONS.ID_INTERVENTION IN " +
                    "(SELECT ID_INTERVENTION FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION HAVING " +
                    "date(MAX(DT_FIN)) <= CURRENT DATE )" +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4) " +
                    "OR " +
                    "(T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE date(DT_DEB_REAL) < CURRENT DATE " +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4 AND T_INTERVENTIONS.ID_USER!=" + userId + " )) " +
                    "OR (T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE T_INTERVENTIONS.CD_STATUT_INTERV<=3 OR T_INTERVENTIONS.CD_STATUT_INTERV>=5))) " +
                    "AND T_INTERVENTIONS.DT_DEB_PREV IS NOT NULL";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Logger.output(TAG, cursor.getString(4));

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionUpdated(int userId) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "T_INTERVENTIONS.ID_CLIENT, "
                    + "T_INTERVENTIONS.ID_SITE, "
                    + "T_INTERVENTIONS.ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM TREF_TYPE_INTERVENTION,T_INTERVENTIONS " +
                    "LEFT JOIN T_SITES_CLIENTS ON T_INTERVENTIONS.ID_SITE=T_SITES_CLIENTS.ID_SITE_CLIENT " +
                    "LEFT JOIN T_CLIENTS ON T_INTERVENTIONS.ID_CLIENT=T_CLIENTS.ID_CLIENT " +
                    "LEFT JOIN T_EQUIPEMENTS_CLIENTS ON T_INTERVENTIONS.ID_EQUIPEMENT=T_EQUIPEMENTS_CLIENTS.ID_EQUIPEMENT_CLIENT " +
                    "WHERE ((T_INTERVENTIONS.ID_INTERVENTION IN " +
                    "(SELECT ID_INTERVENTION FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION HAVING " +
                    "date(MAX(DT_FIN)) <= CURRENT DATE )" +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4) " +
                    "OR " +
                    "(T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE date(DT_DEB_REAL) < CURRENT DATE " +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4 AND T_INTERVENTIONS.ID_USER!=" + userId + " )) " +
                    "OR (T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE T_INTERVENTIONS.CD_STATUT_INTERV<=3 OR T_INTERVENTIONS.CD_STATUT_INTERV>=5))) " +
                    "AND T_INTERVENTIONS.DT_DEB_PREV IS NOT NULL";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);

                Logger.output(TAG, "addr_interv_ville" + encodeString(cursor.getBytes(8)));
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     *
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNearByUpdated(String gpsX,
                                                                           String gpsY, int userId) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "T_INTERVENTIONS.ID_CLIENT, "
                    + "T_INTERVENTIONS.ID_SITE, "
                    + "T_INTERVENTIONS.ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "FROM TREF_TYPE_INTERVENTION,T_INTERVENTIONS " +
                    "LEFT JOIN T_SITES_CLIENTS ON T_INTERVENTIONS.ID_SITE=T_SITES_CLIENTS.ID_SITE_CLIENT " +
                    "LEFT JOIN T_CLIENTS ON T_INTERVENTIONS.ID_CLIENT=T_CLIENTS.ID_CLIENT " +
                    "LEFT JOIN T_EQUIPEMENTS_CLIENTS ON T_INTERVENTIONS.ID_EQUIPEMENT=T_EQUIPEMENTS_CLIENTS.ID_EQUIPEMENT_CLIENT " +
                    "WHERE ((T_INTERVENTIONS.ID_INTERVENTION IN " +
                    "(SELECT ID_INTERVENTION FROM T_TEMPS_INTERV GROUP BY ID_INTERVENTION HAVING " +
                    "date(MAX(DT_FIN)) <= CURRENT DATE )" +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4) " +
                    "OR " +
                    "(T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE date(DT_DEB_REAL) < CURRENT DATE " +
                    "AND T_INTERVENTIONS.CD_STATUT_INTERV=4 AND T_INTERVENTIONS.ID_USER!=" + userId + " )) " +
                    "OR (T_INTERVENTIONS.ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM T_INTERVENTIONS " +
                    "WHERE T_INTERVENTIONS.CD_STATUT_INTERV<=3 OR T_INTERVENTIONS.CD_STATUT_INTERV>=5))) " +
                    "AND T_INTERVENTIONS.DT_DEB_PREV IS NOT NULL "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' " +
                    "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }


    /**
     * get the global tax list for a  invoice/quotation
     *
     * @return
     */
    public synchronized ArrayList<GlobalTaxInvoiceList> getGlobalTaxInvoice(
            String id) {

        ArrayList<GlobalTaxInvoiceList> invoiceQuotationList = new ArrayList<GlobalTaxInvoiceList>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            //new changes
            String getInvoiceQuotation = "SELECT * FROM T_FACTURE_TAX WHERE ID_REMOTE_FACTURE = '"
                    + id + "'" + " AND DT_SUPPR IS NULL";

            stmt = getConnectionObj().prepareStatement(getInvoiceQuotation);

            cursor = stmt.executeQuery();

            GlobalTaxInvoiceList globalTaxInvoiceList = null;

            while (cursor.next()) {


                globalTaxInvoiceList = new GlobalTaxInvoiceList(cursor.getDouble(3),
                        cursor.getDouble(4), getTaxNameById(cursor.getInt(1)),
                        cursor.getBoolean(2), "" + cursor.getInt(1), cursor.getString(5));

                Logger.log(TAG, "UPDATED TOTAL CALCULATION ID_REMOTE_FACTURE=====>" + cursor.getString(6));

                invoiceQuotationList.add(globalTaxInvoiceList);
            }

        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return invoiceQuotationList;
    }


    /**
     * To get the tax of the corresponding item in invoice/quotation
     *
     * @param idTax
     * @return
     */
    public synchronized String getTaxNameById(int idTax) {
        String taxRate = null;

//        String query = "SELECT NM_TAXRATE FROM T_TAXRATES WHERE ID_TAXRATE="
//                + idTax;

        String query = "SELECT * FROM T_TAXRATES WHERE ID_TAXRATE = '"
                + idTax + "'" + " AND DT_SUPPR IS NULL";

        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                taxRate = cursor.getString(3);
            }
//            cursor.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return taxRate;
    }


    /**
     * insert the global tax list for a  invoice/quotation
     *
     * @return
     */
    public synchronized boolean addGlobalTaxInvoice(String idTaxRate, boolean isCompound,
                                                    double taxRate, double taxValue,
                                                    String invoiceId) {

        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;
        try {

            ps = getConnectionObj().prepareStatement("INSERT INTO T_FACTURE_TAX " +
                    "(ID_TAXRATE,FL_COMPOUND,VAL_TAXRATE,VAL_TVA,ID_REMOTE,ID_REMOTE_FACTURE,DT_SUPPR )"
                    + "VALUES(?,?,?,?,?,?,NULL)");


            ps.set(1, idTaxRate);
            ps.set(2, isCompound);
            ps.set(3, taxRate);
            ps.set(4, taxValue);
            ps.set(5, uniqueId);
            ps.set(6, invoiceId);

            ps.execute();

            Logger.log(TAG, "UNIQUE_ID VALUE ADDITEM====>" + uniqueId);

            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    /**
     * update the global item for a  invoice/quotation
     *
     * @return
     */
    public synchronized boolean updateGlobalTaxInvoice(boolean isCompound,
                                                       String id_remote, double taxRateValue) {

        boolean result = false;
        PreparedStatement ps = null;
        try {


            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURE_TAX SET FL_COMPOUND = ?,VAL_TVA = ? WHERE ID_REMOTE = ?");
            ps.set(1, isCompound);
            ps.set(2, taxRateValue);
            ps.set(3, id_remote);

            ps.execute();

            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    /**
     * delete the global item for a  invoice/quotation
     *
     * @return
     */
    public synchronized boolean deleteGlobalTaxInvoice(
            String id) {

        boolean result = false;
        PreparedStatement ps = null;
        try {

            ps = getConnectionObj()
                    .prepareStatement("DELETE T_FACTURE_TAX WHERE ID_REMOTE = ?");
            ps.set(1, id);

            ps.execute();

            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * get the total sum of invoice/quotation
     *
     * @return
     */
    public synchronized double getTotalTaxInvoice(
            String id_remote) {

        double totalAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT SUM(VAL_TVA) AS TOTAL FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '" + id_remote + "'" +
                    "AND DT_SUPPR IS NULL";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getDouble(1);
                Logger.log("Amt", " receivedAmount: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }


    /**
     * get the total sum of invoice/quotation
     *
     * @return
     */
    public synchronized double getSubTotalTaxInvoice(
            String id_remote) {

        double totalAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT SUM(TOTAL_HT) AS TOTAL FROM T_FACTURES WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getDouble(1);
                Logger.log("Amt", " receivedAmount: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }

    /**
     * update the global item for a  invoice/quotation
     *
     * @return
     */
    public synchronized boolean updateTotalOfTaxInvoice(double updatedTotal,
                                                        String id) {

        boolean result = false;
        PreparedStatement ps = null;
        try {


            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURES SET TOTAL_TTC = ? WHERE ID_REMOTE = ?");
            ps.set(1, updatedTotal);
            ps.set(2, id);

            ps.execute();

            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * to delete an invoice or quotation item
     *
     * @param id
     */
    public synchronized void deleteGlobalTaxItem(String id) {

        executeDDL("DELETE FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '" + id
                + "'");
    }


    /**
     * Gets the job resumed time in job details.
     *
     * @param idIntervention the id intervention
     * @return the job resumed time in job details
     */
    public synchronized String[] getInterventionTime(String idIntervention) {
        String[] jobTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {

            query = "SELECT DT_DEB_PREV,DT_FIN_PREV FROM T_INTERVENTIONS WHERE ID_INTERVENTION='"
                    + idIntervention + "'";

            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                try {
                    jobTime = new String[]{resultSet.getString(1),
                            resultSet.getString(2)};

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }
//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobTime;
    }


    public synchronized void getTagsTest() {

        UnavailabilityBeans unavailabilityBeans = null;

        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TAGS ";
            //Connection connection = getConnectionObj();
            PreparedStatement stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            ResultSet cursor = stmt.executeQuery();

            while (cursor.next()) {
                Logger.log(TAG, "TREF TAGS LIST_TAGS ====>" + cursor.getString(5));
            }
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        }


    }


    public synchronized Vector<ReportsJobBean> checkTestQuery(String currentDate, String lastDate) {

        Vector<ReportsJobBean> tmp = new Vector<ReportsJobBean>();
        String query;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            query = "SELECT * "
                    + "FROM T_INTERVENTIONS "
                    + "WHERE "
                    + "(CD_STATUT_INTERV ='5' OR CD_STATUT_INTERV ='6') AND "
                    + "(dateformat(DT_FIN_REAL,'yyyy-mm-dd') >='" + lastDate + "')"
                    + " AND (dateformat(DT_FIN_REAL,'yyyy-mm-dd') <='" + currentDate + "')";

            Logger.log(TAG, "REPORT DETAIL RESULT QUERY===>" + query);

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();


            while (cursor.next()) {

                Logger.log(TAG, "REPORT DETAIL RESULT QUERY===>" + encodeString(cursor.getBytes(1)));


            }

        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return tmp;
    }

    public synchronized double getTotalTaxValueInvoice(
            String id_remote) {

        double totalAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT SUM(TOTAL_TTC) AS TOTAL FROM T_FACTURES WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getDouble(1);
                Logger.log("TOTAL SUM", " TOTAL INVOICE AMT IS====>: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }

    public synchronized boolean updateInvoiceOrQuotationGlobalDisc(String id, double discountValue, double total,
                                                                   boolean discountOption) {

        boolean result = false;
        PreparedStatement ps = null;

        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURES SET DISCOUNT = ?,DISCOUNTPERCENT = ?,TOTAL_TTC = ? " +
                            "WHERE ID_REMOTE = ?");
            ps.set(1, String.format(Locale.US, formatDecimal, discountValue));
            ps.set(2, discountOption);
            ps.set(3, String.format(Locale.US, formatDecimal, total));
            ps.set(4, id);
            ps.execute();


//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    public synchronized double getGlobalDiscountValueInvoice(
            String id_remote) {

        double totalAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT DISCOUNT FROM T_FACTURES WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getDouble(1);
                Logger.log("TOTAL SUM", " TOTAL INVOICE AMT IS====>: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }

    public synchronized boolean getGlobalDiscountOptionInvoice(
            String id_remote) {

        boolean totalAmount = false;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT DISCOUNTPERCENT FROM T_FACTURES WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getBoolean(1);
                Logger.log("TOTAL SUM", " TOTAL INVOICE AMT IS====>: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }

    /**
     * get the total sum of invoice/quotation
     *
     * @return
     */
    public synchronized double getTotalTaxInvoiceNew(
            String id_remote) {

        double totalAmount = 0.00f;
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT SUM(VAL_TVA) AS TOTAL FROM T_FACTURE WHERE ID_REMOTE = '" + id_remote + "'";
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            if (cursor.next()) {
                totalAmount = cursor.getDouble(1);
                Logger.log("Amt", " receivedAmount: " + totalAmount);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return totalAmount;

    }


    public synchronized JobIncidentModel getJobIncident(String idIntervention) {

        Logger.log(TAG, "intervention : " + idIntervention);

        JobIncidentModel incidentModel = null;


        String sql_string = "SELECT * FROM T_INCIDENTS WHERE ID_INTERVENTION='"
                + idIntervention + "'";


        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();


            while (cursor.next()) {

                incidentModel = new JobIncidentModel(cursor.getString(1),
                        cursor.getInt(2), encodeString(cursor.getBytes(3)), cursor.getString(4), cursor.getString(5),
                        cursor.getString(6), cursor.getInt(7), cursor.getInt(8), cursor.getInt(9), cursor.getInt(10),
                        cursor.getInt(11), cursor.getString(12), cursor.getBoolean(13),
                        cursor.getString(14), cursor.getString(15), cursor.getString(16),
                        cursor.getString(17), cursor.getString(18), cursor.getString(19),
                        cursor.getInt(20), cursor.getInt(21), cursor.getInt(22), cursor.getInt(23));

            }

        } catch (Exception e) {
            Logger.log(TAG, "excep  " + e);
            Logger.printException(e);
            incidentModel = null;
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return incidentModel;
    }

    public synchronized JobIncidentLogModel getJobIncidentLog(String idIntervention,
                                                              String idIncident, String action) {

        Logger.log(TAG, "intervention : " + idIntervention);
        Logger.log(TAG, "idIncident : " + idIncident);
        Logger.log(TAG, "action : " + action);

        JobIncidentLogModel incidentLogModel = null;

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();


            stmt = getConnectionObj()
                    .prepareStatement("SELECT DISTINCT ID_INCIDENT_LOG,ID_INCIDENT,ID_CUSTOMER," +
                            "ID_INTERVENTION,ID_USER,ACTION,ACTION_DATE,ACTION_COMMENT," +
                            "ACTION_DURATION FROM T_INCIDENTS_LOG WHERE " +
                            "ID_INTERVENTION = ? AND ID_INCIDENT = ? AND ACTION = ?" +
                            " ORDER BY DT_CREATE ASC");


            stmt.set(1, idIntervention);
            stmt.set(2, idIncident);
            stmt.set(3, action);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                incidentLogModel = new JobIncidentLogModel(cursor.getString(1),
                        cursor.getString(2), cursor.getInt(3), cursor.getString(4),
                        cursor.getInt(5), cursor.getString(6), cursor.getString(7), cursor.getString(8),
                        cursor.getInt(9));

                Logger.log(TAG, "action date check====>  " + cursor.getString(7));
            }

        } catch (Exception e) {
            Logger.log(TAG, "excep  " + e);
            incidentLogModel = null;
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return incidentLogModel;
    }

    public synchronized boolean insertTIncidentLogValues(String idIncident, int idCustomer,
                                                         int idUser, String idIntervention,
                                                         String action, String actionComment,
                                                         int actionDuration) {
        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;
        try {


            ps = getConnectionObj().prepareStatement("INSERT INTO T_INCIDENTS_LOG " +
                    "(ID_INCIDENT_LOG,ID_INCIDENT,ID_CUSTOMER,ID_INTERVENTION," +
                    "ID_USER,ACTION,ACTION_DATE,ACTION_COMMENT,ACTION_DURATION) " +
                    "VALUES (?,?,?,?,?,?,CURRENT UTC TIMESTAMP,?,?)");


            ps.set(1, uniqueId);
            ps.set(2, idIncident);
            ps.set(3, idCustomer);
            ps.set(4, idIntervention);
            ps.set(5, idUser);
            ps.set(6, action);
            ps.set(7, actionComment);
            ps.set(8, actionDuration);

            ps.execute();

            Logger.log(TAG, "UNIQUE_ID VALUE T_INCIDENTS_LOG====>" + uniqueId);

            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    public synchronized boolean updateTIncidentForStartOrResolve(boolean isStart, String idIncident, String status) {
        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;
        String query;
        try {

            if (isStart) {
                query = "UPDATE T_INCIDENTS SET DT_START = CURRENT UTC TIMESTAMP, STATUS = ? WHERE ID_INCIDENT = ?";
            } else {
                query = "UPDATE T_INCIDENTS SET DT_RESOLVE = CURRENT UTC TIMESTAMP, STATUS = ? WHERE ID_INCIDENT = ?";
            }

            ps = getConnectionObj().prepareStatement(query);

            ps.set(1, status);
            ps.set(2, idIncident);

            ps.execute();

            Logger.log(TAG, "UPDATE VALUE T_INCIDENTS====>" + idIncident);

            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    public synchronized boolean updateTIncidentForFreezeOrUnFreeze(boolean isFreeze, String idIncident,
                                                                   String status, int freezeStartOrResolveValue) {
        PreparedStatement ps = null;
        boolean result = false;
        String query;
        try {


            if (isFreeze) {
                query = "UPDATE T_INCIDENTS SET FL_FROZEN = 1 WHERE ID_INCIDENT = ?";
            } else {
                if (status.equalsIgnoreCase("own")) {
                    query = "UPDATE T_INCIDENTS SET FL_FROZEN = 0, FREEZE_START = ? WHERE ID_INCIDENT = ?";
                } else {
                    query = "UPDATE T_INCIDENTS SET FL_FROZEN = 0, FREEZE_RESOLVE = ? WHERE ID_INCIDENT = ?";
                }
            }

            ps = getConnectionObj().prepareStatement(query);

            if (isFreeze) {
                ps.set(1, idIncident);
            } else {
                ps.set(1, freezeStartOrResolveValue);
                ps.set(2, idIncident);
            }
            ps.execute();

            Logger.log(TAG, "UPDATE VALUE T_INCIDENTS====>" + idIncident);

            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    public synchronized String getJobIncidentStatus(String idIncident) {

        String status = null;

        String sql_string = "SELECT STATUS FROM T_INCIDENTS WHERE ID_INCIDENT='"
                + idIncident + "'";

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                status = cursor.getString(1);
            }

        } catch (Exception e) {
            Logger.log(TAG, "excep  " + e);
            Logger.printException(e);
            status = "own";
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return status;
    }


    public synchronized boolean updateInvoiceOrQuotationGlobalDiscNew(String id, double discountValue, double total) {

        boolean result = false;
        PreparedStatement ps = null;

        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        try {


            //Connection connection = getConnectionObj();
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURES SET DISCOUNT = ?,TOTAL_TTC = ? " +
                            "WHERE ID_REMOTE = ?");
            ps.set(1, String.format(Locale.US, formatDecimal, discountValue));

            ps.set(2, String.format(Locale.US, formatDecimal, total));
            ps.set(3, id);
            ps.execute();


//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }


    public synchronized String getNameTechnecian(int userId) {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String user = " ";
        try {


            stmt = getConnectionObj()
                    .prepareStatement("SELECT NOM_USER,PRENOM_USER FROM T_USERS " +
                            "WHERE ID_USER=" + userId);

            cursor = stmt.executeQuery();
            cursor.next();

            user = encodeString(cursor.getBytes(2)) + " " +
                    encodeString(cursor.getBytes(1));
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.log(TAG, " EXCEPTION DURING  ===>" + exc);
            user = "";

        }
        return user;
    }

    public synchronized ArrayList<Integer> getAllTechnecian(String idInter) {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        ArrayList<Integer> user = new ArrayList<>();

        try {

            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_USER FROM T_TEMPS_INTERV WHERE " +
                            "ID_INTERVENTION=? AND FL_AUXILIARY = 1");

            stmt.set(1, idInter);

            cursor = stmt.executeQuery();
            while (cursor.next()) {
                Integer name = cursor.getInt(1);
                user.add(name);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.log(TAG, " EXCEPTION DURING  ===>" + exc);
            user = null;

        }
        return user;
    }

    public synchronized int getMainTechnician(String idInter) {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int user = 0;

        try {

            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_USER FROM T_TEMPS_INTERV WHERE " +
                            "ID_INTERVENTION=? AND FL_SCHEDULED = 1 AND FL_AUXILIARY = 0");
            stmt.set(1, idInter);

            cursor = stmt.executeQuery();
            while (cursor.next()) {
                user = cursor.getInt(1);

            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            user = -1;

        }
        return user;
    }

    public synchronized String getUserLogin(String userName) {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        String user = null;
        try {
//              old query
//            stmt = getConnectionObj()
//                    .prepareStatement("SELECT LOGIN_USER FROM T_USERS");

            stmt = getConnectionObj()
                    .prepareStatement("SELECT LOGIN_USER FROM T_USERS "+
                            "WHERE LOGIN_USER='" + userName + "'");

            cursor = stmt.executeQuery();
            cursor.next();

            user = encodeString(cursor.getBytes(1));

        } catch (Exception exc) {
            Logger.log(TAG, " EXCEPTION  ===>" + exc);
            user = null;

        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return user;
    }

    public synchronized String getEquipementsDetailLink(int idClient, int idSite,
                                                        int idEquipment) {

        String status = null;

        String sql_string;

        sql_string = "SELECT PUBLIC_LINK FROM T_EQUIPEMENTS_CLIENTS WHERE ID_CLIENT="
                + idClient;
        if (idSite != -1 && idSite != 0)
            sql_string += " AND ID_SITE_CLIENT=" + idSite
                    + " AND ID_EQUIPEMENT_CLIENT=" + idEquipment;
        else
            sql_string = sql_string + " AND ID_EQUIPEMENT_CLIENT=" + idEquipment;


        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql_string);
            cursor = stmt.executeQuery();

            while (cursor.next()) {
                status = cursor.getString(1);
            }

        } catch (Exception e) {
            Logger.log(TAG, "excep  " + e);
            Logger.printException(e);
            status = null;
        } finally {

            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return status;
    }

    public synchronized String addDrivingActivityLatLongAndReturnID(int unavailabilityType, String startDate,
                                                                    String endDate, String notesdesc,
                                                                    double startLat, double startLon) {

        Logger.log("TAG", "INSERTING VALUES LAT LONG WHILE CREATING ===>"
                + startLat + "," + startLon);
        int u = getUser().getId();
        String idUser = String.valueOf(u);
        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        try {

            //Connection connection = getConnectionObj();
            ps = getConnectionObj().prepareStatement("INSERT INTO T_CONGE (ID_REMOTE,ID_TYPE_CONGE," +
                    "ID_USER,DT_DEBUT,DT_FIN,NOTES,LAT_START,LNG_START )"
                    + "VALUES(?,?,?,?,?,?,?,?)");

            ps.set(1, uniqueId);
            ps.set(2, unavailabilityType);
            ps.set(3, idUser);
            ps.set(4, startDate);
            ps.set(5, endDate);
            ps.set(6, notesdesc);
            ps.set(7, startLat);
            ps.set(8, startLon);

            ps.execute();
//            ps.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();

        } catch (Exception e) {
            e.printStackTrace();
            uniqueId = null;
        } finally {

            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return uniqueId;
    }


//    public synchronized String getDtFinForRestartJobAndStopJob(String idIntervention) {
//        String dt_Fin = null;
//        PreparedStatement stmt = null;
//        ResultSet cursor = null;
//        try {
//            String query = "SELECT DT_FIN FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '" + idIntervention + "'";
//            //Connection connection = getConnectionObj();
//            stmt = getConnectionObj().prepareStatement(query);
//
//            cursor = stmt.executeQuery();
//
//            while (cursor.next()) {
//                dt_Fin = cursor.getString(1);
//                Logger.log("  PAU_STOP", "CHECK JOB START STOP Dt_Fin " + dt_Fin);
//            }
//
////            cursor.close();
////            stmt.close();
//            //connection.commit();
////            connDao.commit();
//            //connection.release();
//        } catch (Exception e) {
//            Logger.printException(e);
//        } finally {
//            if (cursor != null) {
//                try {
//                    cursor.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            if (stmt != null) {
//                try {
//                    stmt.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            try {
//                connDao.commit();
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
//
//        return dt_Fin;
//
//    }

    public synchronized String getDateDetailsJob(String idIntervention) {
        String dt_Fin = null;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String query = "SELECT ID_TEMPS_INTERV," +
                    "DT_FIN,DT_DEBUT,DT_FIN_PREV,FL_SCHEDULED,FL_AUXILIARY " +
                    "FROM T_TEMPS_INTERV WHERE ID_INTERVENTION = '" + idIntervention + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                dt_Fin = cursor.getString(1);
                Logger.log(" T_TEMPS_INTERV", "VALUES IN T_TEMPS_INTERV FOR DT_FIN  " + cursor.getString(2));
                Logger.log(" T_TEMPS_INTERV", "VALUES IN T_TEMPS_INTERV FOR DT_DEBUT  " + cursor.getString(3));
                Logger.log(" T_TEMPS_INTERV", "VALUES IN T_TEMPS_INTERV FOR DT_FIN_PREV  " + cursor.getString(3));
                Logger.log(" T_TEMPS_INTERV", "VALUES IN T_TEMPS_INTERV FOR FL_SCHEDULED AND " +
                        "FL_AUXILIARY  " + cursor.getInt(5) + " " + cursor.getInt(6));

                Logger.log(" T_TEMPS_INTERV", "VALUES IN T_TEMPS_INTERV FOR ID_TEMPS_INTERV  " + cursor.getString(1));
            }

//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return dt_Fin;

    }

    /**
     * Query to add a new invoice or quotation from mobile
     *
     * @param idInterv    = job id
     * @param flag        = 0 if quotaion; 1 if invoice
     * @param createdDate = date of creation
     * @param uniqueId
     * @return
     */
    public synchronized boolean duplicationInvoiceOrQuotation(String idInterv, int flag,
                                                              String createdDate,
                                                              String invoiceQuotationId, String uniqueId, boolean flInvoiceStrict) {


        int customerId = getIdCustomer();

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.US);
        String s = sdf.format(System.currentTimeMillis());

        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
        String s1 = sdf1.format(System.currentTimeMillis());

        int u = getUser().getId();

        String idUser = String.valueOf(u);
        int idCustomer = getIdCustomer();

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        String query;
        try {

            query = "SELECT "
                    + "ID_CUSTOMER,"
                    + "ID_INTERVENTION ,"
                    + "FL_FACTURE ,"
                    + "ID_CLIENT ,"
                    + "ID_SITE ,"
                    + "TOTAL_HT ,"
                    + "VAL_TVA ,"
                    + "TOTAL_TTC ,"
                    + "DISCOUNT ,"
                    + "DISCOUNTPERCENT "
                    + "FROM T_FACTURES WHERE ID_REMOTE ='"
                    + invoiceQuotationId + "'";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {

                    PreparedStatement ps;
                    // v55 updated
                    ps = getConnectionObj().prepareStatement("INSERT INTO T_FACTURES(" + "ID_REMOTE,"
                            + "ID_CUSTOMER," + "ID_INTERVENTION," + "FL_FACTURE,"
                            + "DT_CREATE," + "ID_CLIENT," + "ID_SITE," + "TOTAL_HT,"
                            + "VAL_TVA," + "TOTAL_TTC," + "DISCOUNT," +
                            "DISCOUNTPERCENT," + "FL_INV_STRICT," + "NO_INT_FACTURE_DEVIS )" + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,0)");
                    ps.set(1, uniqueId);
                    ps.set(2, customerId);
                    ps.set(3, idInterv);
                    ps.set(4, flag);
                    ps.set(5, createdDate);
                    ps.set(8, cursor.getDouble(6));
                    ps.set(9, cursor.getDouble(7));
                    ps.set(10, cursor.getDouble(8));
                    ps.set(11, cursor.getDouble(9));
                    ps.set(12, cursor.getBoolean(10));
                    ps.set(13, flInvoiceStrict);

                    int idClient = cursor.getInt(4);
                    int idSite = cursor.getInt(5);

                    if (idClient == -1) {
                        ps.setNull(6);
                        Log.e("idClientNULL", "idClientNULL: " + idClient);
                    } else if (idClient == 0) {
                        ps.setNull(6);
                        Log.e("idClientNULL", "idClientNULL: " + idClient);
                    } else {
                        ps.set(6, idClient);
                        Log.e("idClient", "idClient: " + idClient);
                    }

                    if (idSite == -1) {
                        ps.setNull(7);
                        Log.e("idSiteNULL", "idSiteNULL: " + idSite);
                    } else if (idSite == 0) {
                        ps.setNull(7);
                        Log.e("idSiteNULL", "idSiteNULL: " + idSite);
                    } else {
                        ps.set(7, idSite);
                        Log.e("idSite", "idSite: " + idSite);
                    }


//                    Logger.log("TAG", "INVOICE DUPLICATION VALUES FLAG===>" + flag);
//                    Logger.log("TAG", "INVOICE DUPLICATION VALUES invoiceQuotationId===>" + uniqueId);
//                    Logger.log("TAG", "INVOICE DUPLICATION VALUES TOTAL_TTC===>" + cursor.getDouble(8));

                    ps.execute();
                    ps.close();
                    //connection.commit();
                    connDao.commit();
                }

            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }


    /**
     * To add a new item in invoice or quotation.
     *
     * @param invoiceQuotationId
     * @param invoiceId
     * @return
     */
    public synchronized boolean duplicateAddInvoiceOrQuotationItem(String invoiceQuotationId, String invoiceId) {

        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;

        //formatting the decimal
        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        String query;
        try {


            query = "SELECT "
                    + "REF_LIGNE,"
                    + "DESCR_LIGNE ,"
                    + "PRIX_UNITAIRE ,"
                    + "QUANTITE ,"
                    + "VAL_TAXRATE ,"
                    + "ORDRE ,"
                    + "DISCOUNT ,"
                    + "TOTAL_HT ,"
                    + "VAL_TVA ,"
                    + "TOTAL_TTC ,"
                    + "ID_REMOTE_FACTURE ,"
                    + "DESCRIPTION ,"
                    + "DISCOUNTPERCENT ,"
                    + "ID_REMOTE "
                    + "FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE ='"
                    + invoiceQuotationId + "'" + " AND DT_SUPPR IS NULL ORDER BY ORDRE";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            try {
                while (cursor.next()) {


                    Logger.log("TAG", "INVOICE DUPLICATION VALUES QUANTITE===>" + cursor.getDouble(4));
                    Logger.log("TAG", "INVOICE DUPLICATION VALUES new REMOTE===>" + cursor.getString(14));


                    ps = getConnectionObj().prepareStatement("INSERT INTO T_LIGNES_FACTURE " +
                            "(" +
                            "ID_REMOTE,REF_LIGNE," +
                            "DESCR_LIGNE,PRIX_UNITAIRE," +
                            "QUANTITE,VAL_TAXRATE," +
                            "ORDRE,DISCOUNT," +
                            "TOTAL_HT,VAL_TVA," +
                            "TOTAL_TTC,ID_REMOTE_FACTURE," +
                            "DESCRIPTION,DISCOUNTPERCENT )"
                            + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?)");


                    ps.set(1, uniqueId);
                    ps.set(2, cursor.getString(1));
                    ps.set(3, cursor.getString(2));
                    ps.set(4, cursor.getDouble(3));
                    ps.set(5, cursor.getDouble(4));
                    ps.set(6, cursor.getDouble(5));
                    ps.set(7, cursor.getInt(6));
                    ps.set(8, cursor.getDouble(7));
                    ps.set(9, cursor.getDouble(8));
                    ps.set(10, cursor.getDouble(9));
                    ps.set(11, cursor.getDouble(10));
                    ps.set(12, invoiceId);
                    ps.set(13, cursor.getString(12));
                    ps.set(14, cursor.getBoolean(13));


                    ps.execute();

                    ps.close();

                    connDao.commit();
                }

            } catch (Exception e) {
                Logger.printException(e);
            } finally {
                if (cursor != null) {
                    try {
                        cursor.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                try {
                    connDao.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            return true;
        } catch (Exception e) {
            Logger.printException(e);
            return false;
        }
    }


    /**
     * get the items for a single invoice/quotation
     *
     * @return
     */
    public synchronized ArrayList<Quotation_Items_Beans> getQuotationItemValues(
            String id) {

        ArrayList<Quotation_Items_Beans> invoiceQuotationList = new ArrayList<Quotation_Items_Beans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            //new changes
            String getInvoiceQuotation = "SELECT  "
                    + "REF_LIGNE,"
                    + "DESCR_LIGNE ,"
                    + "PRIX_UNITAIRE ,"
                    + "QUANTITE ,"
                    + "VAL_TAXRATE ,"
                    + "ORDRE ,"
                    + "DISCOUNT ,"
                    + "TOTAL_HT ,"
                    + "VAL_TVA ,"
                    + "TOTAL_TTC ,"
                    + "ID_REMOTE_FACTURE ,"
                    + "DESCRIPTION ,"
                    + "DISCOUNTPERCENT ,"
                    + "ID_REMOTE "
                    + "FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '"
                    + id + "'" + " AND DT_SUPPR IS NULL ORDER BY ORDRE";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(getInvoiceQuotation);

            cursor = stmt.executeQuery();

            Quotation_Items_Beans invoiceQuotationBeans = null;

            while (cursor.next()) {
                invoiceQuotationBeans = new Quotation_Items_Beans(cursor.getString(1), cursor.getString(2),
                        cursor.getDouble(3), cursor.getDouble(4), cursor.getDouble(5), cursor.getInt(6),
                        cursor.getDouble(7), cursor.getDouble(8), cursor.getDouble(9), cursor.getDouble(10),
                        cursor.getString(11), cursor.getString(12), cursor.getBoolean(13), cursor.getString(14));


                invoiceQuotationList.add(invoiceQuotationBeans);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return invoiceQuotationList;
    }

    public synchronized boolean addQuotationItem(Quotation_Items_Beans quotationItemsBeans, String quotationId) {

        String uniqueId = getUniqueId();
        PreparedStatement ps = null;
        boolean result = false;

        //formatting the decimal
        int noAfterDecimal = 2;
        String formatDecimal = "%.2f";
        GestionAcces gestionAcces = getAcces();
        try {
            noAfterDecimal = gestionAcces.getNumDecimals();
            formatDecimal = "%." + noAfterDecimal + "f";
        } catch (Exception e) {
            noAfterDecimal = 2;
            formatDecimal = "%." + noAfterDecimal + "f";
        }

        try {


            ps = getConnectionObj().prepareStatement("INSERT INTO T_LIGNES_FACTURE " +
                    "(ID_REMOTE,REF_LIGNE,DESCR_LIGNE,PRIX_UNITAIRE," +
                    "QUANTITE,VAL_TAXRATE,ORDRE,DISCOUNT," +
                    "TOTAL_HT,VAL_TVA,TOTAL_TTC," +
                    "ID_REMOTE_FACTURE,DESCRIPTION,DISCOUNTPERCENT )"
                    + "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?)");


            ps.set(1, uniqueId);
            ps.set(2, quotationItemsBeans.getREF_LIGNE());
            ps.set(3, quotationItemsBeans.getDESCR_LIGNE());
            ps.set(4, quotationItemsBeans.getPRIX_UNITAIRE());
            ps.set(5, quotationItemsBeans.getQUANTITE());
            ps.set(6, quotationItemsBeans.getVAL_TAXRATE());
            ps.set(7, quotationItemsBeans.getORDRE());
            ps.set(8, quotationItemsBeans.getDISCOUNT());
            ps.set(9, quotationItemsBeans.getTOTAL_HT());
            ps.set(10, quotationItemsBeans.getVAL_TVA());
            ps.set(11, quotationItemsBeans.getTOTAL_TTC());
            ps.set(12, quotationId);
            ps.set(13, quotationItemsBeans.getDESCRIPTION());
            ps.set(14, quotationItemsBeans.isDISCOUNTPERCENT());

            ps.execute();


            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        } finally {
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    /**
     * Gets the nbre nl.
     *
     * @param jobId
     * @return the nbre nl
     */
    public synchronized int getTempsCount(String jobId) {
        PreparedStatement stmt;
        ResultSet cursor;

        try {

            String sql = "SELECT COUNT(*)  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
                    + jobId + "' ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            cursor.next();
            int res = cursor.getInt(1);
            cursor.close();
            stmt.close();
            //connection.commit();
            connDao.commit();
            //connection.release();
            return res;
        } catch (Exception e) {
            Logger.printException(e);
            return 0;
        }
    }

    public synchronized String getJobFinalTimeInJobDetails(String idIntervention) {
        String jobSuspendedTime = null;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {

            query = "SELECT DT_FIN FROM T_TEMPS_INTERV WHERE ID_INTERVENTION='"
                    + idIntervention + "'";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                try {

                    jobSuspendedTime = resultSet.getString(1);

                } catch (Exception e) {
                    Logger.printException(e);
                }
            }
//            resultSet.close();
//            preparedStatement.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return jobSuspendedTime;
    }


    /**
     * Suspended time diffrence.
     *
     * @param jobId the job id
     * @return the long
     */
    public synchronized ArrayList<Long> jobTimeDiffrence(String jobId) {

        ArrayList<Long> listTimeDIff = new ArrayList<>();
        long jobSuspendedTime = 0;
        String query;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int countValue = getTempsCount(jobId);
        try {

            query = "SELECT DT_FIN,DT_DEBUT  FROM T_TEMPS_INTERV  WHERE ID_INTERVENTION='"
                    + jobId + "' AND FL_SCHEDULED=0 ORDER BY DT_DEBUT DESC";
            //Connection connection = getConnectionObj();
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                try {

                    if (!TextUtils.isEmpty(resultSet.getString(1))) {

                        jobSuspendedTime = getJobSuspendTime(resultSet.getString(1),
                                resultSet.getString(2));

                        listTimeDIff.add(jobSuspendedTime);
                        Logger.log(TAG, "JOB DETAIL TIME DT_FIN  VALUE====>" + resultSet.getString(1));
                        Logger.log(TAG, "JOB DETAIL TIME DT_DEBUT  VALUE====>" + resultSet.getString(2));
                    } else {
                        Calendar cal = Calendar.getInstance();
                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss",
                                Locale.US);
                        String currentDate = sdf.format(cal.getTime());

                        jobSuspendedTime = getJobSuspendTime(currentDate,
                                resultSet.getString(2));

                        Logger.log(TAG, "JOB DETAIL TIME DT_FIN  CURRENT VALUE====>" + currentDate);
                        Logger.log(TAG, "JOB DETAIL TIME DT_DEBUT  VALUE====>" + resultSet.getString(2));

                        listTimeDIff.add(jobSuspendedTime);

                    }

                } catch (Exception e) {
                    Logger.log("TAG", "" + e);
                }
            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return listTimeDIff;

    }

    public synchronized int getTypeIntervention(String idInterv) {
        String sql = "SELECT ID_TYPE_INTERVENTION FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        int status = -1;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                status = cursor.getInt(1);
            }
//            cursor.close();
//            stmt.close();
            //connection.commit();
//            connDao.commit();
            //connection.release();
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return status;
    }

    public synchronized ArrayList<String> getInterventionTimeDetails(String idInterv) {
        String sql = "SELECT DT_DEB_PREV,DT_FIN_PREV,DT_DEB_REAL,DT_FIN_REAL" +
                " FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        ArrayList<String> list = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String startedScheduledDateTime = cursor.getString(1);
                String completedScheduledDateTime = cursor.getString(2);
                String startedRealisedDateTime = cursor.getString(3);
                String completedRealisedDateTime = cursor.getString(4);
                list.add(startedScheduledDateTime);
                list.add(completedScheduledDateTime);
                list.add(startedRealisedDateTime);
                list.add(completedRealisedDateTime);

            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return list;
    }

    public synchronized ArrayList<Integer> getInterventionClientDetails(String idInterv) {
        String sql = "SELECT ID_CLIENT,ID_SITE,ID_EQUIPEMENT" +
                " FROM T_INTERVENTIONS WHERE ID_INTERVENTION = '"
                + idInterv + "'";
        ArrayList<Integer> list = new ArrayList<>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(sql);
            cursor = stmt.executeQuery();
            while (cursor.next()) {

                Integer idClient = cursor.getInt(1);
                Integer idSite = cursor.getInt(2);
                Integer idEquipment = cursor.getInt(3);

                list.add(idClient);
                list.add(idSite);
                list.add(idEquipment);


            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return list;
    }

    public synchronized int getMainTechnicianNew(String idInter) {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        int user = 0;

        try {

            stmt = getConnectionObj()
                    .prepareStatement("SELECT ID_USER FROM T_INTERVENTIONS WHERE " +
                            "ID_INTERVENTION=? ");


            stmt.set(1, idInter);
//            stmt.set(1, idUser);
            cursor = stmt.executeQuery();
            while (cursor.next()) {
                user = cursor.getInt(1);
                Logger.log(TAG, " DESCRIPTION TECHNICIAN USER ID VALUE IS  ===>" + user);
            }
            cursor.close();
            stmt.close();
//            connDao.commit();
        } catch (Exception exc) {
            Logger.log(TAG, " DESCRIPTION TECHNICIAN EXCEPTION DURING MAIN TECHNICIAN  ===>" + exc);
            user = 0;

        }
        return user;
    }


    /**
     * Get the shared block using index
     *
     * @param idInterv
     * @param index
     * @return
     */
    public synchronized ArrayList<FamiliesBean> getSBCategoryUpdated(String idInterv, int index,
                                                                     int previousId, int iterationCount) {
        ArrayList<FamiliesBean> familyList = new ArrayList<>();
        String query;
        //Connection connection = getConnectionObj();
        ResultSet cursor = null;
        PreparedStatement stmt = null;

        try {

            query = "SELECT TOP 15 START AT " +
                    index +
                    " b.ID_MODELE_FAMILLE,m.MIN,m.MAX,b.NM_MODELE_FAMILLE," +
                    "b.ITERATION,b.POS,b.OBLIGATOIRE," +
                    "f.FL_SHARED,b.ID_EQUIPEMENT_CLIENT" +
                    " FROM T_SAISIE_BLOC b " +
                    "LEFT JOIN TREF_MODELE_BLOC m" +
                    " ON b.ID_MODELE_RAPPORT=m.ID_MODELE_RAPPORT" +
                    " AND b.ID_MODELE_FAMILLE=m.ID_MODELE_FAMILLE " +
                    "LEFT JOIN TREF_MODELE_FAMILLE f" +
                    " ON b.ID_MODELE_FAMILLE=f.ID_MODELE_FAMILLE" +
                    " WHERE ID_INTERVENTION='" + idInterv + "'" + " " +
                    "ORDER BY b.POS, b.ITERATION";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

//             previousId = 0;
//            int iterationCount = iterationCount;

            while (cursor.next()) {
//                Logger.output("WHOLE FAMILY -- >", "idModelReport " + cursor.getInt(1) + " position " + cursor.getInt(6) + " minimum " + cursor.getInt(2) + " maximum " + cursor.getInt(3)
//                        + "name " + encodeString(cursor.getBytes(4)) + " iteration " + cursor.getInt(5) + " flShared " + cursor.getInt(8) + " obligatoire : " + cursor.getInt(7) + " equipment id : " + cursor.getInt(9));

                FamiliesBean family = new FamiliesBean();
                family.setIdFamily(cursor.getInt(1));
                family.setMin(cursor.getInt(2));
                family.setMax(cursor.getInt(3));
                family.setNameFamily(encodeString(cursor.getBytes(4)));
                family.setIteration(cursor.getInt(5));
                family.setPosition(cursor.getInt(6));
                family.setObligatoire(cursor.getInt(7));
                family.setIsSharedBlock(cursor.getInt(8));
                family.setIdEquip(cursor.getInt(9));

                //check if there is repetive item of same idModelFamille, then add the count of occurence.
                int flShared = cursor.getInt(8);
                if (flShared == 1) {
                    int currentId = cursor.getInt(1);
                    if (previousId == currentId) {
                        iterationCount++;
                    } else {
                        iterationCount = 1;
                    }
                    previousId = currentId;
                }

                family.setIterationCount(iterationCount);

//                Logger.log("TAG", "SHARED BLOCK" +
//                        " ITERATION COUNT ====>"+iterationCount);
                familyList.add(family);
            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return familyList;
    }


    public synchronized int getSBCategoryCount(String idInterv) {
        String query = null;

        query = "SELECT COUNT(*) FROM T_SAISIE_BLOC" +
                " WHERE ID_INTERVENTION ='" + idInterv + "'";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        int count;

        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();
            count = resultSet.getInt(1);

        } catch (Exception e) {
            e.printStackTrace();
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return count;

    }

    public synchronized ArrayList<FamiliesBean> getSBCategorySingleItem(String idInterv, int index,
                                                                        int previousId, int iterationCount) {
        ArrayList<FamiliesBean> familyList = new ArrayList<>();
        String query;
        ResultSet cursor = null;
        PreparedStatement stmt = null;
        try {

            query = "SELECT TOP 1 START AT " +
                    index +
                    " b.ID_MODELE_FAMILLE,m.MIN,m.MAX,b.NM_MODELE_FAMILLE," +
                    "b.ITERATION,b.POS,b.OBLIGATOIRE," +
                    "f.FL_SHARED,b.ID_EQUIPEMENT_CLIENT" +
                    " FROM T_SAISIE_BLOC b " +
                    "LEFT JOIN TREF_MODELE_BLOC m" +
                    " ON b.ID_MODELE_RAPPORT=m.ID_MODELE_RAPPORT" +
                    " AND b.ID_MODELE_FAMILLE=m.ID_MODELE_FAMILLE " +
                    "LEFT JOIN TREF_MODELE_FAMILLE f" +
                    " ON b.ID_MODELE_FAMILLE=f.ID_MODELE_FAMILLE" +
                    " WHERE ID_INTERVENTION='" + idInterv + "'" + " " +
                    "ORDER BY b.POS, b.ITERATION";

            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();

            while (cursor.next()) {

                FamiliesBean family = new FamiliesBean();
                family.setIdFamily(cursor.getInt(1));
                family.setMin(cursor.getInt(2));
                family.setMax(cursor.getInt(3));
                family.setNameFamily(encodeString(cursor.getBytes(4)));
                family.setIteration(cursor.getInt(5));
                family.setPosition(cursor.getInt(6));
                family.setObligatoire(cursor.getInt(7));
                family.setIsSharedBlock(cursor.getInt(8));
                family.setIdEquip(cursor.getInt(9));

                //check if there is repetive item of same idModelFamille, then add the count of occurence.
                int flShared = cursor.getInt(8);
                if (flShared == 1) {
                    int currentId = cursor.getInt(1);
                    if (previousId == currentId) {
                        iterationCount++;
                    } else {
                        iterationCount = 1;
                    }
                    previousId = currentId;
                }

                family.setIterationCount(iterationCount);

                familyList.add(family);
            }
        } catch (Exception e) {
            Logger.printException(e);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return familyList;
    }


    /**
     * Get the job count of the Todays job
     * Suspended , paused , started and auxillary
     *
     * @param date
     * @param userId
     * @param jobCountALone
     * @return
     */
    public synchronized int getTodaysJobCount(Date date, int userId, boolean jobCountALone) {

        int count = 0;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        String query = "";

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            query = "SELECT COUNT(*) " +
                    "FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    "WHERE T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "')" +
                    "AND CD_STATUT_INTERV <= 2) AND " +
                    "((DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + currentDate + "')" +
                    " AND CD_STATUT_INTERV <= 2) ";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }


        try {
            query = "SELECT COUNT(*) FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    "WHERE " +
                    "ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {

            query = "SELECT COUNT(*) FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +
                    "ID_INTERVENTION IN (" +
                    "SELECT DISTINCT ID_INTERVENTION FROM T_TEMPS_INTERV" +
                    " WHERE (" +
                    " DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    ")" +
                    " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED;


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {

            query = "SELECT COUNT(*) FROM T_INTERVENTIONS" +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +
                    "ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(" +
                    " DATEFORMAT(T_TEMPS_INTERV.DT_DEBUT,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    " AND T_TEMPS_INTERV.DT_FIN IS NULL" +
                    ") " +
                    "OR" +
                    " (ID_USER=" + userId +
                    " AND CD_STATUT_INTERV=3)";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }


        if (!jobCountALone) {
            try {

                query = "SELECT COUNT(*) "
                        + "FROM T_CONGE,TREF_TYPE_CONGE" +
                        " WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                        + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                        + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                        + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 ";

                stmt = getConnectionObj().prepareStatement(query);

                cursor = stmt.executeQuery();

                while (cursor.next()) {
                    count = count + cursor.getInt(1);
                }
                cursor.close();
                stmt.close();
            } catch (Exception exc) {
                Logger.printException(exc);
            }
        }

        return count;
    }




    /**
     * Get all the activity list for today
     *
     * @param date
     * @return
     */
    public ArrayList<CommonListBean> getTodaysActivityList(Date date) {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        ArrayList<CommonListBean> activityList = new ArrayList<>();
        try {
            //new changes include travel activity
            String query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                    + "DATEFORMAT(DT_DEBUT,'yyyy-MM-dd') <='" + currentDate
                    + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 " +
                    "ORDER BY DT_DEBUT DESC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String headerDate = "";
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(3), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), headerDate,
                        String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                activityList.add(Conge);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {

            Logger.printException(exc);
        }
        return activityList;
    }

    /**
     * Get all the parameter used for todays jobs
     *
     * @return
     */
    public String getTodayJobColumn() {
        String query = "SELECT "
                + "ID_INTERVENTION,"// t_intervention
                + "DESCR_INTERVENTION,"// t_intervention
                + "PRIORITE_INTERVENTION,"// t_intervention
                + "DT_DEB_PREV,"// t_intervention
                + "DT_FIN_PREV,"
                + "ADR_INTERV_RUE,"
                + "ADR_INTERV_CP,"
                + "ADR_INTERV_VILLE,"
                + "ADR_INTERV_PAYS,"
                + "CD_STATUT_INTERV,"
                + "NOM_CLIENT_INTERV,"
                + "NOM_CONTACT,"
                + "TEL_CONTACT,"
                + "NOM_SITE_INTERV, "
                + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                + "T_INTERVENTIONS.ID_USER,"
                + "GPS_POSX_INTERV,"
                + "GPS_POSY_INTERV,"
                + "ADR_INTERV_GLOBALE,"
                + "ADR_INTERV_COMPLEMENT,"
                + "NO_INT_CUST, "
                + "NM_CLIENT_SIGN ,"
                + "NM_TECH_SIGN ,"
                + "NM_FACTURE_SIGN, "
                + "NOM_EQUIPEMENT_INTERV, "
                + "ID_CLIENT, "
                + "ID_SITE, "
                + "ID_EQUIPEMENT,"
                + "MOBILE_CONTACT,"
                + "DT_MEETING, "
                + "REF_CUSTOMER, "
                + "ID_INTERVENTION_MERE, "
                + "DT_DEB_REAL ,"
                + "DT_FIN_REAL, "
                + "DT_CREATE ";


        return query;
    }

    /**
     * Get all the jobs for today alone
     *
     * @param date
     * @param userId
     * @return
     */
    public synchronized ArrayList<CommonListBean> getTodaysJobList(Date date, int userId) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        ArrayList<CommonListBean> actList = new ArrayList<>();

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;


        String query = getTodayJobColumn();


        try {
            query += "FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    "WHERE  " +
                    "T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND" +
                    " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                    + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                    currentDate + "')) AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))" +

                    " ORDER BY DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd')," +
                    " CD_STATUT_INTERV, DT_DEB_PREV";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
            }


            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }


        try {
            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    "WHERE " +
                    "ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")" +
                    " ORDER BY DT_DEB_PREV";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {
            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +
                    "(" +
                    "CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + currentDate + "'))" +
                    ")" +

                    " ORDER BY DT_DEB_PREV";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {
            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +

                    "ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(date(T_TEMPS_INTERV.DT_DEBUT) <= CURRENT DATE) AND date('"
                    + dateOfToday
                    + "')=CURRENT DATE AND T_TEMPS_INTERV.DT_FIN IS NULL)";

            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query += "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")";

            }
            query += " ORDER BY DT_DEB_PREV";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        //sorting the jobs
        Collections.sort(currentJobsBeans, new Comparator<CommonListBean>() {
            @Override
            public int compare(CommonListBean lhs, CommonListBean rhs) {
                String pattern = "yyyy-mm-dd HH:mm:ss";
                SimpleDateFormat formatter = new SimpleDateFormat(pattern);
                CommonJobBean lhs1 = (CommonJobBean) lhs;
                CommonJobBean rhs1 = (CommonJobBean) rhs;
                try {

                    int result = formatter.parse(lhs1.getDt_deb_prev()).compareTo
                            (formatter.parse(rhs1.getDt_deb_prev()));
                    if (result == 0) {
                        return ("" + lhs1.getNo_interv()).compareToIgnoreCase("" + rhs1.getNo_interv());
                    } else {
                        return formatter.parse(lhs1.getDt_deb_prev()).compareTo
                                (formatter.parse(rhs1.getDt_deb_prev()));
                    }

                } catch (Exception e) {
                    return 0;
                }

            }
        });


        return currentJobsBeans;
    }


    public synchronized CurrentJobDataBean getTodaysJobSortNearBy(Date date, int userId,
                                                                  String gpsX, String gpsY) {
        int numberOfJob = 0;
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();

        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS inter,TREF_TYPE_INTERVENTION type_intr"
                    + " WHERE "
                    + "inter.ID_TYPE_INTERVENTION=type_intr.ID_TYPE_INTERVENTION "
                    + "AND(" +

                    "("
                    + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "') " +
                    "AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                    currentDate + "'))" +

                    " AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                    + ")" +


                    "OR " +
                    "(" +
                    "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                    + dateOfToday
                    + "')=CURRENT DATE AND DT_FIN IS NULL) AND inter.ID_USER="
                    + userId +
                    ")" +


                    " OR " +
                    "(" +
                    "CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (" +
                    "DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + currentDate + "'))" +
                    ")" +


                    "OR " +
                    "(" +
                    "inter.ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")";


            if (sdf.format(new Date()).equals(sdf.format(date))) {
                query += "OR " +
                        "(" +
                        "inter.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")";
            }

            query += ")";

            //For GPS
            query += " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                    + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal))" +
                    " - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) +" +
                    " COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) *" +
                    " COS(RADIANS(CAST(" + gpsX + " AS decimal))) * " +
                    "(POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) -" +
                    " RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";


            Logger.log(TAG, "CURRENT JOB SORT query===>" + query);

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }

            cursor.close();
            stmt.close();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    //adding missing files in rev 1760 from rev 1738

    /**
     * This function Fetches:- 1.All Scheduled Jobs which are sheduled on the
     * date Passed. 2.All the started Jobs which are still running on the date
     * Passed 3.All the suspended jobs which are suspended on the date Passed.
     * 4.All the Auxillary Jobs which are scheduled on the date Passed. 5.All
     * the Auxillary Jobs which are Started if today is the current date of
     * device. 6.All the Auxillary Jobs which are suspended Which were Initially
     * started on the date Passed.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention now
     */
    public synchronized CurrentJobDataBean getCurrentJobs(Date date, int userId) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            } else {
                query = "SELECT  "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            }

            Logger.log(TAG, "CURRENT JOBS query IS====>" + query);

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }


        try {
            //new changes include travel activity
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                    + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                    + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 " +
                    "ORDER BY DT_DEBUT DESC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String headerDate = "";
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(3), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), headerDate,
                        String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                currentJobsBeans.add(Conge);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {

            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    public synchronized int getCurrentJobCount(Date date, int userId) {

        int count = 0;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        String query = "";

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            query = "SELECT COUNT(*) " +
                    "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    "AND T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND " +
                    "((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "')" +
                    "AND CD_STATUT_INTERV <= 2) AND " +
                    "((DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + currentDate + "')" +
                    " AND CD_STATUT_INTERV <= 2) ";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
                Log.e("COUNT","THE CURRENT JOB COUNT>>>>>>>"+count);

            }
            cursor.close();
            stmt.close();


            query = "SELECT COUNT(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();

            query = "SELECT COUNT(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_INTERVENTION IN (" +
                    "SELECT DISTINCT ID_INTERVENTION FROM T_TEMPS_INTERV" +
                    " WHERE (" +
                    " DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    ")" +
                    " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED;


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();


            query = "SELECT COUNT(*) FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(" +
                    " DATEFORMAT(T_TEMPS_INTERV.DT_DEBUT,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    " AND T_TEMPS_INTERV.DT_FIN IS NULL" +
                    ") " +
                    "OR" +
                    " (ID_USER=" + userId +
                    " AND CD_STATUT_INTERV=3)";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();


            query = "SELECT COUNT(*) "
                    + "FROM T_CONGE,TREF_TYPE_CONGE" +
                    " WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                    + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                    + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 ";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                count = count + cursor.getInt(1);
            }
            cursor.close();
            stmt.close();

        } catch (Exception exc) {
            Logger.printException(exc);
        }


        return count;
    }
    
    /**
     * New changes for optimization
     * This function Fetches:- 1.All Scheduled Jobs which are sheduled on the
     * date Passed. 2.All the started Jobs which are still running on the date
     * Passed 3.All the suspended jobs which are suspended on the date Passed.
     * 4.All the Auxillary Jobs which are scheduled on the date Passed. 5.All
     * the Auxillary Jobs which are Started if today is the current date of
     * device. 6.All the Auxillary Jobs which are suspended Which were Initially
     * started on the date Passed.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention now. good
     */
    public synchronized CurrentJobArrayListBean getCurrentJobsArrayList(Date date, int userId, int offset) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +

                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +

                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +

                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +

                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
//                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION,TREF_MODELE_RAPPORT "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
//                        + "AND "
//                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT=TREF_MODELE_RAPPORT.ID_MODELE_RAPPORT AND(" +
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +

                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +

                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +

                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            }

            Logger.log(TAG, "CURRENT JOBS query IS====>" + query);
            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                Logger.log(TAG, "CURRENT JOBS ID_VALUES IS====>" + encodeString(cursor.getBytes(1)));
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("0th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                Logger.log(TAG, "CURRENT JOBS INTER_NO IS====>" + currentJobsBean.getNo_interv());
                currentJobsBeans.add(currentJobsBean);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }


        try {
            //new changes include travel activity
            query = "SELECT ID_REMOTE,"
                    + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                    + "DT_DEBUT,"
                    + "DT_FIN,"
                    + "NOTES,"
                    + "NOM_TYPE_CONGE,"
                    + "COULEUR_CONGE,"
                    + "ID_USER,"
                    + "ID_GROUPE,"
                    + "FL_UNAVAILABLE,"
                    + "FL_PAYABLE "
                    + "FROM T_CONGE,TREF_TYPE_CONGE WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                    + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                    + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                    + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 " +
                    "ORDER BY DT_DEBUT DESC";

            //Connection connection = getConnectionObj();
            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String headerDate = "";
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(3), currentDateFormat,
                            dedlineHeaderFormat);

//                    Log.e("5th *******************", "********");

                } catch (ParseException e) {
                    Logger.printException(e);
                }
                Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                        cursor.getString(3), cursor.getString(4),
                        encodeString(cursor.getBytes(5)),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)), headerDate,
                        String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                        cursor.getInt(10), cursor.getInt(11));

                currentJobsBeans.add(Conge);
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {

            Logger.printException(exc);
        }

        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);

        Logger.log(TAG, "CURRENT JOBS COUNT IS====>" + numberOfJob);
        Logger.log(TAG, "CURRENT JOBS currentJobsBeans IS====>" + currentJobsBeans.size());

        return currentJobDataBean;
    }

    /**
     * New Changes for optimisation
     * This function Fetches:- 1.All Scheduled Jobs which are sheduled on the
     * date Passed. 2.All the started Jobs which are still running on the date
     * Passed 3.All the suspended jobs which are suspended on the date Passed.
     * 4.All the Auxillary Jobs which are scheduled on the date Passed. 5.All
     * the Auxillary Jobs which are Started if today is the current date of
     * device. 6.All the Auxillary Jobs which are suspended Which were Initially
     * started on the date Passed.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention now good
     */
    public synchronized CurrentJobArrayListBean getCurrentJobsArrayListForSorting(Date date, int userId) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " ORDER BY DT_DEB_PREV";
            }
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }
//good
    public synchronized CurrentJobArrayListBean getCurrentJobValues(Date date, int userId,boolean jobCountALone, int sortingOption) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<>();
        ArrayList<CommonListBean> activityList = new ArrayList<>();
        int numberOfJob = 0;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);

        String query = "";

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    "AND T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND " +
                    "((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "')" +
                    "AND CD_STATUT_INTERV <= 2) AND " +
                    "((DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + currentDate + "')" +
                    " AND CD_STATUT_INTERV <= 2) ";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 1st call"+currentJobsBeans.size());
            }
            cursor.close();
            stmt.close();

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + " FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_USER!=" + userId
                    + " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                    + currentDate + "'" +
                    ")";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

//            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 2nd call"+currentJobsBeans.size());

            }

            cursor.close();
            stmt.close();

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_INTERVENTION IN (" +
                    "SELECT DISTINCT ID_INTERVENTION FROM T_TEMPS_INTERV" +
                    " WHERE (" +
                    " DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    ")" +
                    " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED;


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 3rd call"+currentJobsBeans.size());

            }
            cursor.close();
            stmt.close();


            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    +"FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "(ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(" +
                    " DATEFORMAT(T_TEMPS_INTERV.DT_DEBUT,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    " AND T_TEMPS_INTERV.DT_FIN IS NULL" +
                    ") " +
                    "OR" +
                    " (ID_USER=" + userId +
                    " AND CD_STATUT_INTERV=3))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);

            }
            cursor.close();
            stmt.close();

            if(!jobCountALone) {
                query = "SELECT ID_REMOTE,"
                        + "TREF_TYPE_CONGE.ID_TYPE_CONGE,"
                        + "DT_DEBUT,"
                        + "DT_FIN,"
                        + "NOTES,"
                        + "NOM_TYPE_CONGE,"
                        + "COULEUR_CONGE,"
                        + "ID_USER,"
                        + "ID_GROUPE,"
                        + "FL_UNAVAILABLE,"
                        + "FL_PAYABLE "
                        + "FROM T_CONGE,TREF_TYPE_CONGE" +
                        " WHERE T_CONGE.ID_TYPE_CONGE=TREF_TYPE_CONGE.ID_TYPE_CONGE AND "
                        + "TREF_TYPE_CONGE.DT_SUPPR IS NULL AND T_CONGE.DT_SUPPR IS NULL AND "
                        + "DATEFORMAT(DT_DEBUT,'yyyy-mm-dd') <='" + currentDate
                        + "' AND TREF_TYPE_CONGE.FL_CLOCK = 0 ";

                stmt = getConnectionObj().prepareStatement(query);

                cursor = stmt.executeQuery();
                while (cursor.next()) {
                    try {
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(3), currentDateFormat,
                                dedlineHeaderFormat);
                    } catch (ParseException e) {
                        Logger.printException(e);
                    }
                    Conge Conge = new Conge(cursor.getString(1), cursor.getInt(2),
                            cursor.getString(3), cursor.getString(4),
                            encodeString(cursor.getBytes(5)),
                            encodeString(cursor.getBytes(6)),
                            encodeString(cursor.getBytes(7)), headerDate,
                            String.valueOf(cursor.getInt(8)), String.valueOf(cursor.getInt(9)),
                            cursor.getInt(10), cursor.getInt(11));

                    currentJobsBeans.add(Conge);
                }

                cursor.close();
                stmt.close();
            }

        } catch (Exception exc) {
            Logger.printException(exc);
        }


        //getting the activity list
        if (sortingOption == KEYS.CurrentJobsSorting.SORT_BY_NONE) {
            activityList = getTodaysActivityList(date);
        }


        if (activityList != null & activityList.size() > 0) {
            currentJobsBeans.addAll(activityList);
        }

        Collections.sort(currentJobsBeans, new Comparator<CommonListBean>() {

            @Override
            public int compare(CommonListBean lhs, CommonListBean rhs) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault());

                String lhsStr = "";
                String rhsStr= "";

                if (lhs.getIsJobBean()) {
                    CommonJobBean lhs1 = (CommonJobBean)lhs;
                    if (lhs1.getDt_deb_prev()!=null)
                        lhsStr = lhs1.getDt_deb_prev();
                } else {
                    Conge lhs1 = (Conge)lhs;
                    if (lhs1.getDtDebut()!=null)
                        lhsStr = lhs1.getDtDebut();
                }

                if (rhs.getIsJobBean()) {
                    CommonJobBean rhs1 = (CommonJobBean)rhs;
                    if (rhs1.getDt_deb_prev() != null)
                        rhsStr = rhs1.getDt_deb_prev();
                } else {
                    Conge rhs1 = (Conge)rhs;
                    if (rhs1.getDtDebut() != null)
                        rhsStr = rhs1.getDtDebut();
                }

                if (lhsStr.isEmpty() || rhsStr.isEmpty()) {
                    return 0;
                }

                try
                {
                    return sdf.parse( lhsStr ).compareTo( sdf.parse( rhsStr ) );
                }
                catch ( ParseException e )
                {
                    e.printStackTrace();
                }
                return 0;
            }
        });


        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);


        return currentJobDataBean;
    }

//good
    public synchronized CurrentJobArrayListBean getCurrentJobValuesWithSorting(Date date, int userId) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<>();
        int count = 0;
        int numberOfJob = 0;

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        String query = "";

        PreparedStatement stmt = null;
        ResultSet cursor = null;

        try {
            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    "AND T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND " +
                    "((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "')" +
                    "AND CD_STATUT_INTERV <= 2) AND " +
                    "((DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + currentDate + "')" +
                    " AND CD_STATUT_INTERV <= 2) ";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 1st call"+currentJobsBeans.size());
            }
            cursor.close();
            stmt.close();

//            query = "SELECT "
//                    + "ID_INTERVENTION,"// t_intervention
//                    + "DESCR_INTERVENTION,"// t_intervention
//                    + "PRIORITE_INTERVENTION,"// t_intervention
//                    + "DT_DEB_PREV,"// t_intervention
//                    + "DT_FIN_PREV,"
//                    + "ADR_INTERV_RUE,"
//                    + "ADR_INTERV_CP,"
//                    + "ADR_INTERV_VILLE,"
//                    + "ADR_INTERV_PAYS,"
//                    + "CD_STATUT_INTERV,"
//                    + "NOM_CLIENT_INTERV,"
//                    + "NOM_CONTACT,"
//                    + "TEL_CONTACT,"
//                    + "NOM_SITE_INTERV, "
//                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
//                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "T_INTERVENTIONS.ID_USER,"
//                    + "GPS_POSX_INTERV,"
//                    + "GPS_POSY_INTERV,"
//                    + "ADR_INTERV_GLOBALE,"
//                    + "ADR_INTERV_COMPLEMENT,"
//                    + "NO_INT_CUST, "
//                    + "NM_CLIENT_SIGN ,"
//                    + "NM_TECH_SIGN ,"
//                    + "NM_FACTURE_SIGN, "
//                    + "NOM_EQUIPEMENT_INTERV, "
//                    + "ID_CLIENT, "
//                    + "ID_SITE, "
//                    + "ID_EQUIPEMENT,"
//                    + "MOBILE_CONTACT,"
//                    + "DT_MEETING, "
//                    + "REF_CUSTOMER, "
//                    + "ID_INTERVENTION_MERE, "
//                    + "DT_DEB_REAL ,"
//                    + "DT_FIN_REAL, "
//                    + "DT_CREATE "
//                    + " FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
//                    " WHERE "
//                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
//                    " AND " +
//                    "ID_USER!=" + userId
//                    + " AND CD_STATUT_INTERV="
//                    + KEYS.CurrentJobs.JOB__SUSPENDED
//                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
//                    + currentDate + "'" +
//                    ")";
//
//
//            stmt = getConnectionObj().prepareStatement(query);
//
//            cursor = stmt.executeQuery();
//
//    //            String headerDate = null;
//            while (cursor.next()) {
//                try {
//                    headerDate = getHeaderDateWithRequiredPattern(
//                            cursor.getString(4), currentDateFormat,
//                            dedlineHeaderFormat);
//                } catch (ParseException e) {
//                    Logger.printException(e);
//                }
//
//                CommonJobBean currentJobsBean = new CommonJobBean(
//                        encodeString(cursor.getBytes(1)),
//                        encodeString(cursor.getBytes(2)),
//                        cursor.getInt(3),
//                        cursor.getString(4),
//                        cursor.getString(5),
//                        encodeString(cursor.getBytes(6)),
//                        encodeString(cursor.getBytes(7)),
//                        encodeString(cursor.getBytes(8)),
//                        encodeString(cursor.getBytes(9)),
//                        cursor.getInt(10),
//                        encodeString(cursor.getBytes(11)),
//                        encodeString(cursor.getBytes(12)),
//                        encodeString(cursor.getBytes(13)),
//                        encodeString(cursor.getBytes(14)),
//                        encodeString(cursor.getBytes(15)),
//                        cursor.getInt(16),
//                        cursor.getInt(17),
//                        cursor.getString(19),
//                        cursor.getString(18),
//                        cursor.getString(20),
//                        cursor.getString(21),
//                        cursor.getInt(22),
//                        cursor.getString(23),
//                        cursor.getString(24),
//                        cursor.getString(25),
//                        encodeString(cursor.getBytes(26)),
//                        cursor.getInt(27),
//                        cursor.getInt(28),
//                        cursor.getInt(29),
//                        encodeString(cursor.getBytes(30)),
//                        cursor.getString(31),
//                        cursor.getString(32),
//                        cursor.getString(33),
//                        headerDate,
//                        cursor.getString(36));
//
//                currentJobsBean.setDt_deb_real(cursor.getString(34));
//                currentJobsBean.setDt_fin_real(cursor.getString(35));
//                numberOfJob++;
//                currentJobsBeans.add(currentJobsBean);
//                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 2nd call"+currentJobsBeans.size());
//
//            }
//
//            cursor.close();
//            stmt.close();

            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "ID_INTERVENTION IN (" +
                    "SELECT DISTINCT ID_INTERVENTION FROM T_TEMPS_INTERV" +
                    " WHERE (" +
                    " DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    ")" +
                    " AND CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED;


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 3rd call"+currentJobsBeans.size());

            }
            cursor.close();
            stmt.close();


            query = "SELECT "
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE "
                    +"FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION " +
                    " WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION " +
                    " AND " +
                    "(ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(" +
                    " DATEFORMAT(T_TEMPS_INTERV.DT_DEBUT,'yyyy-mm-dd') ='" + currentDate + "'" +
                    ")" +
                    " AND T_TEMPS_INTERV.DT_FIN IS NULL" +
                    ") " +
                    "OR" +
                    " (ID_USER=" + userId +
                    " AND CD_STATUT_INTERV=3))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);

            }
            cursor.close();
            stmt.close();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        Collections.sort(currentJobsBeans, new Comparator<CommonListBean>() {

            @Override
            public int compare(CommonListBean lhs, CommonListBean rhs) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault());

                String lhsStr = "";
                String rhsStr= "";

                if (lhs.getIsJobBean()) {
                    CommonJobBean lhs1 = (CommonJobBean)lhs;
                    if (lhs1.getDt_deb_prev()!=null)
                        lhsStr = lhs1.getDt_deb_prev();
                } else {
                    Conge lhs1 = (Conge)lhs;
                    if (lhs1.getDtDebut()!=null)
                        lhsStr = lhs1.getDtDebut();
                }

                if (rhs.getIsJobBean()) {
                    CommonJobBean rhs1 = (CommonJobBean)rhs;
                    if (rhs1.getDt_deb_prev() != null)
                        rhsStr = rhs1.getDt_deb_prev();
                } else {
                    Conge rhs1 = (Conge)rhs;
                    if (rhs1.getDtDebut() != null)
                        rhsStr = rhs1.getDtDebut();
                }

                if (lhsStr.isEmpty() || rhsStr.isEmpty()) {
                    return 0;
                }

                try
                {
                    return sdf.parse( lhsStr ).compareTo( sdf.parse( rhsStr ) );
                }
                catch ( ParseException e )
                {
                    e.printStackTrace();
                }
                return 0;
            }
        });

        Log.e("CHECK","QURREY CALLED>>>>>>>>ENDED");

        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    /**
     * new changes for Optimisation
     * Gets the all categorie niveau.
     *
     * @param i           the i
     * @param nom         the nom
     * @param scrollIndex the scroll index
     * @return the all categorie niveau
     * @throws Exception the u lj exception
     */
    public synchronized ArrayList<Categorie> getAllCategorieNiveauOffset(int i, String nom,
                                                                         int scrollIndex,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();
        String query = "";

        query = "SELECT TOP 20 START AT " + offset
                + " TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
                + "FROM TREF_CATEGORIE_PIECE where TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";


        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

//    public synchronized int getAllCategoryCount(int i, String nom,
//                                                int scrollIndex){
//        int count = 0;
//        String query = "";
//
//        query = "SELECT COUNT(*)"
//                + "FROM TREF_CATEGORIE_PIECE where TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";
//
//
//        if (!TextUtils.isEmpty(nom))
//            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
//        query += " ORDER BY NM_CATEGORIE_PIECE ";
//
//        PreparedStatement stmt = null;
//        ResultSet cursor = null;
//        try {
//            stmt = getConnectionObj().prepareStatement(query);
//
//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            cursor = stmt.executeQuery();
//            while (cursor.next()) {
//                count = count + cursor.getInt(1);
//
//            }
//            cursor.close();
//            stmt.close();
//
//        } catch (Exception e) {
//            Logger.printException(e);
//        }
//            return count;
//            }


    //  extra >>>>>>>>>>>>>>>>>>>>getting Category Count
//    public synchronized int getAllCategoryCount(String nom) {
//        String query = null;
//
////
////        query = "SELECT COUNT(*)"
////                + "FROM TREF_CATEGORIE_PIECE where TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";
////
//
//        query = "SELECT"
//                + " TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
//                + "FROM TREF_CATEGORIE_PIECE where TREF_CATEGORIE_PIECE.DT_SUPPR is NULL ";
//
//        if (!TextUtils.isEmpty(nom))
//            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
//        query += " ORDER BY NM_CATEGORIE_PIECE ";
//
//        PreparedStatement preparedStatement = null;
//        ResultSet resultSet = null;
//        int count;
//
//        try {
//            preparedStatement = getConnectionObj().prepareStatement(query);
//            resultSet = preparedStatement.executeQuery();
//            resultSet.first();
//            count = resultSet.getInt(1);
//
//        } catch (Exception e) {
//            e.printStackTrace();
//            Logger.printException(e);
//            count = 0;
//        } finally {
//            if (resultSet != null) {
//                try {
//                    resultSet.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//            if (preparedStatement != null) {
//                try {
//                    preparedStatement.close();
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//            }
//
//        }
//
//        return count;
//
//    }


    //getting All Category Inventory Count
    public synchronized int getAllCategoryInventoryCount(String nom) {
        int count = 0;
        String query = "";

        //new query changes
        query = "SELECT COUNT(DISTINCT TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE)  " +
                "FROM " +
                "TREF_PIECES INNER JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE WHERE " +
                "TREF_PIECES.DT_SUPPR IS NULL " +
                "AND TREF_PIECES.FL_TRACK_STOCK = 1";


        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";


        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;


        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            resultSet = preparedStatement.executeQuery();
            resultSet.first();
            count = resultSet.getInt(1);

        } catch (Exception e) {
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }

        return count;
    }


    public synchronized ArrayList<Categorie> getCategoryNameList(int i,  String nom ,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        //new query changes
        query = "SELECT " +
                "DISTINCT TOP 20 START AT " + offset +
                " TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, " +
                "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE FROM " +
                "TREF_PIECES INNER JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE WHERE " +
                "TREF_PIECES.DT_SUPPR IS NULL " +
                "AND TREF_PIECES.FL_TRACK_STOCK = 1";

        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");


            cursor = stmt.executeQuery();

            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                    Logger.log(TAG, "SUB_CATEGORY item name is =====>" + map.getNomcat());
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                    }
                }
            }

            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    // new change for optimisation
    public synchronized ArrayList<Categorie> getStockRequestCategoryInventoryNewWithOffset(int i, String nom, int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query = "SELECT " +
                "TOP 20 START AT " + offset +
                "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE," +
                " TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE " +
                "FROM ((TREF_PIECES LEFT JOIN TREF_CATEGORIE_PIECE ON " +
                "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE) LEFT JOIN " +
                "T_STOCK_PIECES ON T_STOCK_PIECES.ID_PIECE = TREF_PIECES.ID_PIECE)" +
                " LEFT JOIN T_PIECE_DEMANDE ON T_PIECE_DEMANDE.ID_PIECE = " +
                "TREF_PIECES.ID_PIECE WHERE TREF_PIECES.DT_SUPPR IS NULL" +
                " AND TREF_PIECES.FL_TRACK_STOCK = 1 AND" +
                " T_PIECE_DEMANDE.FL_TRANSFER = 0 AND " +
                "T_PIECE_DEMANDE.DT_COMPLETED IS NULL AND T_STOCK_PIECES.QUANTITY > 0";

        if (!TextUtils.isEmpty(nom))
            query += "AND TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }


    public synchronized ArrayList<Categorie> getStockCategorieNiveauNewWithOffset(int i, String nom,
                                                                                  int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query = "SELECT " +
                "TOP 20 START AT " + offset +
                "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, " +
                "TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE FROM " +
                "(TREF_PIECES LEFT JOIN T_STOCK_PIECES ON T_STOCK_PIECES.ID_PIECE " +
                "= TREF_PIECES.ID_PIECE) LEFT JOIN TREF_CATEGORIE_PIECE " +
                "ON TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE = " +
                "TREF_PIECES.ID_CATEGORIE_PIECE where " +
                "TREF_PIECES.DT_SUPPR IS NULL AND T_STOCK_PIECES.QUANTITY > 0 " +
                "AND TREF_PIECES.FL_TRACK_STOCK = 1";

        if (!TextUtils.isEmpty(nom))
            query += "AND TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY TREF_CATEGORIE_PIECE.NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
//            while (cursor.next()) {
//
//                String nm = encodeString(cursor.getBytes(2));
//
//                String[] temp = nm.split("\\|");
//
//                //new logic
//                int idCat;
//                if ((temp.length - (i + 1)) == 0) {
//                    idCat = cursor.getInt(1);
//                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
//                    if (!cats.contains(map))
//                        cats.add(map);
//                } else {
//                    idCat = 0;
//                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
//
//                    if (!catNameList.contains(map.getNomcat())) {
//                        catNameList.add(map.getNomcat());
//                        cats.add(map);
//                    }
//                }
//            }
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                    }
                }

                Log.e("CHECK","StockCategorieNiveauNew IS CALLED>>>>");
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }


        return cats;
    }
    public synchronized ArrayList<Categorie> getRequestCategoryInventoryWithOffset(int i, String nom,
                                                                                   int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        String query = "";
        ArrayList<String> catNameList = new ArrayList<>();

        query =  "SELECT " +
                "TOP 20 START AT " + offset +
                "TREF_CATEGORIE_PIECE.ID_CATEGORIE_PIECE, NM_CATEGORIE_PIECE "
                + "FROM TREF_CATEGORIE_PIECE " +
                "where ID_CATEGORIE_PIECE IN (SELECT TREF_PIECES.ID_CATEGORIE_PIECE FROM TREF_PIECES WHERE DT_SUPPR IS NULL AND FL_TRACK_STOCK = 1 " +
                "AND TREF_PIECES.ID_PIECE IN (SELECT T_PIECE_DEMANDE.ID_PIECE FROM T_PIECE_DEMANDE WHERE TREF_PIECES.ID_PIECE = T_PIECE_DEMANDE.ID_PIECE AND FL_TRANSFER = 0 AND DT_COMPLETED IS NULL)) ";

        if (!TextUtils.isEmpty(nom))
            query += "AND NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY NM_CATEGORIE_PIECE ";
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    public synchronized int getAllCategoryCount(String nom) {
        int count = 0;
        String query = "";

        query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) " +
                " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON "
                + " cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 " ;

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;


        try {
            preparedStatement = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                preparedStatement.set(1, nom + "%");

            resultSet = preparedStatement.executeQuery();
            resultSet.first();
            count = resultSet.getInt(1);


        } catch (Exception e) {
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }

        return count;
    }

    public synchronized int getStockRequestAllCategoryCount(String nom) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) "
                + " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }

    public synchronized int getStockAllCategoryCount(String nom) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

//        String searchText="a";
//        if (!TextUtils.isEmpty(searchText)) {
//            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";
//        }



        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();
            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }

    public synchronized int getRequestAllCategoryCount(String nom) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }

    public synchronized int getAllCategoryPartsCount(String nom) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT cat.ID_CATEGORIE_PIECE) ";

        query += "FROM TREF_CATEGORIE_PIECE cat " +
                "where cat.DT_SUPPR is NULL ";


        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";


        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }


    public synchronized ArrayList<Categorie> getAllCategory(int i, String nom,
                                                            int scrollIndex,
                                                            int categoryOffset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();
        int cnt = 0;

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + categoryOffset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON "
                + " cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 " ;

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");


            cursor = stmt.executeQuery();

            while (cursor.next()) {
                cnt++;
                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

//                Logger.log(TAG,"CATEGORY NAME IS===>"+nm);

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    Logger.log(TAG,"CATEGORY NAME IS IF ===>"+temp[i]);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG,"CATEGORY NAME IS ELSE ===>"+temp[i]);
                    }
                }


            }

            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }


    public synchronized ArrayList<Categorie> getStockRequestAllCategory(int i, String nom,
                                                                        int scrollIndex,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Stock
        where += " AND s.QUANTITY > 0 ";

        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

    public synchronized ArrayList<Categorie> getStockAllCategory(int i, String nom,
                                                                 int scrollIndex,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

//        if (!TextUtils.isEmpty(nom))
//            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        String searchText="a";
//        if (!TextUtils.isEmpty(searchText)) {
//            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
//        }


        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

    public synchronized ArrayList<Categorie> getRequestAllCategory(int i, String nom,
                                                                   int scrollIndex,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";

        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

    public synchronized ArrayList<Categorie> getAllCategoryParts(int i, String nom,
                                                                 int scrollIndex,int offset) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += "FROM TREF_CATEGORIE_PIECE cat " +
                "where cat.DT_SUPPR is NULL ";


        if (!TextUtils.isEmpty(nom))
            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

            if (!TextUtils.isEmpty(nom))
                stmt.set(1, nom + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    public synchronized int getStockAllCategoryCountWithSearch(String nom,String searchText) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);
        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//         searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();
            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }
//
//    public synchronized ArrayList<Categorie> getAllCategoryWithSearch(int i, String nom,
//                                                            int scrollIndex,
//                                                            int categoryOffset,String searchText) {
//        ArrayList<Categorie> cats = new ArrayList<Categorie>();
//        ArrayList<String> catNameList = new ArrayList<>();
//        int cnt = 0;
//
//        //Setup Base Query
//        String query = "SELECT DISTINCT TOP 20 START AT " + categoryOffset
//                + "cat.ID_CATEGORIE_PIECE, "
//                +" cat.NM_CATEGORIE_PIECE ";
//
//        query += " FROM TREF_PIECES p"
//                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON "
//                + " cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
//                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 " ;
//
//        if (!TextUtils.isEmpty(nom))
//            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";
//
//        if (!TextUtils.isEmpty(searchText))
//            query += " AND ( cat.NM_CATEGORIE_PIECE LIKE ? ";
//
//
//        query += " ORDER BY NM_CATEGORIE_PIECE ";
//
//        PreparedStatement stmt = null;
//        ResultSet cursor = null;
//        try {
//            stmt = getConnectionObj().prepareStatement(query);
//
//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");
//
//
//            cursor = stmt.executeQuery();
//
//            while (cursor.next()) {
//                cnt++;
//                String nm = encodeString(cursor.getBytes(2));
//
//                String[] temp = nm.split("\\|");
//
////                Logger.log(TAG,"CATEGORY NAME IS===>"+nm);
//
//                //new logic
//                int idCat;
//                if ((temp.length - (i + 1)) == 0) {
//                    idCat = cursor.getInt(1);
//                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
//                    Logger.log(TAG,"CATEGORY NAME IS IF ===>"+temp[i]);
//                    if (!cats.contains(map))
//                        cats.add(map);
//                } else {
//                    idCat = 0;
//                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
//
//                    if (!catNameList.contains(map.getNomcat())) {
//                        catNameList.add(map.getNomcat());
//                        cats.add(map);
//                        Logger.log(TAG,"CATEGORY NAME IS ELSE ===>"+temp[i]);
//                    }
//                }
//
//
//            }
//
//            cursor.close();
//            stmt.close();
//
//        } catch (Exception e) {
//            Logger.printException(e);
//        }
//        return cats;
//    }

    public synchronized int getStockRequestAllCategoryCountWithSearch(String nom,String searchText) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) "
                + " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }



    public synchronized ArrayList<Categorie> getStockRequestAllCategoryWithSearch(int i, String nom,
                                                                                  int scrollIndex,int offset,String searchText) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Stock
        where += " AND s.QUANTITY > 0 ";

        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);
//
//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

//    public synchronized int getStockAllCategoryCountWithSearch(String nom,String searchText) {
//        int count=0;
//
//        //Setup Base Query
//        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) ";
//
//        query += " FROM TREF_PIECES p"
//                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
//                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
//                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";
//
//        String joins = "";
//        String where = "";
//
//        //if Stock
//        where += " AND s.QUANTITY > 0 ";
//
//        query = query.replace("#JOINS#", joins);
//        query = query.replace("#WHERE#", where);
//
//        if (!TextUtils.isEmpty(nom))
//            query += "AND cat.NM_CATEGORIE_PIECE LIKE ? ";
//
//        if (!TextUtils.isEmpty(searchText)) {
//            where += " AND ( cat.NM_CATEGORIE_PIECE LIKE ? ";
//            where += ") ";
//        }
//
//        Logger.log("Q", "QUERY VALUES IS===>"+query);
//
//
//        PreparedStatement stmt = null;
//        ResultSet cursor = null;
//        try {
//            stmt = getConnectionObj().prepareStatement(query);
//
//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");
//
//            cursor = stmt.executeQuery();
//            cursor.first();
//            count = cursor.getInt(1);
//
//            cursor.close();
//            stmt.close();
//        } catch (Exception e) {
//            Logger.printException(e);
//            count=0;
//        }
//
//        return count;
//    }


    public synchronized ArrayList<Categorie> getStockAllCategoryWithSearch(int i, String nom,
                                                                           int scrollIndex,int offset,String searchText) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " LEFT JOIN T_STOCK_PIECES s ON p.ID_PIECE = s.ID_PIECE"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";

        //if Stock
        where += " AND s.QUANTITY > 0 ";

        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//         searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }

    public synchronized int getRequestAllCategoryCountWithSearch(String nom,String searchText) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }
        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }

    public synchronized ArrayList<Categorie> getRequestAllCategoryWithSearch(int i, String nom,
                                                                             int scrollIndex,int offset,String searchText) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE #JOINS#"
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 #WHERE#";

        String joins = "";
        String where = "";


        //if Request
        joins += " LEFT JOIN T_PIECE_DEMANDE d ON d.ID_PIECE = p.ID_PIECE ";
        where += " AND d.FL_TRANSFER = 0 AND d.DT_COMPLETED IS NULL ";


        query = query.replace("#JOINS#", joins);
        query = query.replace("#WHERE#", where);

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }


        //Order by clause when not counting
        query += " ORDER BY cat.NM_CATEGORIE_PIECE ASC";

        Logger.log("Q", "QUERY VALUES IS===>"+query);

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");


            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return cats;
    }
    public synchronized int getAllCategoryPartsCountWithSearch(String nom,String searchText) {
        int count=0;

        //Setup Base Query
        String query = "SELECT Count (DISTINCT cat.ID_CATEGORIE_PIECE) ";

        query += "FROM TREF_CATEGORIE_PIECE cat " +
                "where cat.DT_SUPPR is NULL ";


        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        Logger.log("Q", "QUERY VALUES IS===>"+query);


        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");

            cursor = stmt.executeQuery();

            cursor.first();
            count = cursor.getInt(1);

            cursor.close();
            stmt.close();
        } catch (Exception e) {
            Logger.printException(e);
            count=0;
        }

        return count;
    }

    public synchronized ArrayList<Categorie> getAllCategoryPartsWithSearch(int i, String nom,
                                                                           int scrollIndex,int offset,String searchText) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + offset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += "FROM TREF_CATEGORIE_PIECE cat " +
                "where cat.DT_SUPPR is NULL ";



        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        // order by categories
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");


            cursor = stmt.executeQuery();
            while (cursor.next()) {

                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG, "SUB_CATEGORY item name is =====>" + temp[i]);
                    }
                }
            }
            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }

    public synchronized int getAllCategoryCountWithSearch(String nom,String searchText) {
        int count = 0;
        String query = "";

        query = "SELECT Count (DISTINCT p.ID_CATEGORIE_PIECE) " +
                " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON "
                + " cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 " ;

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;


        try {
            preparedStatement = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                preparedStatement.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                preparedStatement.set(2, searchText + "%");


            resultSet = preparedStatement.executeQuery();
            resultSet.first();
            count = resultSet.getInt(1);


        } catch (Exception e) {
            Logger.printException(e);
            count = 0;
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }

        return count;
    }


    public synchronized ArrayList<Categorie> getAllCategoryWithSearch(int i, String nom,
                                                                      int scrollIndex,
                                                                      int categoryOffset,String searchText) {
        ArrayList<Categorie> cats = new ArrayList<Categorie>();
        ArrayList<String> catNameList = new ArrayList<>();
        int cnt = 0;

        //Setup Base Query
        String query = "SELECT DISTINCT TOP 20 START AT " + categoryOffset
                + "cat.ID_CATEGORIE_PIECE, "
                +" cat.NM_CATEGORIE_PIECE ";

        query += " FROM TREF_PIECES p"
                + " INNER JOIN TREF_CATEGORIE_PIECE cat ON "
                + " cat.ID_CATEGORIE_PIECE=p.ID_CATEGORIE_PIECE "
                + " WHERE p.DT_SUPPR is NULL AND p.FL_TRACK_STOCK = 1 " ;

        if (!TextUtils.isEmpty(nom))
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + nom + "%' ";

//        searchText="a";
        if (!TextUtils.isEmpty(searchText)) {
            query+="AND cat.NM_CATEGORIE_PIECE LIKE '%" + searchText + "%' ";
        }

        // order by categories
        query += " ORDER BY NM_CATEGORIE_PIECE ";

        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            stmt = getConnectionObj().prepareStatement(query);

//            if (!TextUtils.isEmpty(nom))
//                stmt.set(1, nom + "%");
//
//            if (!TextUtils.isEmpty(searchText))
//                stmt.set(2, searchText + "%");



            cursor = stmt.executeQuery();

            while (cursor.next()) {
                cnt++;
                String nm = encodeString(cursor.getBytes(2));

                String[] temp = nm.split("\\|");

//                Logger.log(TAG,"CATEGORY NAME IS===>"+nm);

                //new logic
                int idCat;
                if ((temp.length - (i + 1)) == 0) {
                    idCat = cursor.getInt(1);
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);
                    Logger.log(TAG,"CATEGORY NAME IS IF ===>"+temp[i]);
                    if (!cats.contains(map))
                        cats.add(map);
                } else {
                    idCat = 0;
                    Categorie map = new Categorie(idCat, temp[i], temp.length, i + 1);

                    if (!catNameList.contains(map.getNomcat())) {
                        catNameList.add(map.getNomcat());
                        cats.add(map);
                        Logger.log(TAG,"CATEGORY NAME IS ELSE ===>"+temp[i]);
                    }
                }


            }

            cursor.close();
            stmt.close();

        } catch (Exception e) {
            Logger.printException(e);
        }
        return cats;
    }




    class MyObserver implements SyncObserver {
        float last_progress;
        int second_progress = 0;

        public boolean syncProgress(int state, SyncResult result) {
            if (DialogUtils.showProgress == false) {
                return false; // Always continue synchronization.
            }

            int totalTable = result.getTotalTableCount();
            int tableSync = result.getSyncedTableCount();
            float progress = 0.0F;

            if(firstSynch) { // on the first sync, ignore the update DB steps.
                if(state >= RECEIVING_TABLE ) {
                    progress = (float) (tableSync * 100.0 / totalTable);
                } else {
                    progress = 1.0f;
                }
            } else {
                progress = (float) (tableSync * 50.0 / totalTable);

                if(state >= RECEIVING_TABLE ) {
                    progress += 50;
                }
            }

            if (last_progress != progress) { // new table sync
                second_progress = (int)progress;
            } else {
                second_progress +=1;
                if (second_progress >= 100) // loopback second_progress
                    second_progress = (int)progress;
            }

            last_progress = progress;

            DialogUtils.updateProgress((int)progress, second_progress);
/*
            Log.e("MyObserver",
                    "" +
                     "sync progress state = " + state
                            + " bytes sent = " + result.getSentByteCount()
                            + " bytes received = " + result.getReceivedByteCount()
                            + " progress = " + progress
                            + " second_progress = " + second_progress
            );
            */
            return false; // Always continue synchronization.
        }
        public MyObserver() { } // The default constructor.
    }

    /**
     * Update the status of NO_INT_FACTURE_DEVIS when the value is null.
     *
     * @param statut the statut
     * @param invoiceQuotationId
     *
     */
    public synchronized boolean updateFacturesInvoice(String invoiceQuotationId, int statut) {

        boolean result = false;
        PreparedStatement ps = null;

        Logger.log(TAG, "VALUE INVOICE IS" +
                " NO_INT_FACTURE_DEVIS DAO BEFORE====>" + statut);

        try {
            ps = getConnectionObj()
                    .prepareStatement("UPDATE T_FACTURES SET NO_INT_FACTURE_DEVIS = ? " +
                            "WHERE ID_REMOTE = ?");
            ps.set(1, statut);
            ps.set(2, invoiceQuotationId);

            ps.execute();
            ps.close();


            result = true;
        } catch (Exception e) {
            Logger.printException(e);
            result = false;
        }
        return result;
    }

    /**
     *  For checking purpose
     *  GET the value of NO_INT_FACTURE_DEVIS
     *
     * @param invoiceQuotationId
     * @return
     */
    public synchronized int getInvoiceNoFactures(String invoiceQuotationId) {

        int result=0;

        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            String query;

            query="SELECT NO_INT_FACTURE_DEVIS FROM  T_FACTURES " +
                    "WHERE ID_REMOTE = ?";

            preparedStatement = getConnectionObj().prepareStatement(query);
            preparedStatement.set(1, invoiceQuotationId);

            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                result=cursor.getInt(1);
                Logger.log(TAG, "VALUE INVOICE IS" +
                        " NO_INT_FACTURE_DEVIS DAO AFTER====>" + cursor.getInt(1));
            }
            cursor.close();
            preparedStatement.close();

        } catch (Exception e) {
            e.printStackTrace();
            result=0;
        }

        return result;
    }

    public synchronized CurrentJobArrayListBean getTodaysJobs(Date date, int userId,
                                                         int sortingOption) {

        Logger.log(TAG, "Calling the fetch current job query===>" + date);


        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        ArrayList<CommonListBean> actList = new ArrayList<>();

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;


        String query = getTodayJobColumn();


        try {
            query += "FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    "WHERE  " +
                    "T_INTERVENTIONS.DT_SUPPR IS NULL " +
                    "AND" +

                    //new
//                    " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='" + currentDate + "')" +
//                    "AND CD_STATUT_INTERV <= 2) AND " +
//                    "((DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" + currentDate + "')" +
//                    " AND CD_STATUT_INTERV <= 2) " +

                    //old
                    " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                    + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >= '" +
                    currentDate + "')) AND ((CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED1
                    + ") OR (CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))" +

                    " ORDER BY DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd')," +
                    " CD_STATUT_INTERV, DT_DEB_PREV";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 1st call"+currentJobsBeans.size());
            }


            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

//   Commented This Query becuse there is a duplicate in Todays Jobs for Auxillary Technicians.
//        try {
//            query = getTodayJobColumn();
//
//            query += " FROM T_INTERVENTIONS " +
//                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
//                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
//                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
//                    "WHERE " +
//                    "ID_USER!=" + userId
//                    + " AND CD_STATUT_INTERV="
//                    + KEYS.CurrentJobs.JOB__SUSPENDED
//                    + " AND (DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
//                    + currentDate + "'" +
//                    ")" +
//                    " ORDER BY DT_DEB_PREV";
//
//
//            stmt = getConnectionObj().prepareStatement(query);
//
//            cursor = stmt.executeQuery();
//            String headerDate = null;
//            while (cursor.next()) {
//                try {
//                    headerDate = getHeaderDateWithRequiredPattern(
//                            cursor.getString(4), currentDateFormat,
//                            dedlineHeaderFormat);
//
//                } catch (ParseException e) {
//                    Logger.printException(e);
//                }
//
//
//                CommonJobBean currentJobsBean = new CommonJobBean(
//                        encodeString(cursor.getBytes(1)),
//                        encodeString(cursor.getBytes(2)),
//                        cursor.getInt(3),
//                        cursor.getString(4),
//                        cursor.getString(5),
//                        encodeString(cursor.getBytes(6)),
//                        encodeString(cursor.getBytes(7)),
//                        encodeString(cursor.getBytes(8)),
//                        encodeString(cursor.getBytes(9)),
//                        cursor.getInt(10),
//                        encodeString(cursor.getBytes(11)),
//                        encodeString(cursor.getBytes(12)),
//                        encodeString(cursor.getBytes(13)),
//                        encodeString(cursor.getBytes(14)),
//                        encodeString(cursor.getBytes(15)),
//                        cursor.getInt(16),
//                        cursor.getInt(17),
//                        cursor.getString(19),
//                        cursor.getString(18),
//                        cursor.getString(20),
//                        cursor.getString(21),
//                        cursor.getInt(22),
//                        cursor.getString(23),
//                        cursor.getString(24),
//                        cursor.getString(25),
//                        encodeString(cursor.getBytes(26)),
//                        cursor.getInt(27),
//                        cursor.getInt(28),
//                        cursor.getInt(29),
//                        encodeString(cursor.getBytes(30)),
//                        cursor.getString(31),
//                        cursor.getString(32),
//                        cursor.getString(33),
//                        headerDate,
//                        cursor.getString(36));
//
//                currentJobsBean.setDt_deb_real(cursor.getString(34));
//                currentJobsBean.setDt_fin_real(cursor.getString(35));
//                numberOfJob++;
//
//                currentJobsBeans.add(currentJobsBean);
//                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 2nd call"+currentJobsBeans.size());
//            }
//            cursor.close();
//            stmt.close();
//        } catch (Exception exc) {
//            Logger.printException(exc);
//        }

        try {
            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +

                    //new
//                    "ID_INTERVENTION IN (" +
//                    "SELECT DISTINCT ID_INTERVENTION FROM T_TEMPS_INTERV" +
//                    " WHERE " +
//                    "(" +
//                    " DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='" + currentDate + "'" +
//                    ")" +
//                    ")" +
//                    " AND CD_STATUT_INTERV="
//                    + KEYS.CurrentJobs.JOB__SUSPENDED +

                    //old
                    "(" +
                    "CD_STATUT_INTERV="
                    + KEYS.CurrentJobs.JOB__SUSPENDED
                    + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                    + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                    + currentDate + "'))" +
                    ")" +

                    " ORDER BY DT_DEB_PREV";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 3rd call"+currentJobsBeans.size());
            }
            cursor.close();
            stmt.close();
        } catch (Exception exc) {
            Logger.printException(exc);
        }

        try {
            query = getTodayJobColumn();

            query += " FROM T_INTERVENTIONS " +
                    " INNER JOIN TREF_TYPE_INTERVENTION ON" +
                    " TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION=" +
                    "T_INTERVENTIONS.ID_TYPE_INTERVENTION " +
                    " WHERE " +

                    "ID_INTERVENTION IN (" +
                    "SELECT ID_INTERVENTION FROM T_TEMPS_INTERV WHERE " +
                    "(date(T_TEMPS_INTERV.DT_DEBUT) <= CURRENT DATE) AND date('"
                    + dateOfToday
                    + "')=CURRENT DATE AND T_TEMPS_INTERV.DT_FIN IS NULL)";

            if (sdf.format(new Date()).equals(sdf.format(date))) {

                //old
                query += "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")";

//                query += "OR" +
//                    " (ID_USER=" + userId +
//                    " AND CD_STATUT_INTERV=3)";

            }
            query += " ORDER BY DT_DEB_PREV";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }


                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;

                currentJobsBeans.add(currentJobsBean);
                Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 4th call"+currentJobsBeans.size());
            }
            cursor.close();
            stmt.close();

        } catch (Exception exc) {
            Logger.printException(exc);
        }


        //getting the activity list
        if (sortingOption == KEYS.CurrentJobsSorting.SORT_BY_NONE) {
            actList = getTodaysActivityList(date);
        }

        //sorting the jobs
        Collections.sort(currentJobsBeans, new Comparator<CommonListBean>() {
            @Override
            public int compare(CommonListBean lhs, CommonListBean rhs) {
                String pattern = "yyyy-mm-dd HH:mm:ss";
                SimpleDateFormat formatter = new SimpleDateFormat(pattern);
                CommonJobBean lhs1 = (CommonJobBean) lhs;
                CommonJobBean rhs1 = (CommonJobBean) rhs;
                try {

                    int result = formatter.parse(lhs1.getDt_deb_prev()).compareTo
                            (formatter.parse(rhs1.getDt_deb_prev()));
                    if (result == 0) {
                        return ("" + lhs1.getNo_interv()).compareToIgnoreCase("" + rhs1.getNo_interv());
                    } else {
                        return formatter.parse(lhs1.getDt_deb_prev()).compareTo
                                (formatter.parse(rhs1.getDt_deb_prev()));
                    }

                } catch (Exception e) {
                    return 0;
                }

            }
        });

        if (actList != null & actList.size() > 0) {
            currentJobsBeans.addAll(actList);
        }

        //sorting the header date
        Collections.sort(currentJobsBeans, new Comparator<CommonListBean>() {

            @Override
            public int compare(CommonListBean lhs, CommonListBean rhs) {
                return lhs.getHeaderDate().compareTo(rhs.getHeaderDate());
            }
        });

        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
//        Log.e("ArrayCheck","size>>>>>>>>>>>>>>>>>>>> of 5th call"+currentJobsBeans.size());

    }

    public synchronized boolean showGallery() {
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        Boolean galleryOption = false;

        try {
            String query="SELECT FL_MOB_LIVE_PICTURE_ONLY FROM TREF_GESTION_ACCES ";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            cursor.next();

            galleryOption = cursor.getBoolean(1);
            cursor.close();
            stmt.close();
//            connDao.commit();
//            connNew.release();
        } catch (Exception exc) {
            Logger.printException(exc);

        }
        return galleryOption;
    }

    /**
     * new addition for travel activity payable
     * @return
     */
    public synchronized ArrayList<UnavailabilityBeans> getSimilarTravelActivitiesPayable(int flPayable) {

        ArrayList<UnavailabilityBeans> unavailabilitiesTypeList = new ArrayList<UnavailabilityBeans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            String getAllUnavailabilityTypes = "SELECT * FROM TREF_TYPE_CONGE WHERE FL_DRIVING = 1 " +
                    "AND FL_PAYABLE = " + flPayable +
                    " ORDER BY NOM_TYPE_CONGE ASC";
//            Connection connection = getConnectionObj();

            stmt = getConnectionObj()
                    .prepareStatement(getAllUnavailabilityTypes);

            cursor = stmt.executeQuery();

            UnavailabilityBeans unavailabilityBeans = null;

            while (cursor.next()) {
                unavailabilityBeans = new UnavailabilityBeans();

                unavailabilityBeans.setCustomerID(cursor.getInt(5));
                unavailabilityBeans.setUnavailabilityColorCode(cursor
                        .getString(3));
                unavailabilityBeans.setUnavailabilityID(cursor.getInt(1));
                unavailabilityBeans.setUnavailabilityName(cursor.getString(2));

                unavailabilitiesTypeList.add(unavailabilityBeans);

            }
//            cursor.close();
//            stmt.close();
//            connDao.commit();
//            connection.release();
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return unavailabilitiesTypeList;

    }

    /**
     * New changes for optimisation
     * This function Fetches:- 1.All Scheduled Jobs which are sheduled on the
     * date Passed. 2.All the started Jobs which are still running on the date
     * Passed 3.All the suspended jobs which are suspended on the date Passed.
     * 4.All the Auxillary Jobs which are scheduled on the date Passed. 5.All
     * the Auxillary Jobs which are Started if today is the current date of
     * device. 6.All the Auxillary Jobs which are suspended Which were Initially
     * started on the date Passed.
     *
     * @param date   the date
     * @param userId the user id
     * @return the all intervention now. good
     */
    public synchronized CurrentJobArrayListBean getCurrentJobsArrayListNearBy(Date date, int userId, String gpsX, String gpsY) {

        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<>();
        String query;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
        String currentDate = sdf.format(date);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
                currentDateFormat, Locale.US);
        String dateOfToday = simpleDateFormat.format(date);

        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {
            if (sdf.format(new Date()).equals(sdf.format(date))) {

                query = "SELECT TOP 10 "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                        + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__STARTED +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                        + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                        + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                        + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))"
                ;
            } else {
                query = "SELECT "
                        + "ID_INTERVENTION,"// t_intervention
                        + "DESCR_INTERVENTION,"// t_intervention
                        + "PRIORITE_INTERVENTION,"// t_intervention
                        + "DT_DEB_PREV,"// t_intervention
                        + "DT_FIN_PREV,"
                        + "ADR_INTERV_RUE,"
                        + "ADR_INTERV_CP,"
                        + "ADR_INTERV_VILLE,"
                        + "ADR_INTERV_PAYS,"
                        + "CD_STATUT_INTERV,"
                        + "NOM_CLIENT_INTERV,"
                        + "NOM_CONTACT,"
                        + "TEL_CONTACT,"
                        + "NOM_SITE_INTERV, "
                        + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                        + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                        + "T_INTERVENTIONS.ID_USER,"
                        + "GPS_POSX_INTERV,"
                        + "GPS_POSY_INTERV,"
                        + "ADR_INTERV_GLOBALE,"
                        + "ADR_INTERV_COMPLEMENT,"
                        + "NO_INT_CUST, "
                        + "NM_CLIENT_SIGN ,"
                        + "NM_TECH_SIGN ,"
                        + "NM_FACTURE_SIGN, "
                        + "NOM_EQUIPEMENT_INTERV, "
                        + "ID_CLIENT, "
                        + "ID_SITE, "
                        + "ID_EQUIPEMENT,"
                        + "MOBILE_CONTACT,"
                        + "DT_MEETING, "
                        + "REF_CUSTOMER, "
                        + "ID_INTERVENTION_MERE, "
                        + "DT_DEB_REAL ,"
                        + "DT_FIN_REAL, "
                        + "DT_CREATE "
                        + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                        + "WHERE "
                        + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                        + "AND(" +
                        "("
                        + " ((DATEFORMAT(DT_DEB_PREV,'yyyy-mm-dd') <='"
                        + currentDate + "') AND (DATEFORMAT(DT_FIN_PREV,'yyyy-mm-dd') >='" +
                        currentDate + "')) AND ((CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED1
                        + ") OR (CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB_NOT_STARTED2 + "))"
                        + ")" +
                        "OR " +
                        "(" +
                        "ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (date(DT_DEBUT) <= CURRENT DATE) AND date('"
                        + dateOfToday
                        + "')=CURRENT DATE AND DT_FIN IS NULL) AND T_INTERVENTIONS.ID_USER="
                        + userId +
                        ")" +
                        "OR " +
                        "(" +
                        "CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND ID_INTERVENTION IN (SELECT ID_INTERVENTION FROM "
                        + "T_TEMPS_INTERV WHERE (DATEFORMAT(DT_FIN,'yyyy-mm-dd') ='"
                        + currentDate + "'))" +
                        ")" +
                        "OR " +
                        "(" +
                        "T_INTERVENTIONS.ID_USER!=" + userId
                        + " AND CD_STATUT_INTERV="
                        + KEYS.CurrentJobs.JOB__SUSPENDED
                        + " AND DATEFORMAT(DT_DEB_REAL,'yyyy-mm-dd')='"
                        + currentDate + "'" +
                        ")" +
                        ")"
                        + " AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                        + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                        + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' "
                        + "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";
            }
            stmt = getConnectionObj().prepareStatement(query);
            cursor = stmt.executeQuery();
            String headerDate = null;
            while (cursor.next()) {
                try {
                    headerDate = getHeaderDateWithRequiredPattern(
                            cursor.getString(4), currentDateFormat,
                            dedlineHeaderFormat);
                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBeans.add(currentJobsBean);
            }
        } catch (Exception exc) {
            Logger.printException(exc);
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        CurrentJobArrayListBean currentJobDataBean = new CurrentJobArrayListBean(
                currentJobsBeans, numberOfJob);

        return currentJobDataBean;
    }

    public synchronized CurrentJobDataBean getAllInterventionByDateNewWithOffset(int offset) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT " +
                    "TOP 20 START AT " + offset
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
//                    + "TREF_MODELE_RAPPORT.NM_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + " ORDER BY DT_MEETING DESC,"
                    + "DT_PREF DESC ,"
                    + "NO_INT_CUST ASC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {
                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     * with offset
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNearByNewWithOffset(String gpsX,
                                                                       String gpsY,int offset) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT " +
                    "TOP 20 START AT " + offset
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "AND CD_STATUT_INTERV = "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + "AND GPS_POSX_INTERV IS NOT NULL AND GPS_POSY_INTERV IS NOT NULL "
                    + "AND LTRIM(GPS_POSX_INTERV) != '' AND LTRIM(GPS_POSY_INTERV) != '' "
                    + "AND LOWER(GPS_POSX_INTERV) != 'null' AND LOWER(GPS_POSY_INTERV) != 'null' " +
                    "ORDER BY 6366 * 2 * ASIN(SQRT(POWER((SIN((RADIANS(CAST(GPS_POSY_INTERV AS decimal)) - RADIANS(CAST(" + gpsX + " AS decimal))) / 2)), 2) + COS(RADIANS(CAST(GPS_POSY_INTERV AS decimal))) * COS(RADIANS(CAST(" + gpsX + " AS decimal))) * (POWER(SIN(((RADIANS(CAST(GPS_POSX_INTERV AS decimal)) - RADIANS(CAST(" + gpsY + " AS decimal))) / 2)), 2))))";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));

                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     * with offset
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionJobPoolWithOffset(int offset) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT " +
                    "TOP 20 START AT " + offset
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1 "
                    + "ORDER BY "
                    + "NO_INT_CUST ASC";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }

                currentJobsBeans.add(currentJobsBean);

            }

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }

        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }

    /**
     * Fetches all completed jobs by date.
     * with offset
     * @return the all intervention before
     */
    public synchronized CurrentJobDataBean getAllInterventionNewWithOffset(int offset) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT " +
                    "TOP 20 START AT " + offset
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
//                    + KEYS.CurrentJobs.JOB_NOT_STARTED2 + " "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1" + " "
                    + "ORDER BY PRIORITE_INTERVENTION DESC";


            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }


                currentJobsBeans.add(currentJobsBean);

            }
            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobDataBean;
    }


    public synchronized ArrayList<CommonListBean> getJobPoolSearchWithOffset(int offset, String value) {
        ArrayList<CommonListBean> currentJobsBeans = new ArrayList<CommonListBean>();
        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT " +
                    "TOP 20 START AT " + offset
                    + "ID_INTERVENTION,"// t_intervention
                    + "DESCR_INTERVENTION,"// t_intervention
                    + "PRIORITE_INTERVENTION,"// t_intervention
                    + "DT_DEB_PREV,"// t_intervention
                    + "DT_FIN_PREV,"
                    + "ADR_INTERV_RUE,"
                    + "ADR_INTERV_CP,"
                    + "ADR_INTERV_VILLE,"
                    + "ADR_INTERV_PAYS,"
                    + "CD_STATUT_INTERV,"
                    + "NOM_CLIENT_INTERV,"
                    + "NOM_CONTACT,"
                    + "TEL_CONTACT,"
                    + "NOM_SITE_INTERV, "
                    + "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION,"
                    + "T_INTERVENTIONS.ID_MODELE_RAPPORT,"
                    + "T_INTERVENTIONS.ID_USER,"
                    + "GPS_POSX_INTERV,"
                    + "GPS_POSY_INTERV,"
                    + "ADR_INTERV_GLOBALE,"
                    + "ADR_INTERV_COMPLEMENT,"
                    + "NO_INT_CUST, "
                    + "NM_CLIENT_SIGN ,"
                    + "NM_TECH_SIGN ,"
                    + "NM_FACTURE_SIGN, "
                    + "NOM_EQUIPEMENT_INTERV, "
                    + "ID_CLIENT, "
                    + "ID_SITE, "
                    + "ID_EQUIPEMENT,"
                    + "MOBILE_CONTACT,"
                    + "DT_MEETING, "
                    + "REF_CUSTOMER, "
                    + "ID_INTERVENTION_MERE, "
                    + "DT_DEB_REAL ,"
                    + "DT_FIN_REAL, "
                    + "DT_CREATE, "
                    + "T_INTERVENTIONS.FL_POOL,"
                    + "T_INTERVENTIONS.DT_PREF,"
                    + "ID_JOB_WINDOW "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1"
            +"AND (" +
                    "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION LIKE '%" + value + "%' " +
                    "OR NOM_CLIENT_INTERV LIKE '%" + value + "%' " +
                    "OR REF_CUSTOMER LIKE '%" + value + "%'" +
                    "OR NO_INT_CUST LIKE '%" + value + "%'" +
                    " OR NOM_SITE_INTERV LIKE '%" + value + "%'"+
                    " OR NOM_EQUIPEMENT_INTERV LIKE '%" + value + "%'"+
                    ") ORDER BY TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();
            String headerDate = " ";
            while (cursor.next()) {

                try {
                    if (cursor.getString(4) != null && cursor.getString(4).length() > 0)
                        headerDate = getHeaderDateWithRequiredPattern(
                                cursor.getString(4), currentDateFormat,
                                dedlineHeaderFormat);

                } catch (ParseException e) {
                    Logger.printException(e);
                }

                CommonJobBean currentJobsBean = new CommonJobBean(
                        encodeString(cursor.getBytes(1)),
                        encodeString(cursor.getBytes(2)),
                        cursor.getInt(3),
                        cursor.getString(4),
                        cursor.getString(5),
                        encodeString(cursor.getBytes(6)),
                        encodeString(cursor.getBytes(7)),
                        encodeString(cursor.getBytes(8)),
                        encodeString(cursor.getBytes(9)),
                        cursor.getInt(10),
                        encodeString(cursor.getBytes(11)),
                        encodeString(cursor.getBytes(12)),
                        encodeString(cursor.getBytes(13)),
                        encodeString(cursor.getBytes(14)),
                        encodeString(cursor.getBytes(15)),
                        cursor.getInt(16),
                        cursor.getInt(17),
                        cursor.getString(19),
                        cursor.getString(18),
                        cursor.getString(20),
                        cursor.getString(21),
                        cursor.getInt(22),
                        cursor.getString(23),
                        cursor.getString(24),
                        cursor.getString(25),
                        encodeString(cursor.getBytes(26)),
                        cursor.getInt(27),
                        cursor.getInt(28),
                        cursor.getInt(29),
                        encodeString(cursor.getBytes(30)),
                        cursor.getString(31),
                        cursor.getString(32),
                        cursor.getString(33),
                        headerDate,
                        cursor.getString(36));

                currentJobsBean.setDt_deb_real(cursor.getString(34));
                currentJobsBean.setDt_fin_real(cursor.getString(35));
                numberOfJob++;
                currentJobsBean.setJobPool(cursor.getBoolean(37));
                if (cursor.getBoolean(37)) {
                    currentJobsBean.setDatePref(cursor.getString(38));
                    currentJobsBean.setIdJobWindow(cursor.getInt(39));
                }


                currentJobsBeans.add(currentJobsBean);

            }
            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
                currentJobsBeans, numberOfJob);
        return currentJobsBeans;
    }

    public synchronized String getClientFirstName(int clientId) {

        String clientFirstName = null;

        String query;

        query = "SELECT PRENOM_CONTACT_CLIENT " +
                "FROM T_CLIENTS "
                + " WHERE ID_CLIENT =" + clientId + "";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientFirstName = cursor.getString(1);

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return clientFirstName;

    }

    public synchronized String getClientLastName(int clientId) {

        String clientFirstName = null;

        String query;

        query = "SELECT NOM_CONTACT_CLIENT " +
                "FROM T_CLIENTS "
                + " WHERE ID_CLIENT =" + clientId + "";
        //Connection connection = getConnectionObj();
        PreparedStatement preparedStatement = null;
        ResultSet cursor = null;
        try {
            preparedStatement = getConnectionObj().prepareStatement(query);
            cursor = preparedStatement.executeQuery();
            while (cursor.next()) {
                clientFirstName = cursor.getString(1);

            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return clientFirstName;

    }

//    public String isItemPreset(String idRemortFacture,int idPiece) {
//        String sql = "SELECT ID_REMOTE_FACTURE FROM T_LIGNES_FACTURE "
//        +"WHERE ID_REMOTE_FACTURE = '" + idRemortFacture + "'"
//        +"AND ID_PIECE ='" + idPiece + "'";
//        try {
//            PreparedStatement stmt = connDao.prepareStatement(sql);
//            ResultSet cursor = stmt.executeQuery();
//            while (cursor.next()) {
//                return encodeString(cursor.getBytes(1));
//            }
//            cursor.close();
//            stmt.close();
//            connDao.commit();
//            return null;
//        } catch (Exception e) {
//            return null;
//        }
//    }

    public synchronized ArrayList<Invoice_Quotation_Items_Beans> isItemPreset(String idRemortFacture,int idTaxRate,double total,String itemName,String description) {

        ArrayList<Invoice_Quotation_Items_Beans> invoiceQuotationList = new ArrayList<Invoice_Quotation_Items_Beans>();
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

//            //new changes
//            String sql = "SELECT * FROM T_LIGNES_FACTURE "
//                    +"WHERE ID_REMOTE_FACTURE = '" + idRemortFacture + "'"
//                    +"AND ID_PIECE ='" + idPiece + "'";

//            String sql=   "SELECT * FROM T_LIGNES_FACTURE "
//                    +"WHERE ID_REMOTE_FACTURE = '" + idRemortFacture + "'"
//                                        +"AND (REF_LIGNE !='" + itemName + "'"
//            +"AND DESCR_LIGNE !='" + description + "'"
//                    +")";

            String sql= "SELECT * FROM T_LIGNES_FACTURE WHERE ID_REMOTE_FACTURE = '" + idRemortFacture +"'"+
                    "AND ID_TAXRATE = '" + idTaxRate +"'"+
                    "AND TOTAL_HT = '" + total +"'" +
                    "AND REF_LIGNE LIKE '" + itemName +"'" +
                    "AND DESCR_LIGNE LIKE '" + description +"'" ;

            stmt = getConnectionObj().prepareStatement(sql);

            cursor = stmt.executeQuery();

            Invoice_Quotation_Items_Beans invoiceQuotationBeans = null;

            while (cursor.next()) {
                invoiceQuotationBeans = new Invoice_Quotation_Items_Beans();
                invoiceQuotationBeans.setItem(cursor.getString(1));
                invoiceQuotationBeans.setDescription(cursor.getString(2));
                invoiceQuotationBeans.setUnitPrice(cursor.getDouble(3));
                invoiceQuotationBeans.setQuantity(cursor.getDouble(4));
                invoiceQuotationBeans.setTax(cursor.getDouble(5));
                invoiceQuotationBeans.setOrder(cursor.getInt(6));
                invoiceQuotationBeans.setDiscount(cursor.getDouble(8));
                invoiceQuotationBeans.setTotal(cursor.getDouble(9));
                invoiceQuotationBeans.setTaxValue(cursor.getDouble(10));
                invoiceQuotationBeans.setTotalWIthTax(cursor.getDouble(11));
                invoiceQuotationBeans.setId(cursor.getString(12));
                invoiceQuotationBeans.setDescriptionItem(cursor.getString(16));
                invoiceQuotationBeans.setTaxName(getTaxNameById(cursor.getInt(14)));
                invoiceQuotationBeans.setPercent(cursor.getBoolean(18));
                invoiceQuotationBeans.setIdTaxRate("" + cursor.getInt(14));

                invoiceQuotationList.add(invoiceQuotationBeans);
            }
        } catch (Exception exc) {
            Logger.printException(exc);
            exc.printStackTrace();
        } finally {
            if (cursor != null) {
                try {
                    cursor.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            try {
                connDao.commit();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return invoiceQuotationList;
    }
    public synchronized int getJobPoolSearchWithCount(String value) {

        String query;
        int numberOfJob = 0;
        PreparedStatement stmt = null;
        ResultSet cursor = null;
        try {

            query = "SELECT COUNT(ID_INTERVENTION) "
                    + "FROM T_INTERVENTIONS,TREF_TYPE_INTERVENTION "
                    + "WHERE "
                    + "T_INTERVENTIONS.ID_TYPE_INTERVENTION=TREF_TYPE_INTERVENTION.ID_TYPE_INTERVENTION "
                    + "AND CD_STATUT_INTERV = "
                    + KEYS.CurrentJobs.JOB_POOL_SCHEDULE + " "
                    + "AND T_INTERVENTIONS.FL_POOL=1"
                    +"AND (" +
                    "TREF_TYPE_INTERVENTION.NM_TYPE_INTERVENTION LIKE '%" + value + "%' " +
                    "OR NOM_CLIENT_INTERV LIKE '%" + value + "%' " +
                    "OR REF_CUSTOMER LIKE '%" + value + "%'" +
                    "OR NO_INT_CUST LIKE '%" + value + "%'" +
                    " OR NOM_SITE_INTERV LIKE '%" + value + "%'"+
                    " OR NOM_EQUIPEMENT_INTERV LIKE '%" + value + "%'"+
                    ") ORDER BY NOM_CLIENT_INTERV";

            stmt = getConnectionObj().prepareStatement(query);

            cursor = stmt.executeQuery();

            cursor.first();

            numberOfJob = cursor.getInt(1);

            cursor.close();
            stmt.close();
//            connDao.commit();

        } catch (Exception exc) {
            Logger.printException(exc);
        }
//        CurrentJobDataBean currentJobDataBean = new CurrentJobDataBean(
//                currentJobsBeans, numberOfJob);
        return numberOfJob;
    }



}